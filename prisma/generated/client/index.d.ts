
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Project
 * 
 */
export type Project = $Result.DefaultSelection<Prisma.$ProjectPayload>
/**
 * Model ProjectFile
 * 
 */
export type ProjectFile = $Result.DefaultSelection<Prisma.$ProjectFilePayload>
/**
 * Model ProjectUpdate
 * 
 */
export type ProjectUpdate = $Result.DefaultSelection<Prisma.$ProjectUpdatePayload>
/**
 * Model SupportRequest
 * 
 */
export type SupportRequest = $Result.DefaultSelection<Prisma.$SupportRequestPayload>
/**
 * Model SupportMessage
 * 
 */
export type SupportMessage = $Result.DefaultSelection<Prisma.$SupportMessagePayload>
/**
 * Model MeetingRequest
 * 
 */
export type MeetingRequest = $Result.DefaultSelection<Prisma.$MeetingRequestPayload>
/**
 * Model Invoice
 * 
 */
export type Invoice = $Result.DefaultSelection<Prisma.$InvoicePayload>
/**
 * Model Payment
 * 
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model Attendance
 * 
 */
export type Attendance = $Result.DefaultSelection<Prisma.$AttendancePayload>
/**
 * Model LabourAllocation
 * 
 */
export type LabourAllocation = $Result.DefaultSelection<Prisma.$LabourAllocationPayload>
/**
 * Model Payroll
 * 
 */
export type Payroll = $Result.DefaultSelection<Prisma.$PayrollPayload>
/**
 * Model PayrollLine
 * 
 */
export type PayrollLine = $Result.DefaultSelection<Prisma.$PayrollLinePayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model SystemSettings
 * 
 */
export type SystemSettings = $Result.DefaultSelection<Prisma.$SystemSettingsPayload>
/**
 * Model Transaction
 * 
 */
export type Transaction = $Result.DefaultSelection<Prisma.$TransactionPayload>
/**
 * Model InventoryItem
 * 
 */
export type InventoryItem = $Result.DefaultSelection<Prisma.$InventoryItemPayload>
/**
 * Model InventoryTransaction
 * 
 */
export type InventoryTransaction = $Result.DefaultSelection<Prisma.$InventoryTransactionPayload>
/**
 * Model PurchaseRequest
 * 
 */
export type PurchaseRequest = $Result.DefaultSelection<Prisma.$PurchaseRequestPayload>
/**
 * Model Vendor
 * 
 */
export type Vendor = $Result.DefaultSelection<Prisma.$VendorPayload>
/**
 * Model PurchaseOrder
 * 
 */
export type PurchaseOrder = $Result.DefaultSelection<Prisma.$PurchaseOrderPayload>
/**
 * Model GRN
 * 
 */
export type GRN = $Result.DefaultSelection<Prisma.$GRNPayload>
/**
 * Model VendorBill
 * 
 */
export type VendorBill = $Result.DefaultSelection<Prisma.$VendorBillPayload>
/**
 * Model VendorPayment
 * 
 */
export type VendorPayment = $Result.DefaultSelection<Prisma.$VendorPaymentPayload>
/**
 * Model BankAccount
 * 
 */
export type BankAccount = $Result.DefaultSelection<Prisma.$BankAccountPayload>
/**
 * Model BankTransaction
 * 
 */
export type BankTransaction = $Result.DefaultSelection<Prisma.$BankTransactionPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const UserRole: {
  client: 'client',
  admin: 'admin'
};

export type UserRole = (typeof UserRole)[keyof typeof UserRole]


export const ProjectStatus: {
  pending: 'pending',
  under_review: 'under_review',
  accepted: 'accepted',
  in_progress: 'in_progress',
  testing: 'testing',
  completed: 'completed',
  cancelled: 'cancelled'
};

export type ProjectStatus = (typeof ProjectStatus)[keyof typeof ProjectStatus]


export const FileType: {
  document: 'document',
  voice_note: 'voice_note',
  image: 'image',
  other: 'other'
};

export type FileType = (typeof FileType)[keyof typeof FileType]


export const SupportStatus: {
  open: 'open',
  in_progress: 'in_progress',
  resolved: 'resolved',
  closed: 'closed'
};

export type SupportStatus = (typeof SupportStatus)[keyof typeof SupportStatus]


export const PriorityLevel: {
  low: 'low',
  medium: 'medium',
  high: 'high'
};

export type PriorityLevel = (typeof PriorityLevel)[keyof typeof PriorityLevel]


export const MeetingStatus: {
  pending: 'pending',
  accepted: 'accepted',
  declined: 'declined',
  completed: 'completed'
};

export type MeetingStatus = (typeof MeetingStatus)[keyof typeof MeetingStatus]


export const InvoiceStatus: {
  pending: 'pending',
  paid: 'paid',
  overdue: 'overdue',
  cancelled: 'cancelled'
};

export type InvoiceStatus = (typeof InvoiceStatus)[keyof typeof InvoiceStatus]


export const MemberStatus: {
  active: 'active',
  inactive: 'inactive'
};

export type MemberStatus = (typeof MemberStatus)[keyof typeof MemberStatus]


export const NotificationType: {
  project: 'project',
  payment: 'payment',
  support: 'support',
  meeting: 'meeting',
  system: 'system'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const TransactionType: {
  income: 'income',
  expense: 'expense'
};

export type TransactionType = (typeof TransactionType)[keyof typeof TransactionType]


export const InventoryTransactionType: {
  stock_in: 'stock_in',
  stock_out: 'stock_out',
  issue_to_project: 'issue_to_project',
  return_from_project: 'return_from_project',
  scrap: 'scrap',
  wastage: 'wastage'
};

export type InventoryTransactionType = (typeof InventoryTransactionType)[keyof typeof InventoryTransactionType]


export const PurchaseStatus: {
  pending: 'pending',
  approved: 'approved',
  ordered: 'ordered',
  received: 'received',
  billed: 'billed',
  paid: 'paid',
  cancelled: 'cancelled'
};

export type PurchaseStatus = (typeof PurchaseStatus)[keyof typeof PurchaseStatus]

}

export type UserRole = $Enums.UserRole

export const UserRole: typeof $Enums.UserRole

export type ProjectStatus = $Enums.ProjectStatus

export const ProjectStatus: typeof $Enums.ProjectStatus

export type FileType = $Enums.FileType

export const FileType: typeof $Enums.FileType

export type SupportStatus = $Enums.SupportStatus

export const SupportStatus: typeof $Enums.SupportStatus

export type PriorityLevel = $Enums.PriorityLevel

export const PriorityLevel: typeof $Enums.PriorityLevel

export type MeetingStatus = $Enums.MeetingStatus

export const MeetingStatus: typeof $Enums.MeetingStatus

export type InvoiceStatus = $Enums.InvoiceStatus

export const InvoiceStatus: typeof $Enums.InvoiceStatus

export type MemberStatus = $Enums.MemberStatus

export const MemberStatus: typeof $Enums.MemberStatus

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type TransactionType = $Enums.TransactionType

export const TransactionType: typeof $Enums.TransactionType

export type InventoryTransactionType = $Enums.InventoryTransactionType

export const InventoryTransactionType: typeof $Enums.InventoryTransactionType

export type PurchaseStatus = $Enums.PurchaseStatus

export const PurchaseStatus: typeof $Enums.PurchaseStatus

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.project`: Exposes CRUD operations for the **Project** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Projects
    * const projects = await prisma.project.findMany()
    * ```
    */
  get project(): Prisma.ProjectDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectFile`: Exposes CRUD operations for the **ProjectFile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectFiles
    * const projectFiles = await prisma.projectFile.findMany()
    * ```
    */
  get projectFile(): Prisma.ProjectFileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.projectUpdate`: Exposes CRUD operations for the **ProjectUpdate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ProjectUpdates
    * const projectUpdates = await prisma.projectUpdate.findMany()
    * ```
    */
  get projectUpdate(): Prisma.ProjectUpdateDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supportRequest`: Exposes CRUD operations for the **SupportRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupportRequests
    * const supportRequests = await prisma.supportRequest.findMany()
    * ```
    */
  get supportRequest(): Prisma.SupportRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.supportMessage`: Exposes CRUD operations for the **SupportMessage** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SupportMessages
    * const supportMessages = await prisma.supportMessage.findMany()
    * ```
    */
  get supportMessage(): Prisma.SupportMessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.meetingRequest`: Exposes CRUD operations for the **MeetingRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more MeetingRequests
    * const meetingRequests = await prisma.meetingRequest.findMany()
    * ```
    */
  get meetingRequest(): Prisma.MeetingRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.invoice`: Exposes CRUD operations for the **Invoice** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Invoices
    * const invoices = await prisma.invoice.findMany()
    * ```
    */
  get invoice(): Prisma.InvoiceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendance`: Exposes CRUD operations for the **Attendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendance.findMany()
    * ```
    */
  get attendance(): Prisma.AttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.labourAllocation`: Exposes CRUD operations for the **LabourAllocation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LabourAllocations
    * const labourAllocations = await prisma.labourAllocation.findMany()
    * ```
    */
  get labourAllocation(): Prisma.LabourAllocationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payroll`: Exposes CRUD operations for the **Payroll** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payrolls
    * const payrolls = await prisma.payroll.findMany()
    * ```
    */
  get payroll(): Prisma.PayrollDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payrollLine`: Exposes CRUD operations for the **PayrollLine** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PayrollLines
    * const payrollLines = await prisma.payrollLine.findMany()
    * ```
    */
  get payrollLine(): Prisma.PayrollLineDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.systemSettings`: Exposes CRUD operations for the **SystemSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SystemSettings
    * const systemSettings = await prisma.systemSettings.findMany()
    * ```
    */
  get systemSettings(): Prisma.SystemSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.transaction`: Exposes CRUD operations for the **Transaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Transactions
    * const transactions = await prisma.transaction.findMany()
    * ```
    */
  get transaction(): Prisma.TransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryItem`: Exposes CRUD operations for the **InventoryItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryItems
    * const inventoryItems = await prisma.inventoryItem.findMany()
    * ```
    */
  get inventoryItem(): Prisma.InventoryItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.inventoryTransaction`: Exposes CRUD operations for the **InventoryTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InventoryTransactions
    * const inventoryTransactions = await prisma.inventoryTransaction.findMany()
    * ```
    */
  get inventoryTransaction(): Prisma.InventoryTransactionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseRequest`: Exposes CRUD operations for the **PurchaseRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseRequests
    * const purchaseRequests = await prisma.purchaseRequest.findMany()
    * ```
    */
  get purchaseRequest(): Prisma.PurchaseRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendor`: Exposes CRUD operations for the **Vendor** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vendors
    * const vendors = await prisma.vendor.findMany()
    * ```
    */
  get vendor(): Prisma.VendorDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.purchaseOrder`: Exposes CRUD operations for the **PurchaseOrder** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PurchaseOrders
    * const purchaseOrders = await prisma.purchaseOrder.findMany()
    * ```
    */
  get purchaseOrder(): Prisma.PurchaseOrderDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.gRN`: Exposes CRUD operations for the **GRN** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more GRNS
    * const gRNS = await prisma.gRN.findMany()
    * ```
    */
  get gRN(): Prisma.GRNDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendorBill`: Exposes CRUD operations for the **VendorBill** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VendorBills
    * const vendorBills = await prisma.vendorBill.findMany()
    * ```
    */
  get vendorBill(): Prisma.VendorBillDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vendorPayment`: Exposes CRUD operations for the **VendorPayment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VendorPayments
    * const vendorPayments = await prisma.vendorPayment.findMany()
    * ```
    */
  get vendorPayment(): Prisma.VendorPaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bankAccount`: Exposes CRUD operations for the **BankAccount** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BankAccounts
    * const bankAccounts = await prisma.bankAccount.findMany()
    * ```
    */
  get bankAccount(): Prisma.BankAccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bankTransaction`: Exposes CRUD operations for the **BankTransaction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BankTransactions
    * const bankTransactions = await prisma.bankTransaction.findMany()
    * ```
    */
  get bankTransaction(): Prisma.BankTransactionDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.3.0
   * Query Engine version: 9d6ad21cbbceab97458517b147a6a09ff43aa735
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Project: 'Project',
    ProjectFile: 'ProjectFile',
    ProjectUpdate: 'ProjectUpdate',
    SupportRequest: 'SupportRequest',
    SupportMessage: 'SupportMessage',
    MeetingRequest: 'MeetingRequest',
    Invoice: 'Invoice',
    Payment: 'Payment',
    Employee: 'Employee',
    Attendance: 'Attendance',
    LabourAllocation: 'LabourAllocation',
    Payroll: 'Payroll',
    PayrollLine: 'PayrollLine',
    Notification: 'Notification',
    SystemSettings: 'SystemSettings',
    Transaction: 'Transaction',
    InventoryItem: 'InventoryItem',
    InventoryTransaction: 'InventoryTransaction',
    PurchaseRequest: 'PurchaseRequest',
    Vendor: 'Vendor',
    PurchaseOrder: 'PurchaseOrder',
    GRN: 'GRN',
    VendorBill: 'VendorBill',
    VendorPayment: 'VendorPayment',
    BankAccount: 'BankAccount',
    BankTransaction: 'BankTransaction'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "project" | "projectFile" | "projectUpdate" | "supportRequest" | "supportMessage" | "meetingRequest" | "invoice" | "payment" | "employee" | "attendance" | "labourAllocation" | "payroll" | "payrollLine" | "notification" | "systemSettings" | "transaction" | "inventoryItem" | "inventoryTransaction" | "purchaseRequest" | "vendor" | "purchaseOrder" | "gRN" | "vendorBill" | "vendorPayment" | "bankAccount" | "bankTransaction"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Project: {
        payload: Prisma.$ProjectPayload<ExtArgs>
        fields: Prisma.ProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findFirst: {
            args: Prisma.ProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          findMany: {
            args: Prisma.ProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          create: {
            args: Prisma.ProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          createMany: {
            args: Prisma.ProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          delete: {
            args: Prisma.ProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          update: {
            args: Prisma.ProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          deleteMany: {
            args: Prisma.ProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectPayload>
          }
          aggregate: {
            args: Prisma.ProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProject>
          }
          groupBy: {
            args: Prisma.ProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectCountAggregateOutputType> | number
          }
        }
      }
      ProjectFile: {
        payload: Prisma.$ProjectFilePayload<ExtArgs>
        fields: Prisma.ProjectFileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectFileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectFileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFilePayload>
          }
          findFirst: {
            args: Prisma.ProjectFileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectFileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFilePayload>
          }
          findMany: {
            args: Prisma.ProjectFileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFilePayload>[]
          }
          create: {
            args: Prisma.ProjectFileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFilePayload>
          }
          createMany: {
            args: Prisma.ProjectFileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectFileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFilePayload>[]
          }
          delete: {
            args: Prisma.ProjectFileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFilePayload>
          }
          update: {
            args: Prisma.ProjectFileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFilePayload>
          }
          deleteMany: {
            args: Prisma.ProjectFileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectFileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectFileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFilePayload>[]
          }
          upsert: {
            args: Prisma.ProjectFileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectFilePayload>
          }
          aggregate: {
            args: Prisma.ProjectFileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectFile>
          }
          groupBy: {
            args: Prisma.ProjectFileGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectFileGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectFileCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectFileCountAggregateOutputType> | number
          }
        }
      }
      ProjectUpdate: {
        payload: Prisma.$ProjectUpdatePayload<ExtArgs>
        fields: Prisma.ProjectUpdateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProjectUpdateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUpdatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProjectUpdateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>
          }
          findFirst: {
            args: Prisma.ProjectUpdateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUpdatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProjectUpdateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>
          }
          findMany: {
            args: Prisma.ProjectUpdateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>[]
          }
          create: {
            args: Prisma.ProjectUpdateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>
          }
          createMany: {
            args: Prisma.ProjectUpdateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProjectUpdateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>[]
          }
          delete: {
            args: Prisma.ProjectUpdateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>
          }
          update: {
            args: Prisma.ProjectUpdateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>
          }
          deleteMany: {
            args: Prisma.ProjectUpdateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProjectUpdateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ProjectUpdateUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>[]
          }
          upsert: {
            args: Prisma.ProjectUpdateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProjectUpdatePayload>
          }
          aggregate: {
            args: Prisma.ProjectUpdateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProjectUpdate>
          }
          groupBy: {
            args: Prisma.ProjectUpdateGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProjectUpdateGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProjectUpdateCountArgs<ExtArgs>
            result: $Utils.Optional<ProjectUpdateCountAggregateOutputType> | number
          }
        }
      }
      SupportRequest: {
        payload: Prisma.$SupportRequestPayload<ExtArgs>
        fields: Prisma.SupportRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupportRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupportRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportRequestPayload>
          }
          findFirst: {
            args: Prisma.SupportRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupportRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportRequestPayload>
          }
          findMany: {
            args: Prisma.SupportRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportRequestPayload>[]
          }
          create: {
            args: Prisma.SupportRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportRequestPayload>
          }
          createMany: {
            args: Prisma.SupportRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupportRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportRequestPayload>[]
          }
          delete: {
            args: Prisma.SupportRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportRequestPayload>
          }
          update: {
            args: Prisma.SupportRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportRequestPayload>
          }
          deleteMany: {
            args: Prisma.SupportRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupportRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupportRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportRequestPayload>[]
          }
          upsert: {
            args: Prisma.SupportRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportRequestPayload>
          }
          aggregate: {
            args: Prisma.SupportRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupportRequest>
          }
          groupBy: {
            args: Prisma.SupportRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupportRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupportRequestCountArgs<ExtArgs>
            result: $Utils.Optional<SupportRequestCountAggregateOutputType> | number
          }
        }
      }
      SupportMessage: {
        payload: Prisma.$SupportMessagePayload<ExtArgs>
        fields: Prisma.SupportMessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SupportMessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SupportMessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>
          }
          findFirst: {
            args: Prisma.SupportMessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SupportMessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>
          }
          findMany: {
            args: Prisma.SupportMessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>[]
          }
          create: {
            args: Prisma.SupportMessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>
          }
          createMany: {
            args: Prisma.SupportMessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SupportMessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>[]
          }
          delete: {
            args: Prisma.SupportMessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>
          }
          update: {
            args: Prisma.SupportMessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>
          }
          deleteMany: {
            args: Prisma.SupportMessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SupportMessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SupportMessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>[]
          }
          upsert: {
            args: Prisma.SupportMessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SupportMessagePayload>
          }
          aggregate: {
            args: Prisma.SupportMessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSupportMessage>
          }
          groupBy: {
            args: Prisma.SupportMessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<SupportMessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.SupportMessageCountArgs<ExtArgs>
            result: $Utils.Optional<SupportMessageCountAggregateOutputType> | number
          }
        }
      }
      MeetingRequest: {
        payload: Prisma.$MeetingRequestPayload<ExtArgs>
        fields: Prisma.MeetingRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MeetingRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MeetingRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingRequestPayload>
          }
          findFirst: {
            args: Prisma.MeetingRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MeetingRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingRequestPayload>
          }
          findMany: {
            args: Prisma.MeetingRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingRequestPayload>[]
          }
          create: {
            args: Prisma.MeetingRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingRequestPayload>
          }
          createMany: {
            args: Prisma.MeetingRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MeetingRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingRequestPayload>[]
          }
          delete: {
            args: Prisma.MeetingRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingRequestPayload>
          }
          update: {
            args: Prisma.MeetingRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingRequestPayload>
          }
          deleteMany: {
            args: Prisma.MeetingRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MeetingRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MeetingRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingRequestPayload>[]
          }
          upsert: {
            args: Prisma.MeetingRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MeetingRequestPayload>
          }
          aggregate: {
            args: Prisma.MeetingRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMeetingRequest>
          }
          groupBy: {
            args: Prisma.MeetingRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<MeetingRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.MeetingRequestCountArgs<ExtArgs>
            result: $Utils.Optional<MeetingRequestCountAggregateOutputType> | number
          }
        }
      }
      Invoice: {
        payload: Prisma.$InvoicePayload<ExtArgs>
        fields: Prisma.InvoiceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InvoiceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InvoiceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findFirst: {
            args: Prisma.InvoiceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InvoiceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          findMany: {
            args: Prisma.InvoiceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          create: {
            args: Prisma.InvoiceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          createMany: {
            args: Prisma.InvoiceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InvoiceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          delete: {
            args: Prisma.InvoiceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          update: {
            args: Prisma.InvoiceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          deleteMany: {
            args: Prisma.InvoiceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InvoiceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InvoiceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>[]
          }
          upsert: {
            args: Prisma.InvoiceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InvoicePayload>
          }
          aggregate: {
            args: Prisma.InvoiceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInvoice>
          }
          groupBy: {
            args: Prisma.InvoiceGroupByArgs<ExtArgs>
            result: $Utils.Optional<InvoiceGroupByOutputType>[]
          }
          count: {
            args: Prisma.InvoiceCountArgs<ExtArgs>
            result: $Utils.Optional<InvoiceCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmployeeUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      Attendance: {
        payload: Prisma.$AttendancePayload<ExtArgs>
        fields: Prisma.AttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findFirst: {
            args: Prisma.AttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findMany: {
            args: Prisma.AttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          create: {
            args: Prisma.AttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          createMany: {
            args: Prisma.AttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          delete: {
            args: Prisma.AttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          update: {
            args: Prisma.AttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          deleteMany: {
            args: Prisma.AttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          upsert: {
            args: Prisma.AttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          aggregate: {
            args: Prisma.AttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendance>
          }
          groupBy: {
            args: Prisma.AttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceCountAggregateOutputType> | number
          }
        }
      }
      LabourAllocation: {
        payload: Prisma.$LabourAllocationPayload<ExtArgs>
        fields: Prisma.LabourAllocationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LabourAllocationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourAllocationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LabourAllocationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourAllocationPayload>
          }
          findFirst: {
            args: Prisma.LabourAllocationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourAllocationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LabourAllocationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourAllocationPayload>
          }
          findMany: {
            args: Prisma.LabourAllocationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourAllocationPayload>[]
          }
          create: {
            args: Prisma.LabourAllocationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourAllocationPayload>
          }
          createMany: {
            args: Prisma.LabourAllocationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LabourAllocationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourAllocationPayload>[]
          }
          delete: {
            args: Prisma.LabourAllocationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourAllocationPayload>
          }
          update: {
            args: Prisma.LabourAllocationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourAllocationPayload>
          }
          deleteMany: {
            args: Prisma.LabourAllocationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LabourAllocationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LabourAllocationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourAllocationPayload>[]
          }
          upsert: {
            args: Prisma.LabourAllocationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LabourAllocationPayload>
          }
          aggregate: {
            args: Prisma.LabourAllocationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLabourAllocation>
          }
          groupBy: {
            args: Prisma.LabourAllocationGroupByArgs<ExtArgs>
            result: $Utils.Optional<LabourAllocationGroupByOutputType>[]
          }
          count: {
            args: Prisma.LabourAllocationCountArgs<ExtArgs>
            result: $Utils.Optional<LabourAllocationCountAggregateOutputType> | number
          }
        }
      }
      Payroll: {
        payload: Prisma.$PayrollPayload<ExtArgs>
        fields: Prisma.PayrollFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayrollFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayrollFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          findFirst: {
            args: Prisma.PayrollFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayrollFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          findMany: {
            args: Prisma.PayrollFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>[]
          }
          create: {
            args: Prisma.PayrollCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          createMany: {
            args: Prisma.PayrollCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PayrollCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>[]
          }
          delete: {
            args: Prisma.PayrollDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          update: {
            args: Prisma.PayrollUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          deleteMany: {
            args: Prisma.PayrollDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PayrollUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PayrollUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>[]
          }
          upsert: {
            args: Prisma.PayrollUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollPayload>
          }
          aggregate: {
            args: Prisma.PayrollAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayroll>
          }
          groupBy: {
            args: Prisma.PayrollGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayrollGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayrollCountArgs<ExtArgs>
            result: $Utils.Optional<PayrollCountAggregateOutputType> | number
          }
        }
      }
      PayrollLine: {
        payload: Prisma.$PayrollLinePayload<ExtArgs>
        fields: Prisma.PayrollLineFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayrollLineFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollLinePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayrollLineFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollLinePayload>
          }
          findFirst: {
            args: Prisma.PayrollLineFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollLinePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayrollLineFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollLinePayload>
          }
          findMany: {
            args: Prisma.PayrollLineFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollLinePayload>[]
          }
          create: {
            args: Prisma.PayrollLineCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollLinePayload>
          }
          createMany: {
            args: Prisma.PayrollLineCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PayrollLineCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollLinePayload>[]
          }
          delete: {
            args: Prisma.PayrollLineDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollLinePayload>
          }
          update: {
            args: Prisma.PayrollLineUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollLinePayload>
          }
          deleteMany: {
            args: Prisma.PayrollLineDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PayrollLineUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PayrollLineUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollLinePayload>[]
          }
          upsert: {
            args: Prisma.PayrollLineUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollLinePayload>
          }
          aggregate: {
            args: Prisma.PayrollLineAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayrollLine>
          }
          groupBy: {
            args: Prisma.PayrollLineGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayrollLineGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayrollLineCountArgs<ExtArgs>
            result: $Utils.Optional<PayrollLineCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      SystemSettings: {
        payload: Prisma.$SystemSettingsPayload<ExtArgs>
        fields: Prisma.SystemSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SystemSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SystemSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          findFirst: {
            args: Prisma.SystemSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SystemSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          findMany: {
            args: Prisma.SystemSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>[]
          }
          create: {
            args: Prisma.SystemSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          createMany: {
            args: Prisma.SystemSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SystemSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>[]
          }
          delete: {
            args: Prisma.SystemSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          update: {
            args: Prisma.SystemSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          deleteMany: {
            args: Prisma.SystemSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SystemSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SystemSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>[]
          }
          upsert: {
            args: Prisma.SystemSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SystemSettingsPayload>
          }
          aggregate: {
            args: Prisma.SystemSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSystemSettings>
          }
          groupBy: {
            args: Prisma.SystemSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.SystemSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<SystemSettingsCountAggregateOutputType> | number
          }
        }
      }
      Transaction: {
        payload: Prisma.$TransactionPayload<ExtArgs>
        fields: Prisma.TransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findFirst: {
            args: Prisma.TransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          findMany: {
            args: Prisma.TransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          create: {
            args: Prisma.TransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          createMany: {
            args: Prisma.TransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          delete: {
            args: Prisma.TransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          update: {
            args: Prisma.TransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          deleteMany: {
            args: Prisma.TransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>[]
          }
          upsert: {
            args: Prisma.TransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TransactionPayload>
          }
          aggregate: {
            args: Prisma.TransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTransaction>
          }
          groupBy: {
            args: Prisma.TransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TransactionCountArgs<ExtArgs>
            result: $Utils.Optional<TransactionCountAggregateOutputType> | number
          }
        }
      }
      InventoryItem: {
        payload: Prisma.$InventoryItemPayload<ExtArgs>
        fields: Prisma.InventoryItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findFirst: {
            args: Prisma.InventoryItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          findMany: {
            args: Prisma.InventoryItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          create: {
            args: Prisma.InventoryItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          createMany: {
            args: Prisma.InventoryItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          delete: {
            args: Prisma.InventoryItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          update: {
            args: Prisma.InventoryItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          deleteMany: {
            args: Prisma.InventoryItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>[]
          }
          upsert: {
            args: Prisma.InventoryItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryItemPayload>
          }
          aggregate: {
            args: Prisma.InventoryItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryItem>
          }
          groupBy: {
            args: Prisma.InventoryItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryItemCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryItemCountAggregateOutputType> | number
          }
        }
      }
      InventoryTransaction: {
        payload: Prisma.$InventoryTransactionPayload<ExtArgs>
        fields: Prisma.InventoryTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InventoryTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InventoryTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          findFirst: {
            args: Prisma.InventoryTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InventoryTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          findMany: {
            args: Prisma.InventoryTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>[]
          }
          create: {
            args: Prisma.InventoryTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          createMany: {
            args: Prisma.InventoryTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InventoryTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>[]
          }
          delete: {
            args: Prisma.InventoryTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          update: {
            args: Prisma.InventoryTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          deleteMany: {
            args: Prisma.InventoryTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InventoryTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.InventoryTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>[]
          }
          upsert: {
            args: Prisma.InventoryTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InventoryTransactionPayload>
          }
          aggregate: {
            args: Prisma.InventoryTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInventoryTransaction>
          }
          groupBy: {
            args: Prisma.InventoryTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InventoryTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InventoryTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<InventoryTransactionCountAggregateOutputType> | number
          }
        }
      }
      PurchaseRequest: {
        payload: Prisma.$PurchaseRequestPayload<ExtArgs>
        fields: Prisma.PurchaseRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseRequestPayload>
          }
          findFirst: {
            args: Prisma.PurchaseRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseRequestPayload>
          }
          findMany: {
            args: Prisma.PurchaseRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseRequestPayload>[]
          }
          create: {
            args: Prisma.PurchaseRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseRequestPayload>
          }
          createMany: {
            args: Prisma.PurchaseRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseRequestPayload>[]
          }
          delete: {
            args: Prisma.PurchaseRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseRequestPayload>
          }
          update: {
            args: Prisma.PurchaseRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseRequestPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseRequestPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseRequestPayload>
          }
          aggregate: {
            args: Prisma.PurchaseRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseRequest>
          }
          groupBy: {
            args: Prisma.PurchaseRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseRequestCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseRequestCountAggregateOutputType> | number
          }
        }
      }
      Vendor: {
        payload: Prisma.$VendorPayload<ExtArgs>
        fields: Prisma.VendorFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findFirst: {
            args: Prisma.VendorFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          findMany: {
            args: Prisma.VendorFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          create: {
            args: Prisma.VendorCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          createMany: {
            args: Prisma.VendorCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          delete: {
            args: Prisma.VendorDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          update: {
            args: Prisma.VendorUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          deleteMany: {
            args: Prisma.VendorDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VendorUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>[]
          }
          upsert: {
            args: Prisma.VendorUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPayload>
          }
          aggregate: {
            args: Prisma.VendorAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendor>
          }
          groupBy: {
            args: Prisma.VendorGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorCountArgs<ExtArgs>
            result: $Utils.Optional<VendorCountAggregateOutputType> | number
          }
        }
      }
      PurchaseOrder: {
        payload: Prisma.$PurchaseOrderPayload<ExtArgs>
        fields: Prisma.PurchaseOrderFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PurchaseOrderFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findFirst: {
            args: Prisma.PurchaseOrderFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PurchaseOrderFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          findMany: {
            args: Prisma.PurchaseOrderFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          create: {
            args: Prisma.PurchaseOrderCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          createMany: {
            args: Prisma.PurchaseOrderCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PurchaseOrderCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          delete: {
            args: Prisma.PurchaseOrderDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          update: {
            args: Prisma.PurchaseOrderUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          deleteMany: {
            args: Prisma.PurchaseOrderDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PurchaseOrderUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PurchaseOrderUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>[]
          }
          upsert: {
            args: Prisma.PurchaseOrderUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PurchaseOrderPayload>
          }
          aggregate: {
            args: Prisma.PurchaseOrderAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePurchaseOrder>
          }
          groupBy: {
            args: Prisma.PurchaseOrderGroupByArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderGroupByOutputType>[]
          }
          count: {
            args: Prisma.PurchaseOrderCountArgs<ExtArgs>
            result: $Utils.Optional<PurchaseOrderCountAggregateOutputType> | number
          }
        }
      }
      GRN: {
        payload: Prisma.$GRNPayload<ExtArgs>
        fields: Prisma.GRNFieldRefs
        operations: {
          findUnique: {
            args: Prisma.GRNFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GRNPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.GRNFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GRNPayload>
          }
          findFirst: {
            args: Prisma.GRNFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GRNPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.GRNFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GRNPayload>
          }
          findMany: {
            args: Prisma.GRNFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GRNPayload>[]
          }
          create: {
            args: Prisma.GRNCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GRNPayload>
          }
          createMany: {
            args: Prisma.GRNCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.GRNCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GRNPayload>[]
          }
          delete: {
            args: Prisma.GRNDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GRNPayload>
          }
          update: {
            args: Prisma.GRNUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GRNPayload>
          }
          deleteMany: {
            args: Prisma.GRNDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.GRNUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.GRNUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GRNPayload>[]
          }
          upsert: {
            args: Prisma.GRNUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$GRNPayload>
          }
          aggregate: {
            args: Prisma.GRNAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateGRN>
          }
          groupBy: {
            args: Prisma.GRNGroupByArgs<ExtArgs>
            result: $Utils.Optional<GRNGroupByOutputType>[]
          }
          count: {
            args: Prisma.GRNCountArgs<ExtArgs>
            result: $Utils.Optional<GRNCountAggregateOutputType> | number
          }
        }
      }
      VendorBill: {
        payload: Prisma.$VendorBillPayload<ExtArgs>
        fields: Prisma.VendorBillFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorBillFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorBillPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorBillFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorBillPayload>
          }
          findFirst: {
            args: Prisma.VendorBillFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorBillPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorBillFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorBillPayload>
          }
          findMany: {
            args: Prisma.VendorBillFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorBillPayload>[]
          }
          create: {
            args: Prisma.VendorBillCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorBillPayload>
          }
          createMany: {
            args: Prisma.VendorBillCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorBillCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorBillPayload>[]
          }
          delete: {
            args: Prisma.VendorBillDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorBillPayload>
          }
          update: {
            args: Prisma.VendorBillUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorBillPayload>
          }
          deleteMany: {
            args: Prisma.VendorBillDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorBillUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VendorBillUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorBillPayload>[]
          }
          upsert: {
            args: Prisma.VendorBillUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorBillPayload>
          }
          aggregate: {
            args: Prisma.VendorBillAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendorBill>
          }
          groupBy: {
            args: Prisma.VendorBillGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorBillGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorBillCountArgs<ExtArgs>
            result: $Utils.Optional<VendorBillCountAggregateOutputType> | number
          }
        }
      }
      VendorPayment: {
        payload: Prisma.$VendorPaymentPayload<ExtArgs>
        fields: Prisma.VendorPaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VendorPaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VendorPaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPaymentPayload>
          }
          findFirst: {
            args: Prisma.VendorPaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VendorPaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPaymentPayload>
          }
          findMany: {
            args: Prisma.VendorPaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPaymentPayload>[]
          }
          create: {
            args: Prisma.VendorPaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPaymentPayload>
          }
          createMany: {
            args: Prisma.VendorPaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VendorPaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPaymentPayload>[]
          }
          delete: {
            args: Prisma.VendorPaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPaymentPayload>
          }
          update: {
            args: Prisma.VendorPaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPaymentPayload>
          }
          deleteMany: {
            args: Prisma.VendorPaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VendorPaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VendorPaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPaymentPayload>[]
          }
          upsert: {
            args: Prisma.VendorPaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VendorPaymentPayload>
          }
          aggregate: {
            args: Prisma.VendorPaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVendorPayment>
          }
          groupBy: {
            args: Prisma.VendorPaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<VendorPaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.VendorPaymentCountArgs<ExtArgs>
            result: $Utils.Optional<VendorPaymentCountAggregateOutputType> | number
          }
        }
      }
      BankAccount: {
        payload: Prisma.$BankAccountPayload<ExtArgs>
        fields: Prisma.BankAccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BankAccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BankAccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          findFirst: {
            args: Prisma.BankAccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BankAccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          findMany: {
            args: Prisma.BankAccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>[]
          }
          create: {
            args: Prisma.BankAccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          createMany: {
            args: Prisma.BankAccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BankAccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>[]
          }
          delete: {
            args: Prisma.BankAccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          update: {
            args: Prisma.BankAccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          deleteMany: {
            args: Prisma.BankAccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BankAccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BankAccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>[]
          }
          upsert: {
            args: Prisma.BankAccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankAccountPayload>
          }
          aggregate: {
            args: Prisma.BankAccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBankAccount>
          }
          groupBy: {
            args: Prisma.BankAccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<BankAccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.BankAccountCountArgs<ExtArgs>
            result: $Utils.Optional<BankAccountCountAggregateOutputType> | number
          }
        }
      }
      BankTransaction: {
        payload: Prisma.$BankTransactionPayload<ExtArgs>
        fields: Prisma.BankTransactionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BankTransactionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BankTransactionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload>
          }
          findFirst: {
            args: Prisma.BankTransactionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BankTransactionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload>
          }
          findMany: {
            args: Prisma.BankTransactionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload>[]
          }
          create: {
            args: Prisma.BankTransactionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload>
          }
          createMany: {
            args: Prisma.BankTransactionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BankTransactionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload>[]
          }
          delete: {
            args: Prisma.BankTransactionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload>
          }
          update: {
            args: Prisma.BankTransactionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload>
          }
          deleteMany: {
            args: Prisma.BankTransactionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BankTransactionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.BankTransactionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload>[]
          }
          upsert: {
            args: Prisma.BankTransactionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BankTransactionPayload>
          }
          aggregate: {
            args: Prisma.BankTransactionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBankTransaction>
          }
          groupBy: {
            args: Prisma.BankTransactionGroupByArgs<ExtArgs>
            result: $Utils.Optional<BankTransactionGroupByOutputType>[]
          }
          count: {
            args: Prisma.BankTransactionCountArgs<ExtArgs>
            result: $Utils.Optional<BankTransactionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    project?: ProjectOmit
    projectFile?: ProjectFileOmit
    projectUpdate?: ProjectUpdateOmit
    supportRequest?: SupportRequestOmit
    supportMessage?: SupportMessageOmit
    meetingRequest?: MeetingRequestOmit
    invoice?: InvoiceOmit
    payment?: PaymentOmit
    employee?: EmployeeOmit
    attendance?: AttendanceOmit
    labourAllocation?: LabourAllocationOmit
    payroll?: PayrollOmit
    payrollLine?: PayrollLineOmit
    notification?: NotificationOmit
    systemSettings?: SystemSettingsOmit
    transaction?: TransactionOmit
    inventoryItem?: InventoryItemOmit
    inventoryTransaction?: InventoryTransactionOmit
    purchaseRequest?: PurchaseRequestOmit
    vendor?: VendorOmit
    purchaseOrder?: PurchaseOrderOmit
    gRN?: GRNOmit
    vendorBill?: VendorBillOmit
    vendorPayment?: VendorPaymentOmit
    bankAccount?: BankAccountOmit
    bankTransaction?: BankTransactionOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    projects: number
    project_files: number
    project_updates: number
    support_requests: number
    support_messages: number
    meeting_requests: number
    invoices: number
    notifications: number
    transactions: number
    inventory_logs: number
    purchase_requests: number
    purchase_orders: number
    grns: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | UserCountOutputTypeCountProjectsArgs
    project_files?: boolean | UserCountOutputTypeCountProject_filesArgs
    project_updates?: boolean | UserCountOutputTypeCountProject_updatesArgs
    support_requests?: boolean | UserCountOutputTypeCountSupport_requestsArgs
    support_messages?: boolean | UserCountOutputTypeCountSupport_messagesArgs
    meeting_requests?: boolean | UserCountOutputTypeCountMeeting_requestsArgs
    invoices?: boolean | UserCountOutputTypeCountInvoicesArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    transactions?: boolean | UserCountOutputTypeCountTransactionsArgs
    inventory_logs?: boolean | UserCountOutputTypeCountInventory_logsArgs
    purchase_requests?: boolean | UserCountOutputTypeCountPurchase_requestsArgs
    purchase_orders?: boolean | UserCountOutputTypeCountPurchase_ordersArgs
    grns?: boolean | UserCountOutputTypeCountGrnsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProject_filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectFileWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountProject_updatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectUpdateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSupport_requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSupport_messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportMessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountMeeting_requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInventory_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryTransactionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPurchase_requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountPurchase_ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountGrnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GRNWhereInput
  }


  /**
   * Count Type ProjectCountOutputType
   */

  export type ProjectCountOutputType = {
    files: number
    updates: number
    support_requests: number
    meeting_requests: number
    invoices: number
    inventory_logs: number
    purchase_requests: number
    attendance: number
    labour_allocations: number
  }

  export type ProjectCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    files?: boolean | ProjectCountOutputTypeCountFilesArgs
    updates?: boolean | ProjectCountOutputTypeCountUpdatesArgs
    support_requests?: boolean | ProjectCountOutputTypeCountSupport_requestsArgs
    meeting_requests?: boolean | ProjectCountOutputTypeCountMeeting_requestsArgs
    invoices?: boolean | ProjectCountOutputTypeCountInvoicesArgs
    inventory_logs?: boolean | ProjectCountOutputTypeCountInventory_logsArgs
    purchase_requests?: boolean | ProjectCountOutputTypeCountPurchase_requestsArgs
    attendance?: boolean | ProjectCountOutputTypeCountAttendanceArgs
    labour_allocations?: boolean | ProjectCountOutputTypeCountLabour_allocationsArgs
  }

  // Custom InputTypes
  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectCountOutputType
     */
    select?: ProjectCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectFileWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountUpdatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectUpdateWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountSupport_requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportRequestWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountMeeting_requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingRequestWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountInvoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountInventory_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryTransactionWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountPurchase_requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseRequestWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * ProjectCountOutputType without action
   */
  export type ProjectCountOutputTypeCountLabour_allocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabourAllocationWhereInput
  }


  /**
   * Count Type SupportRequestCountOutputType
   */

  export type SupportRequestCountOutputType = {
    messages: number
  }

  export type SupportRequestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    messages?: boolean | SupportRequestCountOutputTypeCountMessagesArgs
  }

  // Custom InputTypes
  /**
   * SupportRequestCountOutputType without action
   */
  export type SupportRequestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportRequestCountOutputType
     */
    select?: SupportRequestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SupportRequestCountOutputType without action
   */
  export type SupportRequestCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportMessageWhereInput
  }


  /**
   * Count Type InvoiceCountOutputType
   */

  export type InvoiceCountOutputType = {
    payments: number
  }

  export type InvoiceCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payments?: boolean | InvoiceCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InvoiceCountOutputType
     */
    select?: InvoiceCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InvoiceCountOutputType without action
   */
  export type InvoiceCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    attendance: number
    allocations: number
    payroll_items: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | EmployeeCountOutputTypeCountAttendanceArgs
    allocations?: boolean | EmployeeCountOutputTypeCountAllocationsArgs
    payroll_items?: boolean | EmployeeCountOutputTypeCountPayroll_itemsArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountAttendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountAllocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabourAllocationWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountPayroll_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollLineWhereInput
  }


  /**
   * Count Type PayrollCountOutputType
   */

  export type PayrollCountOutputType = {
    lines: number
  }

  export type PayrollCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | PayrollCountOutputTypeCountLinesArgs
  }

  // Custom InputTypes
  /**
   * PayrollCountOutputType without action
   */
  export type PayrollCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollCountOutputType
     */
    select?: PayrollCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PayrollCountOutputType without action
   */
  export type PayrollCountOutputTypeCountLinesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollLineWhereInput
  }


  /**
   * Count Type InventoryItemCountOutputType
   */

  export type InventoryItemCountOutputType = {
    transactions: number
  }

  export type InventoryItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | InventoryItemCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * InventoryItemCountOutputType without action
   */
  export type InventoryItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItemCountOutputType
     */
    select?: InventoryItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * InventoryItemCountOutputType without action
   */
  export type InventoryItemCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryTransactionWhereInput
  }


  /**
   * Count Type PurchaseRequestCountOutputType
   */

  export type PurchaseRequestCountOutputType = {
    purchase_orders: number
  }

  export type PurchaseRequestCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase_orders?: boolean | PurchaseRequestCountOutputTypeCountPurchase_ordersArgs
  }

  // Custom InputTypes
  /**
   * PurchaseRequestCountOutputType without action
   */
  export type PurchaseRequestCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequestCountOutputType
     */
    select?: PurchaseRequestCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseRequestCountOutputType without action
   */
  export type PurchaseRequestCountOutputTypeCountPurchase_ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }


  /**
   * Count Type VendorCountOutputType
   */

  export type VendorCountOutputType = {
    purchase_orders: number
    vendor_bills: number
  }

  export type VendorCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase_orders?: boolean | VendorCountOutputTypeCountPurchase_ordersArgs
    vendor_bills?: boolean | VendorCountOutputTypeCountVendor_billsArgs
  }

  // Custom InputTypes
  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorCountOutputType
     */
    select?: VendorCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountPurchase_ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
  }

  /**
   * VendorCountOutputType without action
   */
  export type VendorCountOutputTypeCountVendor_billsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorBillWhereInput
  }


  /**
   * Count Type PurchaseOrderCountOutputType
   */

  export type PurchaseOrderCountOutputType = {
    grns: number
    vendor_bills: number
  }

  export type PurchaseOrderCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    grns?: boolean | PurchaseOrderCountOutputTypeCountGrnsArgs
    vendor_bills?: boolean | PurchaseOrderCountOutputTypeCountVendor_billsArgs
  }

  // Custom InputTypes
  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrderCountOutputType
     */
    select?: PurchaseOrderCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeCountGrnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GRNWhereInput
  }

  /**
   * PurchaseOrderCountOutputType without action
   */
  export type PurchaseOrderCountOutputTypeCountVendor_billsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorBillWhereInput
  }


  /**
   * Count Type VendorBillCountOutputType
   */

  export type VendorBillCountOutputType = {
    vendor_payments: number
  }

  export type VendorBillCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor_payments?: boolean | VendorBillCountOutputTypeCountVendor_paymentsArgs
  }

  // Custom InputTypes
  /**
   * VendorBillCountOutputType without action
   */
  export type VendorBillCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBillCountOutputType
     */
    select?: VendorBillCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VendorBillCountOutputType without action
   */
  export type VendorBillCountOutputTypeCountVendor_paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorPaymentWhereInput
  }


  /**
   * Count Type BankAccountCountOutputType
   */

  export type BankAccountCountOutputType = {
    transactions: number
  }

  export type BankAccountCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | BankAccountCountOutputTypeCountTransactionsArgs
  }

  // Custom InputTypes
  /**
   * BankAccountCountOutputType without action
   */
  export type BankAccountCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccountCountOutputType
     */
    select?: BankAccountCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BankAccountCountOutputType without action
   */
  export type BankAccountCountOutputTypeCountTransactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankTransactionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    full_name: string | null
    role: $Enums.UserRole | null
    avatar_url: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    full_name: string | null
    role: $Enums.UserRole | null
    avatar_url: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    full_name: number
    role: number
    avatar_url: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    full_name?: true
    role?: true
    avatar_url?: true
    created_at?: true
    updated_at?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    full_name?: true
    role?: true
    avatar_url?: true
    created_at?: true
    updated_at?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    full_name?: true
    role?: true
    avatar_url?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string | null
    full_name: string
    role: $Enums.UserRole
    avatar_url: string | null
    created_at: Date
    updated_at: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    full_name?: boolean
    role?: boolean
    avatar_url?: boolean
    created_at?: boolean
    updated_at?: boolean
    projects?: boolean | User$projectsArgs<ExtArgs>
    project_files?: boolean | User$project_filesArgs<ExtArgs>
    project_updates?: boolean | User$project_updatesArgs<ExtArgs>
    support_requests?: boolean | User$support_requestsArgs<ExtArgs>
    support_messages?: boolean | User$support_messagesArgs<ExtArgs>
    meeting_requests?: boolean | User$meeting_requestsArgs<ExtArgs>
    invoices?: boolean | User$invoicesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    inventory_logs?: boolean | User$inventory_logsArgs<ExtArgs>
    purchase_requests?: boolean | User$purchase_requestsArgs<ExtArgs>
    purchase_orders?: boolean | User$purchase_ordersArgs<ExtArgs>
    grns?: boolean | User$grnsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    full_name?: boolean
    role?: boolean
    avatar_url?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    full_name?: boolean
    role?: boolean
    avatar_url?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    full_name?: boolean
    role?: boolean
    avatar_url?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "password" | "full_name" | "role" | "avatar_url" | "created_at" | "updated_at", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    projects?: boolean | User$projectsArgs<ExtArgs>
    project_files?: boolean | User$project_filesArgs<ExtArgs>
    project_updates?: boolean | User$project_updatesArgs<ExtArgs>
    support_requests?: boolean | User$support_requestsArgs<ExtArgs>
    support_messages?: boolean | User$support_messagesArgs<ExtArgs>
    meeting_requests?: boolean | User$meeting_requestsArgs<ExtArgs>
    invoices?: boolean | User$invoicesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    transactions?: boolean | User$transactionsArgs<ExtArgs>
    inventory_logs?: boolean | User$inventory_logsArgs<ExtArgs>
    purchase_requests?: boolean | User$purchase_requestsArgs<ExtArgs>
    purchase_orders?: boolean | User$purchase_ordersArgs<ExtArgs>
    grns?: boolean | User$grnsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      projects: Prisma.$ProjectPayload<ExtArgs>[]
      project_files: Prisma.$ProjectFilePayload<ExtArgs>[]
      project_updates: Prisma.$ProjectUpdatePayload<ExtArgs>[]
      support_requests: Prisma.$SupportRequestPayload<ExtArgs>[]
      support_messages: Prisma.$SupportMessagePayload<ExtArgs>[]
      meeting_requests: Prisma.$MeetingRequestPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      transactions: Prisma.$TransactionPayload<ExtArgs>[]
      inventory_logs: Prisma.$InventoryTransactionPayload<ExtArgs>[]
      purchase_requests: Prisma.$PurchaseRequestPayload<ExtArgs>[]
      purchase_orders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
      grns: Prisma.$GRNPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string | null
      full_name: string
      role: $Enums.UserRole
      avatar_url: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    projects<T extends User$projectsArgs<ExtArgs> = {}>(args?: Subset<T, User$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    project_files<T extends User$project_filesArgs<ExtArgs> = {}>(args?: Subset<T, User$project_filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectFilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    project_updates<T extends User$project_updatesArgs<ExtArgs> = {}>(args?: Subset<T, User$project_updatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    support_requests<T extends User$support_requestsArgs<ExtArgs> = {}>(args?: Subset<T, User$support_requestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    support_messages<T extends User$support_messagesArgs<ExtArgs> = {}>(args?: Subset<T, User$support_messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    meeting_requests<T extends User$meeting_requestsArgs<ExtArgs> = {}>(args?: Subset<T, User$meeting_requestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends User$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, User$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    transactions<T extends User$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, User$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventory_logs<T extends User$inventory_logsArgs<ExtArgs> = {}>(args?: Subset<T, User$inventory_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchase_requests<T extends User$purchase_requestsArgs<ExtArgs> = {}>(args?: Subset<T, User$purchase_requestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchase_orders<T extends User$purchase_ordersArgs<ExtArgs> = {}>(args?: Subset<T, User$purchase_ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    grns<T extends User$grnsArgs<ExtArgs> = {}>(args?: Subset<T, User$grnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GRNPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly full_name: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'UserRole'>
    readonly avatar_url: FieldRef<"User", 'String'>
    readonly created_at: FieldRef<"User", 'DateTime'>
    readonly updated_at: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.projects
   */
  export type User$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    cursor?: ProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * User.project_files
   */
  export type User$project_filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFile
     */
    select?: ProjectFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFile
     */
    omit?: ProjectFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFileInclude<ExtArgs> | null
    where?: ProjectFileWhereInput
    orderBy?: ProjectFileOrderByWithRelationInput | ProjectFileOrderByWithRelationInput[]
    cursor?: ProjectFileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectFileScalarFieldEnum | ProjectFileScalarFieldEnum[]
  }

  /**
   * User.project_updates
   */
  export type User$project_updatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
    where?: ProjectUpdateWhereInput
    orderBy?: ProjectUpdateOrderByWithRelationInput | ProjectUpdateOrderByWithRelationInput[]
    cursor?: ProjectUpdateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectUpdateScalarFieldEnum | ProjectUpdateScalarFieldEnum[]
  }

  /**
   * User.support_requests
   */
  export type User$support_requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportRequest
     */
    select?: SupportRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportRequest
     */
    omit?: SupportRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportRequestInclude<ExtArgs> | null
    where?: SupportRequestWhereInput
    orderBy?: SupportRequestOrderByWithRelationInput | SupportRequestOrderByWithRelationInput[]
    cursor?: SupportRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportRequestScalarFieldEnum | SupportRequestScalarFieldEnum[]
  }

  /**
   * User.support_messages
   */
  export type User$support_messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportMessage
     */
    omit?: SupportMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
    where?: SupportMessageWhereInput
    orderBy?: SupportMessageOrderByWithRelationInput | SupportMessageOrderByWithRelationInput[]
    cursor?: SupportMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportMessageScalarFieldEnum | SupportMessageScalarFieldEnum[]
  }

  /**
   * User.meeting_requests
   */
  export type User$meeting_requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRequest
     */
    select?: MeetingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRequest
     */
    omit?: MeetingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRequestInclude<ExtArgs> | null
    where?: MeetingRequestWhereInput
    orderBy?: MeetingRequestOrderByWithRelationInput | MeetingRequestOrderByWithRelationInput[]
    cursor?: MeetingRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeetingRequestScalarFieldEnum | MeetingRequestScalarFieldEnum[]
  }

  /**
   * User.invoices
   */
  export type User$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.transactions
   */
  export type User$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    cursor?: TransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * User.inventory_logs
   */
  export type User$inventory_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    where?: InventoryTransactionWhereInput
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    cursor?: InventoryTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryTransactionScalarFieldEnum | InventoryTransactionScalarFieldEnum[]
  }

  /**
   * User.purchase_requests
   */
  export type User$purchase_requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseRequest
     */
    omit?: PurchaseRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
    where?: PurchaseRequestWhereInput
    orderBy?: PurchaseRequestOrderByWithRelationInput | PurchaseRequestOrderByWithRelationInput[]
    cursor?: PurchaseRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseRequestScalarFieldEnum | PurchaseRequestScalarFieldEnum[]
  }

  /**
   * User.purchase_orders
   */
  export type User$purchase_ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * User.grns
   */
  export type User$grnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRN
     */
    select?: GRNSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRN
     */
    omit?: GRNOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNInclude<ExtArgs> | null
    where?: GRNWhereInput
    orderBy?: GRNOrderByWithRelationInput | GRNOrderByWithRelationInput[]
    cursor?: GRNWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GRNScalarFieldEnum | GRNScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Project
   */

  export type AggregateProject = {
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  export type ProjectAvgAggregateOutputType = {
    estimated_cost: Decimal | null
    actual_cost: Decimal | null
  }

  export type ProjectSumAggregateOutputType = {
    estimated_cost: Decimal | null
    actual_cost: Decimal | null
  }

  export type ProjectMinAggregateOutputType = {
    id: string | null
    client_id: string | null
    title: string | null
    description: string | null
    status: $Enums.ProjectStatus | null
    github_link: string | null
    estimated_cost: Decimal | null
    actual_cost: Decimal | null
    deadline: Date | null
    test_asset_url: string | null
    deployment_url: string | null
    live_preview_type: string | null
    live_preview_url: string | null
    is_featured: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProjectMaxAggregateOutputType = {
    id: string | null
    client_id: string | null
    title: string | null
    description: string | null
    status: $Enums.ProjectStatus | null
    github_link: string | null
    estimated_cost: Decimal | null
    actual_cost: Decimal | null
    deadline: Date | null
    test_asset_url: string | null
    deployment_url: string | null
    live_preview_type: string | null
    live_preview_url: string | null
    is_featured: boolean | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type ProjectCountAggregateOutputType = {
    id: number
    client_id: number
    title: number
    description: number
    status: number
    github_link: number
    estimated_cost: number
    actual_cost: number
    deadline: number
    test_asset_url: number
    deployment_url: number
    live_preview_type: number
    live_preview_url: number
    technical_config: number
    tickets: number
    notes: number
    labour_data: number
    inventory_data: number
    resources_data: number
    design_data: number
    expenses_data: number
    timeline_data: number
    is_featured: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type ProjectAvgAggregateInputType = {
    estimated_cost?: true
    actual_cost?: true
  }

  export type ProjectSumAggregateInputType = {
    estimated_cost?: true
    actual_cost?: true
  }

  export type ProjectMinAggregateInputType = {
    id?: true
    client_id?: true
    title?: true
    description?: true
    status?: true
    github_link?: true
    estimated_cost?: true
    actual_cost?: true
    deadline?: true
    test_asset_url?: true
    deployment_url?: true
    live_preview_type?: true
    live_preview_url?: true
    is_featured?: true
    created_at?: true
    updated_at?: true
  }

  export type ProjectMaxAggregateInputType = {
    id?: true
    client_id?: true
    title?: true
    description?: true
    status?: true
    github_link?: true
    estimated_cost?: true
    actual_cost?: true
    deadline?: true
    test_asset_url?: true
    deployment_url?: true
    live_preview_type?: true
    live_preview_url?: true
    is_featured?: true
    created_at?: true
    updated_at?: true
  }

  export type ProjectCountAggregateInputType = {
    id?: true
    client_id?: true
    title?: true
    description?: true
    status?: true
    github_link?: true
    estimated_cost?: true
    actual_cost?: true
    deadline?: true
    test_asset_url?: true
    deployment_url?: true
    live_preview_type?: true
    live_preview_url?: true
    technical_config?: true
    tickets?: true
    notes?: true
    labour_data?: true
    inventory_data?: true
    resources_data?: true
    design_data?: true
    expenses_data?: true
    timeline_data?: true
    is_featured?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type ProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Project to aggregate.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Projects
    **/
    _count?: true | ProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectMaxAggregateInputType
  }

  export type GetProjectAggregateType<T extends ProjectAggregateArgs> = {
        [P in keyof T & keyof AggregateProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProject[P]>
      : GetScalarType<T[P], AggregateProject[P]>
  }




  export type ProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectWhereInput
    orderBy?: ProjectOrderByWithAggregationInput | ProjectOrderByWithAggregationInput[]
    by: ProjectScalarFieldEnum[] | ProjectScalarFieldEnum
    having?: ProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectCountAggregateInputType | true
    _avg?: ProjectAvgAggregateInputType
    _sum?: ProjectSumAggregateInputType
    _min?: ProjectMinAggregateInputType
    _max?: ProjectMaxAggregateInputType
  }

  export type ProjectGroupByOutputType = {
    id: string
    client_id: string
    title: string
    description: string
    status: $Enums.ProjectStatus
    github_link: string | null
    estimated_cost: Decimal | null
    actual_cost: Decimal | null
    deadline: Date | null
    test_asset_url: string | null
    deployment_url: string | null
    live_preview_type: string | null
    live_preview_url: string | null
    technical_config: JsonValue | null
    tickets: JsonValue | null
    notes: string[]
    labour_data: JsonValue | null
    inventory_data: JsonValue | null
    resources_data: JsonValue | null
    design_data: JsonValue | null
    expenses_data: JsonValue | null
    timeline_data: JsonValue | null
    is_featured: boolean
    created_at: Date
    updated_at: Date
    _count: ProjectCountAggregateOutputType | null
    _avg: ProjectAvgAggregateOutputType | null
    _sum: ProjectSumAggregateOutputType | null
    _min: ProjectMinAggregateOutputType | null
    _max: ProjectMaxAggregateOutputType | null
  }

  type GetProjectGroupByPayload<T extends ProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectGroupByOutputType[P]>
        }
      >
    >


  export type ProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    client_id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    github_link?: boolean
    estimated_cost?: boolean
    actual_cost?: boolean
    deadline?: boolean
    test_asset_url?: boolean
    deployment_url?: boolean
    live_preview_type?: boolean
    live_preview_url?: boolean
    technical_config?: boolean
    tickets?: boolean
    notes?: boolean
    labour_data?: boolean
    inventory_data?: boolean
    resources_data?: boolean
    design_data?: boolean
    expenses_data?: boolean
    timeline_data?: boolean
    is_featured?: boolean
    created_at?: boolean
    updated_at?: boolean
    client?: boolean | UserDefaultArgs<ExtArgs>
    files?: boolean | Project$filesArgs<ExtArgs>
    updates?: boolean | Project$updatesArgs<ExtArgs>
    support_requests?: boolean | Project$support_requestsArgs<ExtArgs>
    meeting_requests?: boolean | Project$meeting_requestsArgs<ExtArgs>
    invoices?: boolean | Project$invoicesArgs<ExtArgs>
    inventory_logs?: boolean | Project$inventory_logsArgs<ExtArgs>
    purchase_requests?: boolean | Project$purchase_requestsArgs<ExtArgs>
    attendance?: boolean | Project$attendanceArgs<ExtArgs>
    labour_allocations?: boolean | Project$labour_allocationsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    client_id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    github_link?: boolean
    estimated_cost?: boolean
    actual_cost?: boolean
    deadline?: boolean
    test_asset_url?: boolean
    deployment_url?: boolean
    live_preview_type?: boolean
    live_preview_url?: boolean
    technical_config?: boolean
    tickets?: boolean
    notes?: boolean
    labour_data?: boolean
    inventory_data?: boolean
    resources_data?: boolean
    design_data?: boolean
    expenses_data?: boolean
    timeline_data?: boolean
    is_featured?: boolean
    created_at?: boolean
    updated_at?: boolean
    client?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    client_id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    github_link?: boolean
    estimated_cost?: boolean
    actual_cost?: boolean
    deadline?: boolean
    test_asset_url?: boolean
    deployment_url?: boolean
    live_preview_type?: boolean
    live_preview_url?: boolean
    technical_config?: boolean
    tickets?: boolean
    notes?: boolean
    labour_data?: boolean
    inventory_data?: boolean
    resources_data?: boolean
    design_data?: boolean
    expenses_data?: boolean
    timeline_data?: boolean
    is_featured?: boolean
    created_at?: boolean
    updated_at?: boolean
    client?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["project"]>

  export type ProjectSelectScalar = {
    id?: boolean
    client_id?: boolean
    title?: boolean
    description?: boolean
    status?: boolean
    github_link?: boolean
    estimated_cost?: boolean
    actual_cost?: boolean
    deadline?: boolean
    test_asset_url?: boolean
    deployment_url?: boolean
    live_preview_type?: boolean
    live_preview_url?: boolean
    technical_config?: boolean
    tickets?: boolean
    notes?: boolean
    labour_data?: boolean
    inventory_data?: boolean
    resources_data?: boolean
    design_data?: boolean
    expenses_data?: boolean
    timeline_data?: boolean
    is_featured?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type ProjectOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "client_id" | "title" | "description" | "status" | "github_link" | "estimated_cost" | "actual_cost" | "deadline" | "test_asset_url" | "deployment_url" | "live_preview_type" | "live_preview_url" | "technical_config" | "tickets" | "notes" | "labour_data" | "inventory_data" | "resources_data" | "design_data" | "expenses_data" | "timeline_data" | "is_featured" | "created_at" | "updated_at", ExtArgs["result"]["project"]>
  export type ProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | UserDefaultArgs<ExtArgs>
    files?: boolean | Project$filesArgs<ExtArgs>
    updates?: boolean | Project$updatesArgs<ExtArgs>
    support_requests?: boolean | Project$support_requestsArgs<ExtArgs>
    meeting_requests?: boolean | Project$meeting_requestsArgs<ExtArgs>
    invoices?: boolean | Project$invoicesArgs<ExtArgs>
    inventory_logs?: boolean | Project$inventory_logsArgs<ExtArgs>
    purchase_requests?: boolean | Project$purchase_requestsArgs<ExtArgs>
    attendance?: boolean | Project$attendanceArgs<ExtArgs>
    labour_allocations?: boolean | Project$labour_allocationsArgs<ExtArgs>
    _count?: boolean | ProjectCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    client?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Project"
    objects: {
      client: Prisma.$UserPayload<ExtArgs>
      files: Prisma.$ProjectFilePayload<ExtArgs>[]
      updates: Prisma.$ProjectUpdatePayload<ExtArgs>[]
      support_requests: Prisma.$SupportRequestPayload<ExtArgs>[]
      meeting_requests: Prisma.$MeetingRequestPayload<ExtArgs>[]
      invoices: Prisma.$InvoicePayload<ExtArgs>[]
      inventory_logs: Prisma.$InventoryTransactionPayload<ExtArgs>[]
      purchase_requests: Prisma.$PurchaseRequestPayload<ExtArgs>[]
      attendance: Prisma.$AttendancePayload<ExtArgs>[]
      labour_allocations: Prisma.$LabourAllocationPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      client_id: string
      title: string
      description: string
      status: $Enums.ProjectStatus
      github_link: string | null
      estimated_cost: Prisma.Decimal | null
      actual_cost: Prisma.Decimal | null
      deadline: Date | null
      test_asset_url: string | null
      deployment_url: string | null
      live_preview_type: string | null
      live_preview_url: string | null
      technical_config: Prisma.JsonValue | null
      tickets: Prisma.JsonValue | null
      notes: string[]
      labour_data: Prisma.JsonValue | null
      inventory_data: Prisma.JsonValue | null
      resources_data: Prisma.JsonValue | null
      design_data: Prisma.JsonValue | null
      expenses_data: Prisma.JsonValue | null
      timeline_data: Prisma.JsonValue | null
      is_featured: boolean
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["project"]>
    composites: {}
  }

  type ProjectGetPayload<S extends boolean | null | undefined | ProjectDefaultArgs> = $Result.GetResult<Prisma.$ProjectPayload, S>

  type ProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectCountAggregateInputType | true
    }

  export interface ProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Project'], meta: { name: 'Project' } }
    /**
     * Find zero or one Project that matches the filter.
     * @param {ProjectFindUniqueArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFindUniqueArgs>(args: SelectSubset<T, ProjectFindUniqueArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Project that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFindUniqueOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFindFirstArgs>(args?: SelectSubset<T, ProjectFindFirstArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Project that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindFirstOrThrowArgs} args - Arguments to find a Project
     * @example
     * // Get one Project
     * const project = await prisma.project.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Projects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Projects
     * const projects = await prisma.project.findMany()
     * 
     * // Get first 10 Projects
     * const projects = await prisma.project.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectWithIdOnly = await prisma.project.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFindManyArgs>(args?: SelectSubset<T, ProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Project.
     * @param {ProjectCreateArgs} args - Arguments to create a Project.
     * @example
     * // Create one Project
     * const Project = await prisma.project.create({
     *   data: {
     *     // ... data to create a Project
     *   }
     * })
     * 
     */
    create<T extends ProjectCreateArgs>(args: SelectSubset<T, ProjectCreateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Projects.
     * @param {ProjectCreateManyArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectCreateManyArgs>(args?: SelectSubset<T, ProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Projects and returns the data saved in the database.
     * @param {ProjectCreateManyAndReturnArgs} args - Arguments to create many Projects.
     * @example
     * // Create many Projects
     * const project = await prisma.project.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Project.
     * @param {ProjectDeleteArgs} args - Arguments to delete one Project.
     * @example
     * // Delete one Project
     * const Project = await prisma.project.delete({
     *   where: {
     *     // ... filter to delete one Project
     *   }
     * })
     * 
     */
    delete<T extends ProjectDeleteArgs>(args: SelectSubset<T, ProjectDeleteArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Project.
     * @param {ProjectUpdateArgs} args - Arguments to update one Project.
     * @example
     * // Update one Project
     * const project = await prisma.project.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateArgs>(args: SelectSubset<T, ProjectUpdateArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Projects.
     * @param {ProjectDeleteManyArgs} args - Arguments to filter Projects to delete.
     * @example
     * // Delete a few Projects
     * const { count } = await prisma.project.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectDeleteManyArgs>(args?: SelectSubset<T, ProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Projects and returns the data updated in the database.
     * @param {ProjectUpdateManyAndReturnArgs} args - Arguments to update many Projects.
     * @example
     * // Update many Projects
     * const project = await prisma.project.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Projects and only return the `id`
     * const projectWithIdOnly = await prisma.project.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Project.
     * @param {ProjectUpsertArgs} args - Arguments to update or create a Project.
     * @example
     * // Update or create a Project
     * const project = await prisma.project.upsert({
     *   create: {
     *     // ... data to create a Project
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Project we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpsertArgs>(args: SelectSubset<T, ProjectUpsertArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Projects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectCountArgs} args - Arguments to filter Projects to count.
     * @example
     * // Count the number of Projects
     * const count = await prisma.project.count({
     *   where: {
     *     // ... the filter for the Projects we want to count
     *   }
     * })
    **/
    count<T extends ProjectCountArgs>(
      args?: Subset<T, ProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectAggregateArgs>(args: Subset<T, ProjectAggregateArgs>): Prisma.PrismaPromise<GetProjectAggregateType<T>>

    /**
     * Group by Project.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectGroupByArgs['orderBy'] }
        : { orderBy?: ProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Project model
   */
  readonly fields: ProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Project.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    client<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    files<T extends Project$filesArgs<ExtArgs> = {}>(args?: Subset<T, Project$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectFilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    updates<T extends Project$updatesArgs<ExtArgs> = {}>(args?: Subset<T, Project$updatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    support_requests<T extends Project$support_requestsArgs<ExtArgs> = {}>(args?: Subset<T, Project$support_requestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    meeting_requests<T extends Project$meeting_requestsArgs<ExtArgs> = {}>(args?: Subset<T, Project$meeting_requestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    invoices<T extends Project$invoicesArgs<ExtArgs> = {}>(args?: Subset<T, Project$invoicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inventory_logs<T extends Project$inventory_logsArgs<ExtArgs> = {}>(args?: Subset<T, Project$inventory_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    purchase_requests<T extends Project$purchase_requestsArgs<ExtArgs> = {}>(args?: Subset<T, Project$purchase_requestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendance<T extends Project$attendanceArgs<ExtArgs> = {}>(args?: Subset<T, Project$attendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    labour_allocations<T extends Project$labour_allocationsArgs<ExtArgs> = {}>(args?: Subset<T, Project$labour_allocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabourAllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Project model
   */
  interface ProjectFieldRefs {
    readonly id: FieldRef<"Project", 'String'>
    readonly client_id: FieldRef<"Project", 'String'>
    readonly title: FieldRef<"Project", 'String'>
    readonly description: FieldRef<"Project", 'String'>
    readonly status: FieldRef<"Project", 'ProjectStatus'>
    readonly github_link: FieldRef<"Project", 'String'>
    readonly estimated_cost: FieldRef<"Project", 'Decimal'>
    readonly actual_cost: FieldRef<"Project", 'Decimal'>
    readonly deadline: FieldRef<"Project", 'DateTime'>
    readonly test_asset_url: FieldRef<"Project", 'String'>
    readonly deployment_url: FieldRef<"Project", 'String'>
    readonly live_preview_type: FieldRef<"Project", 'String'>
    readonly live_preview_url: FieldRef<"Project", 'String'>
    readonly technical_config: FieldRef<"Project", 'Json'>
    readonly tickets: FieldRef<"Project", 'Json'>
    readonly notes: FieldRef<"Project", 'String[]'>
    readonly labour_data: FieldRef<"Project", 'Json'>
    readonly inventory_data: FieldRef<"Project", 'Json'>
    readonly resources_data: FieldRef<"Project", 'Json'>
    readonly design_data: FieldRef<"Project", 'Json'>
    readonly expenses_data: FieldRef<"Project", 'Json'>
    readonly timeline_data: FieldRef<"Project", 'Json'>
    readonly is_featured: FieldRef<"Project", 'Boolean'>
    readonly created_at: FieldRef<"Project", 'DateTime'>
    readonly updated_at: FieldRef<"Project", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Project findUnique
   */
  export type ProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findUniqueOrThrow
   */
  export type ProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project findFirst
   */
  export type ProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findFirstOrThrow
   */
  export type ProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Project to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Projects.
     */
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project findMany
   */
  export type ProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter, which Projects to fetch.
     */
    where?: ProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Projects to fetch.
     */
    orderBy?: ProjectOrderByWithRelationInput | ProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Projects.
     */
    cursor?: ProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Projects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Projects.
     */
    skip?: number
    distinct?: ProjectScalarFieldEnum | ProjectScalarFieldEnum[]
  }

  /**
   * Project create
   */
  export type ProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a Project.
     */
    data: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
  }

  /**
   * Project createMany
   */
  export type ProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Project createManyAndReturn
   */
  export type ProjectCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to create many Projects.
     */
    data: ProjectCreateManyInput | ProjectCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project update
   */
  export type ProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a Project.
     */
    data: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
    /**
     * Choose, which Project to update.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project updateMany
   */
  export type ProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
  }

  /**
   * Project updateManyAndReturn
   */
  export type ProjectUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * The data used to update Projects.
     */
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyInput>
    /**
     * Filter which Projects to update
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Project upsert
   */
  export type ProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the Project to update in case it exists.
     */
    where: ProjectWhereUniqueInput
    /**
     * In case the Project found by the `where` argument doesn't exist, create a new Project with this data.
     */
    create: XOR<ProjectCreateInput, ProjectUncheckedCreateInput>
    /**
     * In case the Project was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateInput, ProjectUncheckedUpdateInput>
  }

  /**
   * Project delete
   */
  export type ProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    /**
     * Filter which Project to delete.
     */
    where: ProjectWhereUniqueInput
  }

  /**
   * Project deleteMany
   */
  export type ProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Projects to delete
     */
    where?: ProjectWhereInput
    /**
     * Limit how many Projects to delete.
     */
    limit?: number
  }

  /**
   * Project.files
   */
  export type Project$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFile
     */
    select?: ProjectFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFile
     */
    omit?: ProjectFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFileInclude<ExtArgs> | null
    where?: ProjectFileWhereInput
    orderBy?: ProjectFileOrderByWithRelationInput | ProjectFileOrderByWithRelationInput[]
    cursor?: ProjectFileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectFileScalarFieldEnum | ProjectFileScalarFieldEnum[]
  }

  /**
   * Project.updates
   */
  export type Project$updatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
    where?: ProjectUpdateWhereInput
    orderBy?: ProjectUpdateOrderByWithRelationInput | ProjectUpdateOrderByWithRelationInput[]
    cursor?: ProjectUpdateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProjectUpdateScalarFieldEnum | ProjectUpdateScalarFieldEnum[]
  }

  /**
   * Project.support_requests
   */
  export type Project$support_requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportRequest
     */
    select?: SupportRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportRequest
     */
    omit?: SupportRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportRequestInclude<ExtArgs> | null
    where?: SupportRequestWhereInput
    orderBy?: SupportRequestOrderByWithRelationInput | SupportRequestOrderByWithRelationInput[]
    cursor?: SupportRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportRequestScalarFieldEnum | SupportRequestScalarFieldEnum[]
  }

  /**
   * Project.meeting_requests
   */
  export type Project$meeting_requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRequest
     */
    select?: MeetingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRequest
     */
    omit?: MeetingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRequestInclude<ExtArgs> | null
    where?: MeetingRequestWhereInput
    orderBy?: MeetingRequestOrderByWithRelationInput | MeetingRequestOrderByWithRelationInput[]
    cursor?: MeetingRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MeetingRequestScalarFieldEnum | MeetingRequestScalarFieldEnum[]
  }

  /**
   * Project.invoices
   */
  export type Project$invoicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    cursor?: InvoiceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Project.inventory_logs
   */
  export type Project$inventory_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    where?: InventoryTransactionWhereInput
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    cursor?: InventoryTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryTransactionScalarFieldEnum | InventoryTransactionScalarFieldEnum[]
  }

  /**
   * Project.purchase_requests
   */
  export type Project$purchase_requestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseRequest
     */
    omit?: PurchaseRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
    where?: PurchaseRequestWhereInput
    orderBy?: PurchaseRequestOrderByWithRelationInput | PurchaseRequestOrderByWithRelationInput[]
    cursor?: PurchaseRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseRequestScalarFieldEnum | PurchaseRequestScalarFieldEnum[]
  }

  /**
   * Project.attendance
   */
  export type Project$attendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Project.labour_allocations
   */
  export type Project$labour_allocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourAllocation
     */
    select?: LabourAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourAllocation
     */
    omit?: LabourAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourAllocationInclude<ExtArgs> | null
    where?: LabourAllocationWhereInput
    orderBy?: LabourAllocationOrderByWithRelationInput | LabourAllocationOrderByWithRelationInput[]
    cursor?: LabourAllocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabourAllocationScalarFieldEnum | LabourAllocationScalarFieldEnum[]
  }

  /**
   * Project without action
   */
  export type ProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
  }


  /**
   * Model ProjectFile
   */

  export type AggregateProjectFile = {
    _count: ProjectFileCountAggregateOutputType | null
    _avg: ProjectFileAvgAggregateOutputType | null
    _sum: ProjectFileSumAggregateOutputType | null
    _min: ProjectFileMinAggregateOutputType | null
    _max: ProjectFileMaxAggregateOutputType | null
  }

  export type ProjectFileAvgAggregateOutputType = {
    file_size: number | null
  }

  export type ProjectFileSumAggregateOutputType = {
    file_size: bigint | null
  }

  export type ProjectFileMinAggregateOutputType = {
    id: string | null
    project_id: string | null
    file_name: string | null
    file_url: string | null
    file_type: $Enums.FileType | null
    file_size: bigint | null
    uploaded_by: string | null
    created_at: Date | null
  }

  export type ProjectFileMaxAggregateOutputType = {
    id: string | null
    project_id: string | null
    file_name: string | null
    file_url: string | null
    file_type: $Enums.FileType | null
    file_size: bigint | null
    uploaded_by: string | null
    created_at: Date | null
  }

  export type ProjectFileCountAggregateOutputType = {
    id: number
    project_id: number
    file_name: number
    file_url: number
    file_type: number
    file_size: number
    uploaded_by: number
    created_at: number
    _all: number
  }


  export type ProjectFileAvgAggregateInputType = {
    file_size?: true
  }

  export type ProjectFileSumAggregateInputType = {
    file_size?: true
  }

  export type ProjectFileMinAggregateInputType = {
    id?: true
    project_id?: true
    file_name?: true
    file_url?: true
    file_type?: true
    file_size?: true
    uploaded_by?: true
    created_at?: true
  }

  export type ProjectFileMaxAggregateInputType = {
    id?: true
    project_id?: true
    file_name?: true
    file_url?: true
    file_type?: true
    file_size?: true
    uploaded_by?: true
    created_at?: true
  }

  export type ProjectFileCountAggregateInputType = {
    id?: true
    project_id?: true
    file_name?: true
    file_url?: true
    file_type?: true
    file_size?: true
    uploaded_by?: true
    created_at?: true
    _all?: true
  }

  export type ProjectFileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectFile to aggregate.
     */
    where?: ProjectFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectFiles to fetch.
     */
    orderBy?: ProjectFileOrderByWithRelationInput | ProjectFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectFiles
    **/
    _count?: true | ProjectFileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProjectFileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProjectFileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectFileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectFileMaxAggregateInputType
  }

  export type GetProjectFileAggregateType<T extends ProjectFileAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectFile[P]>
      : GetScalarType<T[P], AggregateProjectFile[P]>
  }




  export type ProjectFileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectFileWhereInput
    orderBy?: ProjectFileOrderByWithAggregationInput | ProjectFileOrderByWithAggregationInput[]
    by: ProjectFileScalarFieldEnum[] | ProjectFileScalarFieldEnum
    having?: ProjectFileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectFileCountAggregateInputType | true
    _avg?: ProjectFileAvgAggregateInputType
    _sum?: ProjectFileSumAggregateInputType
    _min?: ProjectFileMinAggregateInputType
    _max?: ProjectFileMaxAggregateInputType
  }

  export type ProjectFileGroupByOutputType = {
    id: string
    project_id: string
    file_name: string
    file_url: string
    file_type: $Enums.FileType
    file_size: bigint
    uploaded_by: string
    created_at: Date
    _count: ProjectFileCountAggregateOutputType | null
    _avg: ProjectFileAvgAggregateOutputType | null
    _sum: ProjectFileSumAggregateOutputType | null
    _min: ProjectFileMinAggregateOutputType | null
    _max: ProjectFileMaxAggregateOutputType | null
  }

  type GetProjectFileGroupByPayload<T extends ProjectFileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectFileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectFileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectFileGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectFileGroupByOutputType[P]>
        }
      >
    >


  export type ProjectFileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    project_id?: boolean
    file_name?: boolean
    file_url?: boolean
    file_type?: boolean
    file_size?: boolean
    uploaded_by?: boolean
    created_at?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectFile"]>

  export type ProjectFileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    project_id?: boolean
    file_name?: boolean
    file_url?: boolean
    file_type?: boolean
    file_size?: boolean
    uploaded_by?: boolean
    created_at?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectFile"]>

  export type ProjectFileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    project_id?: boolean
    file_name?: boolean
    file_url?: boolean
    file_type?: boolean
    file_size?: boolean
    uploaded_by?: boolean
    created_at?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectFile"]>

  export type ProjectFileSelectScalar = {
    id?: boolean
    project_id?: boolean
    file_name?: boolean
    file_url?: boolean
    file_type?: boolean
    file_size?: boolean
    uploaded_by?: boolean
    created_at?: boolean
  }

  export type ProjectFileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "project_id" | "file_name" | "file_url" | "file_type" | "file_size" | "uploaded_by" | "created_at", ExtArgs["result"]["projectFile"]>
  export type ProjectFileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectFileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectFileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    uploader?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectFilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectFile"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      uploader: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      project_id: string
      file_name: string
      file_url: string
      file_type: $Enums.FileType
      file_size: bigint
      uploaded_by: string
      created_at: Date
    }, ExtArgs["result"]["projectFile"]>
    composites: {}
  }

  type ProjectFileGetPayload<S extends boolean | null | undefined | ProjectFileDefaultArgs> = $Result.GetResult<Prisma.$ProjectFilePayload, S>

  type ProjectFileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectFileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectFileCountAggregateInputType | true
    }

  export interface ProjectFileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectFile'], meta: { name: 'ProjectFile' } }
    /**
     * Find zero or one ProjectFile that matches the filter.
     * @param {ProjectFileFindUniqueArgs} args - Arguments to find a ProjectFile
     * @example
     * // Get one ProjectFile
     * const projectFile = await prisma.projectFile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectFileFindUniqueArgs>(args: SelectSubset<T, ProjectFileFindUniqueArgs<ExtArgs>>): Prisma__ProjectFileClient<$Result.GetResult<Prisma.$ProjectFilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectFile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectFileFindUniqueOrThrowArgs} args - Arguments to find a ProjectFile
     * @example
     * // Get one ProjectFile
     * const projectFile = await prisma.projectFile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectFileFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectFileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectFileClient<$Result.GetResult<Prisma.$ProjectFilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectFile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFileFindFirstArgs} args - Arguments to find a ProjectFile
     * @example
     * // Get one ProjectFile
     * const projectFile = await prisma.projectFile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectFileFindFirstArgs>(args?: SelectSubset<T, ProjectFileFindFirstArgs<ExtArgs>>): Prisma__ProjectFileClient<$Result.GetResult<Prisma.$ProjectFilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectFile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFileFindFirstOrThrowArgs} args - Arguments to find a ProjectFile
     * @example
     * // Get one ProjectFile
     * const projectFile = await prisma.projectFile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectFileFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectFileFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectFileClient<$Result.GetResult<Prisma.$ProjectFilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectFiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectFiles
     * const projectFiles = await prisma.projectFile.findMany()
     * 
     * // Get first 10 ProjectFiles
     * const projectFiles = await prisma.projectFile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectFileWithIdOnly = await prisma.projectFile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectFileFindManyArgs>(args?: SelectSubset<T, ProjectFileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectFilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectFile.
     * @param {ProjectFileCreateArgs} args - Arguments to create a ProjectFile.
     * @example
     * // Create one ProjectFile
     * const ProjectFile = await prisma.projectFile.create({
     *   data: {
     *     // ... data to create a ProjectFile
     *   }
     * })
     * 
     */
    create<T extends ProjectFileCreateArgs>(args: SelectSubset<T, ProjectFileCreateArgs<ExtArgs>>): Prisma__ProjectFileClient<$Result.GetResult<Prisma.$ProjectFilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectFiles.
     * @param {ProjectFileCreateManyArgs} args - Arguments to create many ProjectFiles.
     * @example
     * // Create many ProjectFiles
     * const projectFile = await prisma.projectFile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectFileCreateManyArgs>(args?: SelectSubset<T, ProjectFileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectFiles and returns the data saved in the database.
     * @param {ProjectFileCreateManyAndReturnArgs} args - Arguments to create many ProjectFiles.
     * @example
     * // Create many ProjectFiles
     * const projectFile = await prisma.projectFile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectFiles and only return the `id`
     * const projectFileWithIdOnly = await prisma.projectFile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectFileCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectFileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectFilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectFile.
     * @param {ProjectFileDeleteArgs} args - Arguments to delete one ProjectFile.
     * @example
     * // Delete one ProjectFile
     * const ProjectFile = await prisma.projectFile.delete({
     *   where: {
     *     // ... filter to delete one ProjectFile
     *   }
     * })
     * 
     */
    delete<T extends ProjectFileDeleteArgs>(args: SelectSubset<T, ProjectFileDeleteArgs<ExtArgs>>): Prisma__ProjectFileClient<$Result.GetResult<Prisma.$ProjectFilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectFile.
     * @param {ProjectFileUpdateArgs} args - Arguments to update one ProjectFile.
     * @example
     * // Update one ProjectFile
     * const projectFile = await prisma.projectFile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectFileUpdateArgs>(args: SelectSubset<T, ProjectFileUpdateArgs<ExtArgs>>): Prisma__ProjectFileClient<$Result.GetResult<Prisma.$ProjectFilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectFiles.
     * @param {ProjectFileDeleteManyArgs} args - Arguments to filter ProjectFiles to delete.
     * @example
     * // Delete a few ProjectFiles
     * const { count } = await prisma.projectFile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectFileDeleteManyArgs>(args?: SelectSubset<T, ProjectFileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectFiles
     * const projectFile = await prisma.projectFile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectFileUpdateManyArgs>(args: SelectSubset<T, ProjectFileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectFiles and returns the data updated in the database.
     * @param {ProjectFileUpdateManyAndReturnArgs} args - Arguments to update many ProjectFiles.
     * @example
     * // Update many ProjectFiles
     * const projectFile = await prisma.projectFile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectFiles and only return the `id`
     * const projectFileWithIdOnly = await prisma.projectFile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectFileUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectFileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectFilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectFile.
     * @param {ProjectFileUpsertArgs} args - Arguments to update or create a ProjectFile.
     * @example
     * // Update or create a ProjectFile
     * const projectFile = await prisma.projectFile.upsert({
     *   create: {
     *     // ... data to create a ProjectFile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectFile we want to update
     *   }
     * })
     */
    upsert<T extends ProjectFileUpsertArgs>(args: SelectSubset<T, ProjectFileUpsertArgs<ExtArgs>>): Prisma__ProjectFileClient<$Result.GetResult<Prisma.$ProjectFilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectFiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFileCountArgs} args - Arguments to filter ProjectFiles to count.
     * @example
     * // Count the number of ProjectFiles
     * const count = await prisma.projectFile.count({
     *   where: {
     *     // ... the filter for the ProjectFiles we want to count
     *   }
     * })
    **/
    count<T extends ProjectFileCountArgs>(
      args?: Subset<T, ProjectFileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectFileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectFileAggregateArgs>(args: Subset<T, ProjectFileAggregateArgs>): Prisma.PrismaPromise<GetProjectFileAggregateType<T>>

    /**
     * Group by ProjectFile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectFileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectFileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectFileGroupByArgs['orderBy'] }
        : { orderBy?: ProjectFileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectFileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectFile model
   */
  readonly fields: ProjectFileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectFile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectFileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    uploader<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectFile model
   */
  interface ProjectFileFieldRefs {
    readonly id: FieldRef<"ProjectFile", 'String'>
    readonly project_id: FieldRef<"ProjectFile", 'String'>
    readonly file_name: FieldRef<"ProjectFile", 'String'>
    readonly file_url: FieldRef<"ProjectFile", 'String'>
    readonly file_type: FieldRef<"ProjectFile", 'FileType'>
    readonly file_size: FieldRef<"ProjectFile", 'BigInt'>
    readonly uploaded_by: FieldRef<"ProjectFile", 'String'>
    readonly created_at: FieldRef<"ProjectFile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectFile findUnique
   */
  export type ProjectFileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFile
     */
    select?: ProjectFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFile
     */
    omit?: ProjectFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFileInclude<ExtArgs> | null
    /**
     * Filter, which ProjectFile to fetch.
     */
    where: ProjectFileWhereUniqueInput
  }

  /**
   * ProjectFile findUniqueOrThrow
   */
  export type ProjectFileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFile
     */
    select?: ProjectFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFile
     */
    omit?: ProjectFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFileInclude<ExtArgs> | null
    /**
     * Filter, which ProjectFile to fetch.
     */
    where: ProjectFileWhereUniqueInput
  }

  /**
   * ProjectFile findFirst
   */
  export type ProjectFileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFile
     */
    select?: ProjectFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFile
     */
    omit?: ProjectFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFileInclude<ExtArgs> | null
    /**
     * Filter, which ProjectFile to fetch.
     */
    where?: ProjectFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectFiles to fetch.
     */
    orderBy?: ProjectFileOrderByWithRelationInput | ProjectFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectFiles.
     */
    cursor?: ProjectFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectFiles.
     */
    distinct?: ProjectFileScalarFieldEnum | ProjectFileScalarFieldEnum[]
  }

  /**
   * ProjectFile findFirstOrThrow
   */
  export type ProjectFileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFile
     */
    select?: ProjectFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFile
     */
    omit?: ProjectFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFileInclude<ExtArgs> | null
    /**
     * Filter, which ProjectFile to fetch.
     */
    where?: ProjectFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectFiles to fetch.
     */
    orderBy?: ProjectFileOrderByWithRelationInput | ProjectFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectFiles.
     */
    cursor?: ProjectFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectFiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectFiles.
     */
    distinct?: ProjectFileScalarFieldEnum | ProjectFileScalarFieldEnum[]
  }

  /**
   * ProjectFile findMany
   */
  export type ProjectFileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFile
     */
    select?: ProjectFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFile
     */
    omit?: ProjectFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFileInclude<ExtArgs> | null
    /**
     * Filter, which ProjectFiles to fetch.
     */
    where?: ProjectFileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectFiles to fetch.
     */
    orderBy?: ProjectFileOrderByWithRelationInput | ProjectFileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectFiles.
     */
    cursor?: ProjectFileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectFiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectFiles.
     */
    skip?: number
    distinct?: ProjectFileScalarFieldEnum | ProjectFileScalarFieldEnum[]
  }

  /**
   * ProjectFile create
   */
  export type ProjectFileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFile
     */
    select?: ProjectFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFile
     */
    omit?: ProjectFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFileInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectFile.
     */
    data: XOR<ProjectFileCreateInput, ProjectFileUncheckedCreateInput>
  }

  /**
   * ProjectFile createMany
   */
  export type ProjectFileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectFiles.
     */
    data: ProjectFileCreateManyInput | ProjectFileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectFile createManyAndReturn
   */
  export type ProjectFileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFile
     */
    select?: ProjectFileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFile
     */
    omit?: ProjectFileOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectFiles.
     */
    data: ProjectFileCreateManyInput | ProjectFileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectFile update
   */
  export type ProjectFileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFile
     */
    select?: ProjectFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFile
     */
    omit?: ProjectFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFileInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectFile.
     */
    data: XOR<ProjectFileUpdateInput, ProjectFileUncheckedUpdateInput>
    /**
     * Choose, which ProjectFile to update.
     */
    where: ProjectFileWhereUniqueInput
  }

  /**
   * ProjectFile updateMany
   */
  export type ProjectFileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectFiles.
     */
    data: XOR<ProjectFileUpdateManyMutationInput, ProjectFileUncheckedUpdateManyInput>
    /**
     * Filter which ProjectFiles to update
     */
    where?: ProjectFileWhereInput
    /**
     * Limit how many ProjectFiles to update.
     */
    limit?: number
  }

  /**
   * ProjectFile updateManyAndReturn
   */
  export type ProjectFileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFile
     */
    select?: ProjectFileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFile
     */
    omit?: ProjectFileOmit<ExtArgs> | null
    /**
     * The data used to update ProjectFiles.
     */
    data: XOR<ProjectFileUpdateManyMutationInput, ProjectFileUncheckedUpdateManyInput>
    /**
     * Filter which ProjectFiles to update
     */
    where?: ProjectFileWhereInput
    /**
     * Limit how many ProjectFiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectFile upsert
   */
  export type ProjectFileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFile
     */
    select?: ProjectFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFile
     */
    omit?: ProjectFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFileInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectFile to update in case it exists.
     */
    where: ProjectFileWhereUniqueInput
    /**
     * In case the ProjectFile found by the `where` argument doesn't exist, create a new ProjectFile with this data.
     */
    create: XOR<ProjectFileCreateInput, ProjectFileUncheckedCreateInput>
    /**
     * In case the ProjectFile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectFileUpdateInput, ProjectFileUncheckedUpdateInput>
  }

  /**
   * ProjectFile delete
   */
  export type ProjectFileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFile
     */
    select?: ProjectFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFile
     */
    omit?: ProjectFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFileInclude<ExtArgs> | null
    /**
     * Filter which ProjectFile to delete.
     */
    where: ProjectFileWhereUniqueInput
  }

  /**
   * ProjectFile deleteMany
   */
  export type ProjectFileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectFiles to delete
     */
    where?: ProjectFileWhereInput
    /**
     * Limit how many ProjectFiles to delete.
     */
    limit?: number
  }

  /**
   * ProjectFile without action
   */
  export type ProjectFileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectFile
     */
    select?: ProjectFileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectFile
     */
    omit?: ProjectFileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectFileInclude<ExtArgs> | null
  }


  /**
   * Model ProjectUpdate
   */

  export type AggregateProjectUpdate = {
    _count: ProjectUpdateCountAggregateOutputType | null
    _min: ProjectUpdateMinAggregateOutputType | null
    _max: ProjectUpdateMaxAggregateOutputType | null
  }

  export type ProjectUpdateMinAggregateOutputType = {
    id: string | null
    project_id: string | null
    update_text: string | null
    created_by: string | null
    created_at: Date | null
  }

  export type ProjectUpdateMaxAggregateOutputType = {
    id: string | null
    project_id: string | null
    update_text: string | null
    created_by: string | null
    created_at: Date | null
  }

  export type ProjectUpdateCountAggregateOutputType = {
    id: number
    project_id: number
    update_text: number
    created_by: number
    created_at: number
    _all: number
  }


  export type ProjectUpdateMinAggregateInputType = {
    id?: true
    project_id?: true
    update_text?: true
    created_by?: true
    created_at?: true
  }

  export type ProjectUpdateMaxAggregateInputType = {
    id?: true
    project_id?: true
    update_text?: true
    created_by?: true
    created_at?: true
  }

  export type ProjectUpdateCountAggregateInputType = {
    id?: true
    project_id?: true
    update_text?: true
    created_by?: true
    created_at?: true
    _all?: true
  }

  export type ProjectUpdateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectUpdate to aggregate.
     */
    where?: ProjectUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectUpdates to fetch.
     */
    orderBy?: ProjectUpdateOrderByWithRelationInput | ProjectUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProjectUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ProjectUpdates
    **/
    _count?: true | ProjectUpdateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProjectUpdateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProjectUpdateMaxAggregateInputType
  }

  export type GetProjectUpdateAggregateType<T extends ProjectUpdateAggregateArgs> = {
        [P in keyof T & keyof AggregateProjectUpdate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProjectUpdate[P]>
      : GetScalarType<T[P], AggregateProjectUpdate[P]>
  }




  export type ProjectUpdateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProjectUpdateWhereInput
    orderBy?: ProjectUpdateOrderByWithAggregationInput | ProjectUpdateOrderByWithAggregationInput[]
    by: ProjectUpdateScalarFieldEnum[] | ProjectUpdateScalarFieldEnum
    having?: ProjectUpdateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProjectUpdateCountAggregateInputType | true
    _min?: ProjectUpdateMinAggregateInputType
    _max?: ProjectUpdateMaxAggregateInputType
  }

  export type ProjectUpdateGroupByOutputType = {
    id: string
    project_id: string
    update_text: string
    created_by: string
    created_at: Date
    _count: ProjectUpdateCountAggregateOutputType | null
    _min: ProjectUpdateMinAggregateOutputType | null
    _max: ProjectUpdateMaxAggregateOutputType | null
  }

  type GetProjectUpdateGroupByPayload<T extends ProjectUpdateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProjectUpdateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProjectUpdateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProjectUpdateGroupByOutputType[P]>
            : GetScalarType<T[P], ProjectUpdateGroupByOutputType[P]>
        }
      >
    >


  export type ProjectUpdateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    project_id?: boolean
    update_text?: boolean
    created_by?: boolean
    created_at?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectUpdate"]>

  export type ProjectUpdateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    project_id?: boolean
    update_text?: boolean
    created_by?: boolean
    created_at?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectUpdate"]>

  export type ProjectUpdateSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    project_id?: boolean
    update_text?: boolean
    created_by?: boolean
    created_at?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["projectUpdate"]>

  export type ProjectUpdateSelectScalar = {
    id?: boolean
    project_id?: boolean
    update_text?: boolean
    created_by?: boolean
    created_at?: boolean
  }

  export type ProjectUpdateOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "project_id" | "update_text" | "created_by" | "created_at", ExtArgs["result"]["projectUpdate"]>
  export type ProjectUpdateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectUpdateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type ProjectUpdateIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    author?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $ProjectUpdatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ProjectUpdate"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      author: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      project_id: string
      update_text: string
      created_by: string
      created_at: Date
    }, ExtArgs["result"]["projectUpdate"]>
    composites: {}
  }

  type ProjectUpdateGetPayload<S extends boolean | null | undefined | ProjectUpdateDefaultArgs> = $Result.GetResult<Prisma.$ProjectUpdatePayload, S>

  type ProjectUpdateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ProjectUpdateFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProjectUpdateCountAggregateInputType | true
    }

  export interface ProjectUpdateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ProjectUpdate'], meta: { name: 'ProjectUpdate' } }
    /**
     * Find zero or one ProjectUpdate that matches the filter.
     * @param {ProjectUpdateFindUniqueArgs} args - Arguments to find a ProjectUpdate
     * @example
     * // Get one ProjectUpdate
     * const projectUpdate = await prisma.projectUpdate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProjectUpdateFindUniqueArgs>(args: SelectSubset<T, ProjectUpdateFindUniqueArgs<ExtArgs>>): Prisma__ProjectUpdateClient<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ProjectUpdate that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ProjectUpdateFindUniqueOrThrowArgs} args - Arguments to find a ProjectUpdate
     * @example
     * // Get one ProjectUpdate
     * const projectUpdate = await prisma.projectUpdate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProjectUpdateFindUniqueOrThrowArgs>(args: SelectSubset<T, ProjectUpdateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProjectUpdateClient<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectUpdate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateFindFirstArgs} args - Arguments to find a ProjectUpdate
     * @example
     * // Get one ProjectUpdate
     * const projectUpdate = await prisma.projectUpdate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProjectUpdateFindFirstArgs>(args?: SelectSubset<T, ProjectUpdateFindFirstArgs<ExtArgs>>): Prisma__ProjectUpdateClient<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ProjectUpdate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateFindFirstOrThrowArgs} args - Arguments to find a ProjectUpdate
     * @example
     * // Get one ProjectUpdate
     * const projectUpdate = await prisma.projectUpdate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProjectUpdateFindFirstOrThrowArgs>(args?: SelectSubset<T, ProjectUpdateFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProjectUpdateClient<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ProjectUpdates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ProjectUpdates
     * const projectUpdates = await prisma.projectUpdate.findMany()
     * 
     * // Get first 10 ProjectUpdates
     * const projectUpdates = await prisma.projectUpdate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const projectUpdateWithIdOnly = await prisma.projectUpdate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProjectUpdateFindManyArgs>(args?: SelectSubset<T, ProjectUpdateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ProjectUpdate.
     * @param {ProjectUpdateCreateArgs} args - Arguments to create a ProjectUpdate.
     * @example
     * // Create one ProjectUpdate
     * const ProjectUpdate = await prisma.projectUpdate.create({
     *   data: {
     *     // ... data to create a ProjectUpdate
     *   }
     * })
     * 
     */
    create<T extends ProjectUpdateCreateArgs>(args: SelectSubset<T, ProjectUpdateCreateArgs<ExtArgs>>): Prisma__ProjectUpdateClient<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ProjectUpdates.
     * @param {ProjectUpdateCreateManyArgs} args - Arguments to create many ProjectUpdates.
     * @example
     * // Create many ProjectUpdates
     * const projectUpdate = await prisma.projectUpdate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProjectUpdateCreateManyArgs>(args?: SelectSubset<T, ProjectUpdateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ProjectUpdates and returns the data saved in the database.
     * @param {ProjectUpdateCreateManyAndReturnArgs} args - Arguments to create many ProjectUpdates.
     * @example
     * // Create many ProjectUpdates
     * const projectUpdate = await prisma.projectUpdate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ProjectUpdates and only return the `id`
     * const projectUpdateWithIdOnly = await prisma.projectUpdate.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProjectUpdateCreateManyAndReturnArgs>(args?: SelectSubset<T, ProjectUpdateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ProjectUpdate.
     * @param {ProjectUpdateDeleteArgs} args - Arguments to delete one ProjectUpdate.
     * @example
     * // Delete one ProjectUpdate
     * const ProjectUpdate = await prisma.projectUpdate.delete({
     *   where: {
     *     // ... filter to delete one ProjectUpdate
     *   }
     * })
     * 
     */
    delete<T extends ProjectUpdateDeleteArgs>(args: SelectSubset<T, ProjectUpdateDeleteArgs<ExtArgs>>): Prisma__ProjectUpdateClient<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ProjectUpdate.
     * @param {ProjectUpdateUpdateArgs} args - Arguments to update one ProjectUpdate.
     * @example
     * // Update one ProjectUpdate
     * const projectUpdate = await prisma.projectUpdate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProjectUpdateUpdateArgs>(args: SelectSubset<T, ProjectUpdateUpdateArgs<ExtArgs>>): Prisma__ProjectUpdateClient<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ProjectUpdates.
     * @param {ProjectUpdateDeleteManyArgs} args - Arguments to filter ProjectUpdates to delete.
     * @example
     * // Delete a few ProjectUpdates
     * const { count } = await prisma.projectUpdate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProjectUpdateDeleteManyArgs>(args?: SelectSubset<T, ProjectUpdateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectUpdates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ProjectUpdates
     * const projectUpdate = await prisma.projectUpdate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProjectUpdateUpdateManyArgs>(args: SelectSubset<T, ProjectUpdateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ProjectUpdates and returns the data updated in the database.
     * @param {ProjectUpdateUpdateManyAndReturnArgs} args - Arguments to update many ProjectUpdates.
     * @example
     * // Update many ProjectUpdates
     * const projectUpdate = await prisma.projectUpdate.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ProjectUpdates and only return the `id`
     * const projectUpdateWithIdOnly = await prisma.projectUpdate.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ProjectUpdateUpdateManyAndReturnArgs>(args: SelectSubset<T, ProjectUpdateUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ProjectUpdate.
     * @param {ProjectUpdateUpsertArgs} args - Arguments to update or create a ProjectUpdate.
     * @example
     * // Update or create a ProjectUpdate
     * const projectUpdate = await prisma.projectUpdate.upsert({
     *   create: {
     *     // ... data to create a ProjectUpdate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ProjectUpdate we want to update
     *   }
     * })
     */
    upsert<T extends ProjectUpdateUpsertArgs>(args: SelectSubset<T, ProjectUpdateUpsertArgs<ExtArgs>>): Prisma__ProjectUpdateClient<$Result.GetResult<Prisma.$ProjectUpdatePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ProjectUpdates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateCountArgs} args - Arguments to filter ProjectUpdates to count.
     * @example
     * // Count the number of ProjectUpdates
     * const count = await prisma.projectUpdate.count({
     *   where: {
     *     // ... the filter for the ProjectUpdates we want to count
     *   }
     * })
    **/
    count<T extends ProjectUpdateCountArgs>(
      args?: Subset<T, ProjectUpdateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProjectUpdateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ProjectUpdate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProjectUpdateAggregateArgs>(args: Subset<T, ProjectUpdateAggregateArgs>): Prisma.PrismaPromise<GetProjectUpdateAggregateType<T>>

    /**
     * Group by ProjectUpdate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProjectUpdateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProjectUpdateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProjectUpdateGroupByArgs['orderBy'] }
        : { orderBy?: ProjectUpdateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProjectUpdateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProjectUpdateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ProjectUpdate model
   */
  readonly fields: ProjectUpdateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ProjectUpdate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProjectUpdateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    author<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ProjectUpdate model
   */
  interface ProjectUpdateFieldRefs {
    readonly id: FieldRef<"ProjectUpdate", 'String'>
    readonly project_id: FieldRef<"ProjectUpdate", 'String'>
    readonly update_text: FieldRef<"ProjectUpdate", 'String'>
    readonly created_by: FieldRef<"ProjectUpdate", 'String'>
    readonly created_at: FieldRef<"ProjectUpdate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ProjectUpdate findUnique
   */
  export type ProjectUpdateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
    /**
     * Filter, which ProjectUpdate to fetch.
     */
    where: ProjectUpdateWhereUniqueInput
  }

  /**
   * ProjectUpdate findUniqueOrThrow
   */
  export type ProjectUpdateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
    /**
     * Filter, which ProjectUpdate to fetch.
     */
    where: ProjectUpdateWhereUniqueInput
  }

  /**
   * ProjectUpdate findFirst
   */
  export type ProjectUpdateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
    /**
     * Filter, which ProjectUpdate to fetch.
     */
    where?: ProjectUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectUpdates to fetch.
     */
    orderBy?: ProjectUpdateOrderByWithRelationInput | ProjectUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectUpdates.
     */
    cursor?: ProjectUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectUpdates.
     */
    distinct?: ProjectUpdateScalarFieldEnum | ProjectUpdateScalarFieldEnum[]
  }

  /**
   * ProjectUpdate findFirstOrThrow
   */
  export type ProjectUpdateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
    /**
     * Filter, which ProjectUpdate to fetch.
     */
    where?: ProjectUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectUpdates to fetch.
     */
    orderBy?: ProjectUpdateOrderByWithRelationInput | ProjectUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ProjectUpdates.
     */
    cursor?: ProjectUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectUpdates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ProjectUpdates.
     */
    distinct?: ProjectUpdateScalarFieldEnum | ProjectUpdateScalarFieldEnum[]
  }

  /**
   * ProjectUpdate findMany
   */
  export type ProjectUpdateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
    /**
     * Filter, which ProjectUpdates to fetch.
     */
    where?: ProjectUpdateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ProjectUpdates to fetch.
     */
    orderBy?: ProjectUpdateOrderByWithRelationInput | ProjectUpdateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ProjectUpdates.
     */
    cursor?: ProjectUpdateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ProjectUpdates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ProjectUpdates.
     */
    skip?: number
    distinct?: ProjectUpdateScalarFieldEnum | ProjectUpdateScalarFieldEnum[]
  }

  /**
   * ProjectUpdate create
   */
  export type ProjectUpdateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
    /**
     * The data needed to create a ProjectUpdate.
     */
    data: XOR<ProjectUpdateCreateInput, ProjectUpdateUncheckedCreateInput>
  }

  /**
   * ProjectUpdate createMany
   */
  export type ProjectUpdateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ProjectUpdates.
     */
    data: ProjectUpdateCreateManyInput | ProjectUpdateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ProjectUpdate createManyAndReturn
   */
  export type ProjectUpdateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * The data used to create many ProjectUpdates.
     */
    data: ProjectUpdateCreateManyInput | ProjectUpdateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectUpdate update
   */
  export type ProjectUpdateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
    /**
     * The data needed to update a ProjectUpdate.
     */
    data: XOR<ProjectUpdateUpdateInput, ProjectUpdateUncheckedUpdateInput>
    /**
     * Choose, which ProjectUpdate to update.
     */
    where: ProjectUpdateWhereUniqueInput
  }

  /**
   * ProjectUpdate updateMany
   */
  export type ProjectUpdateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ProjectUpdates.
     */
    data: XOR<ProjectUpdateUpdateManyMutationInput, ProjectUpdateUncheckedUpdateManyInput>
    /**
     * Filter which ProjectUpdates to update
     */
    where?: ProjectUpdateWhereInput
    /**
     * Limit how many ProjectUpdates to update.
     */
    limit?: number
  }

  /**
   * ProjectUpdate updateManyAndReturn
   */
  export type ProjectUpdateUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * The data used to update ProjectUpdates.
     */
    data: XOR<ProjectUpdateUpdateManyMutationInput, ProjectUpdateUncheckedUpdateManyInput>
    /**
     * Filter which ProjectUpdates to update
     */
    where?: ProjectUpdateWhereInput
    /**
     * Limit how many ProjectUpdates to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ProjectUpdate upsert
   */
  export type ProjectUpdateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
    /**
     * The filter to search for the ProjectUpdate to update in case it exists.
     */
    where: ProjectUpdateWhereUniqueInput
    /**
     * In case the ProjectUpdate found by the `where` argument doesn't exist, create a new ProjectUpdate with this data.
     */
    create: XOR<ProjectUpdateCreateInput, ProjectUpdateUncheckedCreateInput>
    /**
     * In case the ProjectUpdate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProjectUpdateUpdateInput, ProjectUpdateUncheckedUpdateInput>
  }

  /**
   * ProjectUpdate delete
   */
  export type ProjectUpdateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
    /**
     * Filter which ProjectUpdate to delete.
     */
    where: ProjectUpdateWhereUniqueInput
  }

  /**
   * ProjectUpdate deleteMany
   */
  export type ProjectUpdateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ProjectUpdates to delete
     */
    where?: ProjectUpdateWhereInput
    /**
     * Limit how many ProjectUpdates to delete.
     */
    limit?: number
  }

  /**
   * ProjectUpdate without action
   */
  export type ProjectUpdateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProjectUpdate
     */
    select?: ProjectUpdateSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ProjectUpdate
     */
    omit?: ProjectUpdateOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectUpdateInclude<ExtArgs> | null
  }


  /**
   * Model SupportRequest
   */

  export type AggregateSupportRequest = {
    _count: SupportRequestCountAggregateOutputType | null
    _min: SupportRequestMinAggregateOutputType | null
    _max: SupportRequestMaxAggregateOutputType | null
  }

  export type SupportRequestMinAggregateOutputType = {
    id: string | null
    project_id: string | null
    client_id: string | null
    subject: string | null
    description: string | null
    status: $Enums.SupportStatus | null
    priority: $Enums.PriorityLevel | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SupportRequestMaxAggregateOutputType = {
    id: string | null
    project_id: string | null
    client_id: string | null
    subject: string | null
    description: string | null
    status: $Enums.SupportStatus | null
    priority: $Enums.PriorityLevel | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type SupportRequestCountAggregateOutputType = {
    id: number
    project_id: number
    client_id: number
    subject: number
    description: number
    status: number
    priority: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type SupportRequestMinAggregateInputType = {
    id?: true
    project_id?: true
    client_id?: true
    subject?: true
    description?: true
    status?: true
    priority?: true
    created_at?: true
    updated_at?: true
  }

  export type SupportRequestMaxAggregateInputType = {
    id?: true
    project_id?: true
    client_id?: true
    subject?: true
    description?: true
    status?: true
    priority?: true
    created_at?: true
    updated_at?: true
  }

  export type SupportRequestCountAggregateInputType = {
    id?: true
    project_id?: true
    client_id?: true
    subject?: true
    description?: true
    status?: true
    priority?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type SupportRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportRequest to aggregate.
     */
    where?: SupportRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportRequests to fetch.
     */
    orderBy?: SupportRequestOrderByWithRelationInput | SupportRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupportRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupportRequests
    **/
    _count?: true | SupportRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupportRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupportRequestMaxAggregateInputType
  }

  export type GetSupportRequestAggregateType<T extends SupportRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateSupportRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupportRequest[P]>
      : GetScalarType<T[P], AggregateSupportRequest[P]>
  }




  export type SupportRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportRequestWhereInput
    orderBy?: SupportRequestOrderByWithAggregationInput | SupportRequestOrderByWithAggregationInput[]
    by: SupportRequestScalarFieldEnum[] | SupportRequestScalarFieldEnum
    having?: SupportRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupportRequestCountAggregateInputType | true
    _min?: SupportRequestMinAggregateInputType
    _max?: SupportRequestMaxAggregateInputType
  }

  export type SupportRequestGroupByOutputType = {
    id: string
    project_id: string | null
    client_id: string
    subject: string
    description: string
    status: $Enums.SupportStatus
    priority: $Enums.PriorityLevel
    created_at: Date
    updated_at: Date
    _count: SupportRequestCountAggregateOutputType | null
    _min: SupportRequestMinAggregateOutputType | null
    _max: SupportRequestMaxAggregateOutputType | null
  }

  type GetSupportRequestGroupByPayload<T extends SupportRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupportRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupportRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupportRequestGroupByOutputType[P]>
            : GetScalarType<T[P], SupportRequestGroupByOutputType[P]>
        }
      >
    >


  export type SupportRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    project_id?: boolean
    client_id?: boolean
    subject?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | SupportRequest$projectArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | SupportRequest$messagesArgs<ExtArgs>
    _count?: boolean | SupportRequestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supportRequest"]>

  export type SupportRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    project_id?: boolean
    client_id?: boolean
    subject?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | SupportRequest$projectArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supportRequest"]>

  export type SupportRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    project_id?: boolean
    client_id?: boolean
    subject?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | SupportRequest$projectArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supportRequest"]>

  export type SupportRequestSelectScalar = {
    id?: boolean
    project_id?: boolean
    client_id?: boolean
    subject?: boolean
    description?: boolean
    status?: boolean
    priority?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type SupportRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "project_id" | "client_id" | "subject" | "description" | "status" | "priority" | "created_at" | "updated_at", ExtArgs["result"]["supportRequest"]>
  export type SupportRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | SupportRequest$projectArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
    messages?: boolean | SupportRequest$messagesArgs<ExtArgs>
    _count?: boolean | SupportRequestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type SupportRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | SupportRequest$projectArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SupportRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | SupportRequest$projectArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SupportRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupportRequest"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs> | null
      client: Prisma.$UserPayload<ExtArgs>
      messages: Prisma.$SupportMessagePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      project_id: string | null
      client_id: string
      subject: string
      description: string
      status: $Enums.SupportStatus
      priority: $Enums.PriorityLevel
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["supportRequest"]>
    composites: {}
  }

  type SupportRequestGetPayload<S extends boolean | null | undefined | SupportRequestDefaultArgs> = $Result.GetResult<Prisma.$SupportRequestPayload, S>

  type SupportRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupportRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupportRequestCountAggregateInputType | true
    }

  export interface SupportRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupportRequest'], meta: { name: 'SupportRequest' } }
    /**
     * Find zero or one SupportRequest that matches the filter.
     * @param {SupportRequestFindUniqueArgs} args - Arguments to find a SupportRequest
     * @example
     * // Get one SupportRequest
     * const supportRequest = await prisma.supportRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupportRequestFindUniqueArgs>(args: SelectSubset<T, SupportRequestFindUniqueArgs<ExtArgs>>): Prisma__SupportRequestClient<$Result.GetResult<Prisma.$SupportRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SupportRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupportRequestFindUniqueOrThrowArgs} args - Arguments to find a SupportRequest
     * @example
     * // Get one SupportRequest
     * const supportRequest = await prisma.supportRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupportRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, SupportRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupportRequestClient<$Result.GetResult<Prisma.$SupportRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupportRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportRequestFindFirstArgs} args - Arguments to find a SupportRequest
     * @example
     * // Get one SupportRequest
     * const supportRequest = await prisma.supportRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupportRequestFindFirstArgs>(args?: SelectSubset<T, SupportRequestFindFirstArgs<ExtArgs>>): Prisma__SupportRequestClient<$Result.GetResult<Prisma.$SupportRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupportRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportRequestFindFirstOrThrowArgs} args - Arguments to find a SupportRequest
     * @example
     * // Get one SupportRequest
     * const supportRequest = await prisma.supportRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupportRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, SupportRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupportRequestClient<$Result.GetResult<Prisma.$SupportRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SupportRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupportRequests
     * const supportRequests = await prisma.supportRequest.findMany()
     * 
     * // Get first 10 SupportRequests
     * const supportRequests = await prisma.supportRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supportRequestWithIdOnly = await prisma.supportRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupportRequestFindManyArgs>(args?: SelectSubset<T, SupportRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SupportRequest.
     * @param {SupportRequestCreateArgs} args - Arguments to create a SupportRequest.
     * @example
     * // Create one SupportRequest
     * const SupportRequest = await prisma.supportRequest.create({
     *   data: {
     *     // ... data to create a SupportRequest
     *   }
     * })
     * 
     */
    create<T extends SupportRequestCreateArgs>(args: SelectSubset<T, SupportRequestCreateArgs<ExtArgs>>): Prisma__SupportRequestClient<$Result.GetResult<Prisma.$SupportRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SupportRequests.
     * @param {SupportRequestCreateManyArgs} args - Arguments to create many SupportRequests.
     * @example
     * // Create many SupportRequests
     * const supportRequest = await prisma.supportRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupportRequestCreateManyArgs>(args?: SelectSubset<T, SupportRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupportRequests and returns the data saved in the database.
     * @param {SupportRequestCreateManyAndReturnArgs} args - Arguments to create many SupportRequests.
     * @example
     * // Create many SupportRequests
     * const supportRequest = await prisma.supportRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupportRequests and only return the `id`
     * const supportRequestWithIdOnly = await prisma.supportRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupportRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, SupportRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SupportRequest.
     * @param {SupportRequestDeleteArgs} args - Arguments to delete one SupportRequest.
     * @example
     * // Delete one SupportRequest
     * const SupportRequest = await prisma.supportRequest.delete({
     *   where: {
     *     // ... filter to delete one SupportRequest
     *   }
     * })
     * 
     */
    delete<T extends SupportRequestDeleteArgs>(args: SelectSubset<T, SupportRequestDeleteArgs<ExtArgs>>): Prisma__SupportRequestClient<$Result.GetResult<Prisma.$SupportRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SupportRequest.
     * @param {SupportRequestUpdateArgs} args - Arguments to update one SupportRequest.
     * @example
     * // Update one SupportRequest
     * const supportRequest = await prisma.supportRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupportRequestUpdateArgs>(args: SelectSubset<T, SupportRequestUpdateArgs<ExtArgs>>): Prisma__SupportRequestClient<$Result.GetResult<Prisma.$SupportRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SupportRequests.
     * @param {SupportRequestDeleteManyArgs} args - Arguments to filter SupportRequests to delete.
     * @example
     * // Delete a few SupportRequests
     * const { count } = await prisma.supportRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupportRequestDeleteManyArgs>(args?: SelectSubset<T, SupportRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupportRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupportRequests
     * const supportRequest = await prisma.supportRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupportRequestUpdateManyArgs>(args: SelectSubset<T, SupportRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupportRequests and returns the data updated in the database.
     * @param {SupportRequestUpdateManyAndReturnArgs} args - Arguments to update many SupportRequests.
     * @example
     * // Update many SupportRequests
     * const supportRequest = await prisma.supportRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SupportRequests and only return the `id`
     * const supportRequestWithIdOnly = await prisma.supportRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupportRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, SupportRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SupportRequest.
     * @param {SupportRequestUpsertArgs} args - Arguments to update or create a SupportRequest.
     * @example
     * // Update or create a SupportRequest
     * const supportRequest = await prisma.supportRequest.upsert({
     *   create: {
     *     // ... data to create a SupportRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupportRequest we want to update
     *   }
     * })
     */
    upsert<T extends SupportRequestUpsertArgs>(args: SelectSubset<T, SupportRequestUpsertArgs<ExtArgs>>): Prisma__SupportRequestClient<$Result.GetResult<Prisma.$SupportRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SupportRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportRequestCountArgs} args - Arguments to filter SupportRequests to count.
     * @example
     * // Count the number of SupportRequests
     * const count = await prisma.supportRequest.count({
     *   where: {
     *     // ... the filter for the SupportRequests we want to count
     *   }
     * })
    **/
    count<T extends SupportRequestCountArgs>(
      args?: Subset<T, SupportRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupportRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupportRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupportRequestAggregateArgs>(args: Subset<T, SupportRequestAggregateArgs>): Prisma.PrismaPromise<GetSupportRequestAggregateType<T>>

    /**
     * Group by SupportRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupportRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupportRequestGroupByArgs['orderBy'] }
        : { orderBy?: SupportRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupportRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupportRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupportRequest model
   */
  readonly fields: SupportRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupportRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupportRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends SupportRequest$projectArgs<ExtArgs> = {}>(args?: Subset<T, SupportRequest$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    client<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    messages<T extends SupportRequest$messagesArgs<ExtArgs> = {}>(args?: Subset<T, SupportRequest$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupportRequest model
   */
  interface SupportRequestFieldRefs {
    readonly id: FieldRef<"SupportRequest", 'String'>
    readonly project_id: FieldRef<"SupportRequest", 'String'>
    readonly client_id: FieldRef<"SupportRequest", 'String'>
    readonly subject: FieldRef<"SupportRequest", 'String'>
    readonly description: FieldRef<"SupportRequest", 'String'>
    readonly status: FieldRef<"SupportRequest", 'SupportStatus'>
    readonly priority: FieldRef<"SupportRequest", 'PriorityLevel'>
    readonly created_at: FieldRef<"SupportRequest", 'DateTime'>
    readonly updated_at: FieldRef<"SupportRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SupportRequest findUnique
   */
  export type SupportRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportRequest
     */
    select?: SupportRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportRequest
     */
    omit?: SupportRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportRequestInclude<ExtArgs> | null
    /**
     * Filter, which SupportRequest to fetch.
     */
    where: SupportRequestWhereUniqueInput
  }

  /**
   * SupportRequest findUniqueOrThrow
   */
  export type SupportRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportRequest
     */
    select?: SupportRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportRequest
     */
    omit?: SupportRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportRequestInclude<ExtArgs> | null
    /**
     * Filter, which SupportRequest to fetch.
     */
    where: SupportRequestWhereUniqueInput
  }

  /**
   * SupportRequest findFirst
   */
  export type SupportRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportRequest
     */
    select?: SupportRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportRequest
     */
    omit?: SupportRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportRequestInclude<ExtArgs> | null
    /**
     * Filter, which SupportRequest to fetch.
     */
    where?: SupportRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportRequests to fetch.
     */
    orderBy?: SupportRequestOrderByWithRelationInput | SupportRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportRequests.
     */
    cursor?: SupportRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportRequests.
     */
    distinct?: SupportRequestScalarFieldEnum | SupportRequestScalarFieldEnum[]
  }

  /**
   * SupportRequest findFirstOrThrow
   */
  export type SupportRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportRequest
     */
    select?: SupportRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportRequest
     */
    omit?: SupportRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportRequestInclude<ExtArgs> | null
    /**
     * Filter, which SupportRequest to fetch.
     */
    where?: SupportRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportRequests to fetch.
     */
    orderBy?: SupportRequestOrderByWithRelationInput | SupportRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportRequests.
     */
    cursor?: SupportRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportRequests.
     */
    distinct?: SupportRequestScalarFieldEnum | SupportRequestScalarFieldEnum[]
  }

  /**
   * SupportRequest findMany
   */
  export type SupportRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportRequest
     */
    select?: SupportRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportRequest
     */
    omit?: SupportRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportRequestInclude<ExtArgs> | null
    /**
     * Filter, which SupportRequests to fetch.
     */
    where?: SupportRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportRequests to fetch.
     */
    orderBy?: SupportRequestOrderByWithRelationInput | SupportRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupportRequests.
     */
    cursor?: SupportRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportRequests.
     */
    skip?: number
    distinct?: SupportRequestScalarFieldEnum | SupportRequestScalarFieldEnum[]
  }

  /**
   * SupportRequest create
   */
  export type SupportRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportRequest
     */
    select?: SupportRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportRequest
     */
    omit?: SupportRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a SupportRequest.
     */
    data: XOR<SupportRequestCreateInput, SupportRequestUncheckedCreateInput>
  }

  /**
   * SupportRequest createMany
   */
  export type SupportRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupportRequests.
     */
    data: SupportRequestCreateManyInput | SupportRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupportRequest createManyAndReturn
   */
  export type SupportRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportRequest
     */
    select?: SupportRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupportRequest
     */
    omit?: SupportRequestOmit<ExtArgs> | null
    /**
     * The data used to create many SupportRequests.
     */
    data: SupportRequestCreateManyInput | SupportRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupportRequest update
   */
  export type SupportRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportRequest
     */
    select?: SupportRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportRequest
     */
    omit?: SupportRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a SupportRequest.
     */
    data: XOR<SupportRequestUpdateInput, SupportRequestUncheckedUpdateInput>
    /**
     * Choose, which SupportRequest to update.
     */
    where: SupportRequestWhereUniqueInput
  }

  /**
   * SupportRequest updateMany
   */
  export type SupportRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupportRequests.
     */
    data: XOR<SupportRequestUpdateManyMutationInput, SupportRequestUncheckedUpdateManyInput>
    /**
     * Filter which SupportRequests to update
     */
    where?: SupportRequestWhereInput
    /**
     * Limit how many SupportRequests to update.
     */
    limit?: number
  }

  /**
   * SupportRequest updateManyAndReturn
   */
  export type SupportRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportRequest
     */
    select?: SupportRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupportRequest
     */
    omit?: SupportRequestOmit<ExtArgs> | null
    /**
     * The data used to update SupportRequests.
     */
    data: XOR<SupportRequestUpdateManyMutationInput, SupportRequestUncheckedUpdateManyInput>
    /**
     * Filter which SupportRequests to update
     */
    where?: SupportRequestWhereInput
    /**
     * Limit how many SupportRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupportRequest upsert
   */
  export type SupportRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportRequest
     */
    select?: SupportRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportRequest
     */
    omit?: SupportRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the SupportRequest to update in case it exists.
     */
    where: SupportRequestWhereUniqueInput
    /**
     * In case the SupportRequest found by the `where` argument doesn't exist, create a new SupportRequest with this data.
     */
    create: XOR<SupportRequestCreateInput, SupportRequestUncheckedCreateInput>
    /**
     * In case the SupportRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupportRequestUpdateInput, SupportRequestUncheckedUpdateInput>
  }

  /**
   * SupportRequest delete
   */
  export type SupportRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportRequest
     */
    select?: SupportRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportRequest
     */
    omit?: SupportRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportRequestInclude<ExtArgs> | null
    /**
     * Filter which SupportRequest to delete.
     */
    where: SupportRequestWhereUniqueInput
  }

  /**
   * SupportRequest deleteMany
   */
  export type SupportRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportRequests to delete
     */
    where?: SupportRequestWhereInput
    /**
     * Limit how many SupportRequests to delete.
     */
    limit?: number
  }

  /**
   * SupportRequest.project
   */
  export type SupportRequest$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * SupportRequest.messages
   */
  export type SupportRequest$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportMessage
     */
    omit?: SupportMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
    where?: SupportMessageWhereInput
    orderBy?: SupportMessageOrderByWithRelationInput | SupportMessageOrderByWithRelationInput[]
    cursor?: SupportMessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SupportMessageScalarFieldEnum | SupportMessageScalarFieldEnum[]
  }

  /**
   * SupportRequest without action
   */
  export type SupportRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportRequest
     */
    select?: SupportRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportRequest
     */
    omit?: SupportRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportRequestInclude<ExtArgs> | null
  }


  /**
   * Model SupportMessage
   */

  export type AggregateSupportMessage = {
    _count: SupportMessageCountAggregateOutputType | null
    _min: SupportMessageMinAggregateOutputType | null
    _max: SupportMessageMaxAggregateOutputType | null
  }

  export type SupportMessageMinAggregateOutputType = {
    id: string | null
    support_request_id: string | null
    user_id: string | null
    message: string | null
    created_at: Date | null
  }

  export type SupportMessageMaxAggregateOutputType = {
    id: string | null
    support_request_id: string | null
    user_id: string | null
    message: string | null
    created_at: Date | null
  }

  export type SupportMessageCountAggregateOutputType = {
    id: number
    support_request_id: number
    user_id: number
    message: number
    created_at: number
    _all: number
  }


  export type SupportMessageMinAggregateInputType = {
    id?: true
    support_request_id?: true
    user_id?: true
    message?: true
    created_at?: true
  }

  export type SupportMessageMaxAggregateInputType = {
    id?: true
    support_request_id?: true
    user_id?: true
    message?: true
    created_at?: true
  }

  export type SupportMessageCountAggregateInputType = {
    id?: true
    support_request_id?: true
    user_id?: true
    message?: true
    created_at?: true
    _all?: true
  }

  export type SupportMessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportMessage to aggregate.
     */
    where?: SupportMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportMessages to fetch.
     */
    orderBy?: SupportMessageOrderByWithRelationInput | SupportMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SupportMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SupportMessages
    **/
    _count?: true | SupportMessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SupportMessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SupportMessageMaxAggregateInputType
  }

  export type GetSupportMessageAggregateType<T extends SupportMessageAggregateArgs> = {
        [P in keyof T & keyof AggregateSupportMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSupportMessage[P]>
      : GetScalarType<T[P], AggregateSupportMessage[P]>
  }




  export type SupportMessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SupportMessageWhereInput
    orderBy?: SupportMessageOrderByWithAggregationInput | SupportMessageOrderByWithAggregationInput[]
    by: SupportMessageScalarFieldEnum[] | SupportMessageScalarFieldEnum
    having?: SupportMessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SupportMessageCountAggregateInputType | true
    _min?: SupportMessageMinAggregateInputType
    _max?: SupportMessageMaxAggregateInputType
  }

  export type SupportMessageGroupByOutputType = {
    id: string
    support_request_id: string
    user_id: string
    message: string
    created_at: Date
    _count: SupportMessageCountAggregateOutputType | null
    _min: SupportMessageMinAggregateOutputType | null
    _max: SupportMessageMaxAggregateOutputType | null
  }

  type GetSupportMessageGroupByPayload<T extends SupportMessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SupportMessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SupportMessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SupportMessageGroupByOutputType[P]>
            : GetScalarType<T[P], SupportMessageGroupByOutputType[P]>
        }
      >
    >


  export type SupportMessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    support_request_id?: boolean
    user_id?: boolean
    message?: boolean
    created_at?: boolean
    request?: boolean | SupportRequestDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supportMessage"]>

  export type SupportMessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    support_request_id?: boolean
    user_id?: boolean
    message?: boolean
    created_at?: boolean
    request?: boolean | SupportRequestDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supportMessage"]>

  export type SupportMessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    support_request_id?: boolean
    user_id?: boolean
    message?: boolean
    created_at?: boolean
    request?: boolean | SupportRequestDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["supportMessage"]>

  export type SupportMessageSelectScalar = {
    id?: boolean
    support_request_id?: boolean
    user_id?: boolean
    message?: boolean
    created_at?: boolean
  }

  export type SupportMessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "support_request_id" | "user_id" | "message" | "created_at", ExtArgs["result"]["supportMessage"]>
  export type SupportMessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | SupportRequestDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SupportMessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | SupportRequestDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SupportMessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    request?: boolean | SupportRequestDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SupportMessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SupportMessage"
    objects: {
      request: Prisma.$SupportRequestPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      support_request_id: string
      user_id: string
      message: string
      created_at: Date
    }, ExtArgs["result"]["supportMessage"]>
    composites: {}
  }

  type SupportMessageGetPayload<S extends boolean | null | undefined | SupportMessageDefaultArgs> = $Result.GetResult<Prisma.$SupportMessagePayload, S>

  type SupportMessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SupportMessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SupportMessageCountAggregateInputType | true
    }

  export interface SupportMessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SupportMessage'], meta: { name: 'SupportMessage' } }
    /**
     * Find zero or one SupportMessage that matches the filter.
     * @param {SupportMessageFindUniqueArgs} args - Arguments to find a SupportMessage
     * @example
     * // Get one SupportMessage
     * const supportMessage = await prisma.supportMessage.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SupportMessageFindUniqueArgs>(args: SelectSubset<T, SupportMessageFindUniqueArgs<ExtArgs>>): Prisma__SupportMessageClient<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SupportMessage that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SupportMessageFindUniqueOrThrowArgs} args - Arguments to find a SupportMessage
     * @example
     * // Get one SupportMessage
     * const supportMessage = await prisma.supportMessage.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SupportMessageFindUniqueOrThrowArgs>(args: SelectSubset<T, SupportMessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SupportMessageClient<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupportMessage that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportMessageFindFirstArgs} args - Arguments to find a SupportMessage
     * @example
     * // Get one SupportMessage
     * const supportMessage = await prisma.supportMessage.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SupportMessageFindFirstArgs>(args?: SelectSubset<T, SupportMessageFindFirstArgs<ExtArgs>>): Prisma__SupportMessageClient<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SupportMessage that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportMessageFindFirstOrThrowArgs} args - Arguments to find a SupportMessage
     * @example
     * // Get one SupportMessage
     * const supportMessage = await prisma.supportMessage.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SupportMessageFindFirstOrThrowArgs>(args?: SelectSubset<T, SupportMessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__SupportMessageClient<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SupportMessages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportMessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SupportMessages
     * const supportMessages = await prisma.supportMessage.findMany()
     * 
     * // Get first 10 SupportMessages
     * const supportMessages = await prisma.supportMessage.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const supportMessageWithIdOnly = await prisma.supportMessage.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SupportMessageFindManyArgs>(args?: SelectSubset<T, SupportMessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SupportMessage.
     * @param {SupportMessageCreateArgs} args - Arguments to create a SupportMessage.
     * @example
     * // Create one SupportMessage
     * const SupportMessage = await prisma.supportMessage.create({
     *   data: {
     *     // ... data to create a SupportMessage
     *   }
     * })
     * 
     */
    create<T extends SupportMessageCreateArgs>(args: SelectSubset<T, SupportMessageCreateArgs<ExtArgs>>): Prisma__SupportMessageClient<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SupportMessages.
     * @param {SupportMessageCreateManyArgs} args - Arguments to create many SupportMessages.
     * @example
     * // Create many SupportMessages
     * const supportMessage = await prisma.supportMessage.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SupportMessageCreateManyArgs>(args?: SelectSubset<T, SupportMessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SupportMessages and returns the data saved in the database.
     * @param {SupportMessageCreateManyAndReturnArgs} args - Arguments to create many SupportMessages.
     * @example
     * // Create many SupportMessages
     * const supportMessage = await prisma.supportMessage.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SupportMessages and only return the `id`
     * const supportMessageWithIdOnly = await prisma.supportMessage.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SupportMessageCreateManyAndReturnArgs>(args?: SelectSubset<T, SupportMessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SupportMessage.
     * @param {SupportMessageDeleteArgs} args - Arguments to delete one SupportMessage.
     * @example
     * // Delete one SupportMessage
     * const SupportMessage = await prisma.supportMessage.delete({
     *   where: {
     *     // ... filter to delete one SupportMessage
     *   }
     * })
     * 
     */
    delete<T extends SupportMessageDeleteArgs>(args: SelectSubset<T, SupportMessageDeleteArgs<ExtArgs>>): Prisma__SupportMessageClient<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SupportMessage.
     * @param {SupportMessageUpdateArgs} args - Arguments to update one SupportMessage.
     * @example
     * // Update one SupportMessage
     * const supportMessage = await prisma.supportMessage.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SupportMessageUpdateArgs>(args: SelectSubset<T, SupportMessageUpdateArgs<ExtArgs>>): Prisma__SupportMessageClient<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SupportMessages.
     * @param {SupportMessageDeleteManyArgs} args - Arguments to filter SupportMessages to delete.
     * @example
     * // Delete a few SupportMessages
     * const { count } = await prisma.supportMessage.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SupportMessageDeleteManyArgs>(args?: SelectSubset<T, SupportMessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupportMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportMessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SupportMessages
     * const supportMessage = await prisma.supportMessage.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SupportMessageUpdateManyArgs>(args: SelectSubset<T, SupportMessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SupportMessages and returns the data updated in the database.
     * @param {SupportMessageUpdateManyAndReturnArgs} args - Arguments to update many SupportMessages.
     * @example
     * // Update many SupportMessages
     * const supportMessage = await prisma.supportMessage.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SupportMessages and only return the `id`
     * const supportMessageWithIdOnly = await prisma.supportMessage.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SupportMessageUpdateManyAndReturnArgs>(args: SelectSubset<T, SupportMessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SupportMessage.
     * @param {SupportMessageUpsertArgs} args - Arguments to update or create a SupportMessage.
     * @example
     * // Update or create a SupportMessage
     * const supportMessage = await prisma.supportMessage.upsert({
     *   create: {
     *     // ... data to create a SupportMessage
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SupportMessage we want to update
     *   }
     * })
     */
    upsert<T extends SupportMessageUpsertArgs>(args: SelectSubset<T, SupportMessageUpsertArgs<ExtArgs>>): Prisma__SupportMessageClient<$Result.GetResult<Prisma.$SupportMessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SupportMessages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportMessageCountArgs} args - Arguments to filter SupportMessages to count.
     * @example
     * // Count the number of SupportMessages
     * const count = await prisma.supportMessage.count({
     *   where: {
     *     // ... the filter for the SupportMessages we want to count
     *   }
     * })
    **/
    count<T extends SupportMessageCountArgs>(
      args?: Subset<T, SupportMessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SupportMessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SupportMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportMessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SupportMessageAggregateArgs>(args: Subset<T, SupportMessageAggregateArgs>): Prisma.PrismaPromise<GetSupportMessageAggregateType<T>>

    /**
     * Group by SupportMessage.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SupportMessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SupportMessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SupportMessageGroupByArgs['orderBy'] }
        : { orderBy?: SupportMessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SupportMessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSupportMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SupportMessage model
   */
  readonly fields: SupportMessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SupportMessage.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SupportMessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    request<T extends SupportRequestDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SupportRequestDefaultArgs<ExtArgs>>): Prisma__SupportRequestClient<$Result.GetResult<Prisma.$SupportRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SupportMessage model
   */
  interface SupportMessageFieldRefs {
    readonly id: FieldRef<"SupportMessage", 'String'>
    readonly support_request_id: FieldRef<"SupportMessage", 'String'>
    readonly user_id: FieldRef<"SupportMessage", 'String'>
    readonly message: FieldRef<"SupportMessage", 'String'>
    readonly created_at: FieldRef<"SupportMessage", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SupportMessage findUnique
   */
  export type SupportMessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportMessage
     */
    omit?: SupportMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
    /**
     * Filter, which SupportMessage to fetch.
     */
    where: SupportMessageWhereUniqueInput
  }

  /**
   * SupportMessage findUniqueOrThrow
   */
  export type SupportMessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportMessage
     */
    omit?: SupportMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
    /**
     * Filter, which SupportMessage to fetch.
     */
    where: SupportMessageWhereUniqueInput
  }

  /**
   * SupportMessage findFirst
   */
  export type SupportMessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportMessage
     */
    omit?: SupportMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
    /**
     * Filter, which SupportMessage to fetch.
     */
    where?: SupportMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportMessages to fetch.
     */
    orderBy?: SupportMessageOrderByWithRelationInput | SupportMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportMessages.
     */
    cursor?: SupportMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportMessages.
     */
    distinct?: SupportMessageScalarFieldEnum | SupportMessageScalarFieldEnum[]
  }

  /**
   * SupportMessage findFirstOrThrow
   */
  export type SupportMessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportMessage
     */
    omit?: SupportMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
    /**
     * Filter, which SupportMessage to fetch.
     */
    where?: SupportMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportMessages to fetch.
     */
    orderBy?: SupportMessageOrderByWithRelationInput | SupportMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SupportMessages.
     */
    cursor?: SupportMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportMessages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SupportMessages.
     */
    distinct?: SupportMessageScalarFieldEnum | SupportMessageScalarFieldEnum[]
  }

  /**
   * SupportMessage findMany
   */
  export type SupportMessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportMessage
     */
    omit?: SupportMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
    /**
     * Filter, which SupportMessages to fetch.
     */
    where?: SupportMessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SupportMessages to fetch.
     */
    orderBy?: SupportMessageOrderByWithRelationInput | SupportMessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SupportMessages.
     */
    cursor?: SupportMessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SupportMessages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SupportMessages.
     */
    skip?: number
    distinct?: SupportMessageScalarFieldEnum | SupportMessageScalarFieldEnum[]
  }

  /**
   * SupportMessage create
   */
  export type SupportMessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportMessage
     */
    omit?: SupportMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
    /**
     * The data needed to create a SupportMessage.
     */
    data: XOR<SupportMessageCreateInput, SupportMessageUncheckedCreateInput>
  }

  /**
   * SupportMessage createMany
   */
  export type SupportMessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SupportMessages.
     */
    data: SupportMessageCreateManyInput | SupportMessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SupportMessage createManyAndReturn
   */
  export type SupportMessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupportMessage
     */
    omit?: SupportMessageOmit<ExtArgs> | null
    /**
     * The data used to create many SupportMessages.
     */
    data: SupportMessageCreateManyInput | SupportMessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupportMessage update
   */
  export type SupportMessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportMessage
     */
    omit?: SupportMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
    /**
     * The data needed to update a SupportMessage.
     */
    data: XOR<SupportMessageUpdateInput, SupportMessageUncheckedUpdateInput>
    /**
     * Choose, which SupportMessage to update.
     */
    where: SupportMessageWhereUniqueInput
  }

  /**
   * SupportMessage updateMany
   */
  export type SupportMessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SupportMessages.
     */
    data: XOR<SupportMessageUpdateManyMutationInput, SupportMessageUncheckedUpdateManyInput>
    /**
     * Filter which SupportMessages to update
     */
    where?: SupportMessageWhereInput
    /**
     * Limit how many SupportMessages to update.
     */
    limit?: number
  }

  /**
   * SupportMessage updateManyAndReturn
   */
  export type SupportMessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SupportMessage
     */
    omit?: SupportMessageOmit<ExtArgs> | null
    /**
     * The data used to update SupportMessages.
     */
    data: XOR<SupportMessageUpdateManyMutationInput, SupportMessageUncheckedUpdateManyInput>
    /**
     * Filter which SupportMessages to update
     */
    where?: SupportMessageWhereInput
    /**
     * Limit how many SupportMessages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SupportMessage upsert
   */
  export type SupportMessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportMessage
     */
    omit?: SupportMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
    /**
     * The filter to search for the SupportMessage to update in case it exists.
     */
    where: SupportMessageWhereUniqueInput
    /**
     * In case the SupportMessage found by the `where` argument doesn't exist, create a new SupportMessage with this data.
     */
    create: XOR<SupportMessageCreateInput, SupportMessageUncheckedCreateInput>
    /**
     * In case the SupportMessage was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SupportMessageUpdateInput, SupportMessageUncheckedUpdateInput>
  }

  /**
   * SupportMessage delete
   */
  export type SupportMessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportMessage
     */
    omit?: SupportMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
    /**
     * Filter which SupportMessage to delete.
     */
    where: SupportMessageWhereUniqueInput
  }

  /**
   * SupportMessage deleteMany
   */
  export type SupportMessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SupportMessages to delete
     */
    where?: SupportMessageWhereInput
    /**
     * Limit how many SupportMessages to delete.
     */
    limit?: number
  }

  /**
   * SupportMessage without action
   */
  export type SupportMessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SupportMessage
     */
    select?: SupportMessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SupportMessage
     */
    omit?: SupportMessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SupportMessageInclude<ExtArgs> | null
  }


  /**
   * Model MeetingRequest
   */

  export type AggregateMeetingRequest = {
    _count: MeetingRequestCountAggregateOutputType | null
    _avg: MeetingRequestAvgAggregateOutputType | null
    _sum: MeetingRequestSumAggregateOutputType | null
    _min: MeetingRequestMinAggregateOutputType | null
    _max: MeetingRequestMaxAggregateOutputType | null
  }

  export type MeetingRequestAvgAggregateOutputType = {
    duration_minutes: number | null
  }

  export type MeetingRequestSumAggregateOutputType = {
    duration_minutes: number | null
  }

  export type MeetingRequestMinAggregateOutputType = {
    id: string | null
    project_id: string | null
    client_id: string | null
    requested_date: Date | null
    duration_minutes: number | null
    purpose: string | null
    status: $Enums.MeetingStatus | null
    meeting_link: string | null
    admin_notes: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MeetingRequestMaxAggregateOutputType = {
    id: string | null
    project_id: string | null
    client_id: string | null
    requested_date: Date | null
    duration_minutes: number | null
    purpose: string | null
    status: $Enums.MeetingStatus | null
    meeting_link: string | null
    admin_notes: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type MeetingRequestCountAggregateOutputType = {
    id: number
    project_id: number
    client_id: number
    requested_date: number
    duration_minutes: number
    purpose: number
    status: number
    meeting_link: number
    admin_notes: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type MeetingRequestAvgAggregateInputType = {
    duration_minutes?: true
  }

  export type MeetingRequestSumAggregateInputType = {
    duration_minutes?: true
  }

  export type MeetingRequestMinAggregateInputType = {
    id?: true
    project_id?: true
    client_id?: true
    requested_date?: true
    duration_minutes?: true
    purpose?: true
    status?: true
    meeting_link?: true
    admin_notes?: true
    created_at?: true
    updated_at?: true
  }

  export type MeetingRequestMaxAggregateInputType = {
    id?: true
    project_id?: true
    client_id?: true
    requested_date?: true
    duration_minutes?: true
    purpose?: true
    status?: true
    meeting_link?: true
    admin_notes?: true
    created_at?: true
    updated_at?: true
  }

  export type MeetingRequestCountAggregateInputType = {
    id?: true
    project_id?: true
    client_id?: true
    requested_date?: true
    duration_minutes?: true
    purpose?: true
    status?: true
    meeting_link?: true
    admin_notes?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type MeetingRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MeetingRequest to aggregate.
     */
    where?: MeetingRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeetingRequests to fetch.
     */
    orderBy?: MeetingRequestOrderByWithRelationInput | MeetingRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MeetingRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeetingRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeetingRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned MeetingRequests
    **/
    _count?: true | MeetingRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: MeetingRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: MeetingRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MeetingRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MeetingRequestMaxAggregateInputType
  }

  export type GetMeetingRequestAggregateType<T extends MeetingRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateMeetingRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMeetingRequest[P]>
      : GetScalarType<T[P], AggregateMeetingRequest[P]>
  }




  export type MeetingRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MeetingRequestWhereInput
    orderBy?: MeetingRequestOrderByWithAggregationInput | MeetingRequestOrderByWithAggregationInput[]
    by: MeetingRequestScalarFieldEnum[] | MeetingRequestScalarFieldEnum
    having?: MeetingRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MeetingRequestCountAggregateInputType | true
    _avg?: MeetingRequestAvgAggregateInputType
    _sum?: MeetingRequestSumAggregateInputType
    _min?: MeetingRequestMinAggregateInputType
    _max?: MeetingRequestMaxAggregateInputType
  }

  export type MeetingRequestGroupByOutputType = {
    id: string
    project_id: string | null
    client_id: string
    requested_date: Date
    duration_minutes: number
    purpose: string
    status: $Enums.MeetingStatus
    meeting_link: string | null
    admin_notes: string | null
    created_at: Date
    updated_at: Date
    _count: MeetingRequestCountAggregateOutputType | null
    _avg: MeetingRequestAvgAggregateOutputType | null
    _sum: MeetingRequestSumAggregateOutputType | null
    _min: MeetingRequestMinAggregateOutputType | null
    _max: MeetingRequestMaxAggregateOutputType | null
  }

  type GetMeetingRequestGroupByPayload<T extends MeetingRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MeetingRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MeetingRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MeetingRequestGroupByOutputType[P]>
            : GetScalarType<T[P], MeetingRequestGroupByOutputType[P]>
        }
      >
    >


  export type MeetingRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    project_id?: boolean
    client_id?: boolean
    requested_date?: boolean
    duration_minutes?: boolean
    purpose?: boolean
    status?: boolean
    meeting_link?: boolean
    admin_notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | MeetingRequest$projectArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meetingRequest"]>

  export type MeetingRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    project_id?: boolean
    client_id?: boolean
    requested_date?: boolean
    duration_minutes?: boolean
    purpose?: boolean
    status?: boolean
    meeting_link?: boolean
    admin_notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | MeetingRequest$projectArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meetingRequest"]>

  export type MeetingRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    project_id?: boolean
    client_id?: boolean
    requested_date?: boolean
    duration_minutes?: boolean
    purpose?: boolean
    status?: boolean
    meeting_link?: boolean
    admin_notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | MeetingRequest$projectArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["meetingRequest"]>

  export type MeetingRequestSelectScalar = {
    id?: boolean
    project_id?: boolean
    client_id?: boolean
    requested_date?: boolean
    duration_minutes?: boolean
    purpose?: boolean
    status?: boolean
    meeting_link?: boolean
    admin_notes?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type MeetingRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "project_id" | "client_id" | "requested_date" | "duration_minutes" | "purpose" | "status" | "meeting_link" | "admin_notes" | "created_at" | "updated_at", ExtArgs["result"]["meetingRequest"]>
  export type MeetingRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | MeetingRequest$projectArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MeetingRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | MeetingRequest$projectArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MeetingRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | MeetingRequest$projectArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MeetingRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "MeetingRequest"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs> | null
      client: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      project_id: string | null
      client_id: string
      requested_date: Date
      duration_minutes: number
      purpose: string
      status: $Enums.MeetingStatus
      meeting_link: string | null
      admin_notes: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["meetingRequest"]>
    composites: {}
  }

  type MeetingRequestGetPayload<S extends boolean | null | undefined | MeetingRequestDefaultArgs> = $Result.GetResult<Prisma.$MeetingRequestPayload, S>

  type MeetingRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MeetingRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MeetingRequestCountAggregateInputType | true
    }

  export interface MeetingRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['MeetingRequest'], meta: { name: 'MeetingRequest' } }
    /**
     * Find zero or one MeetingRequest that matches the filter.
     * @param {MeetingRequestFindUniqueArgs} args - Arguments to find a MeetingRequest
     * @example
     * // Get one MeetingRequest
     * const meetingRequest = await prisma.meetingRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MeetingRequestFindUniqueArgs>(args: SelectSubset<T, MeetingRequestFindUniqueArgs<ExtArgs>>): Prisma__MeetingRequestClient<$Result.GetResult<Prisma.$MeetingRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one MeetingRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MeetingRequestFindUniqueOrThrowArgs} args - Arguments to find a MeetingRequest
     * @example
     * // Get one MeetingRequest
     * const meetingRequest = await prisma.meetingRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MeetingRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, MeetingRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MeetingRequestClient<$Result.GetResult<Prisma.$MeetingRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MeetingRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingRequestFindFirstArgs} args - Arguments to find a MeetingRequest
     * @example
     * // Get one MeetingRequest
     * const meetingRequest = await prisma.meetingRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MeetingRequestFindFirstArgs>(args?: SelectSubset<T, MeetingRequestFindFirstArgs<ExtArgs>>): Prisma__MeetingRequestClient<$Result.GetResult<Prisma.$MeetingRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first MeetingRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingRequestFindFirstOrThrowArgs} args - Arguments to find a MeetingRequest
     * @example
     * // Get one MeetingRequest
     * const meetingRequest = await prisma.meetingRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MeetingRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, MeetingRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__MeetingRequestClient<$Result.GetResult<Prisma.$MeetingRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more MeetingRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all MeetingRequests
     * const meetingRequests = await prisma.meetingRequest.findMany()
     * 
     * // Get first 10 MeetingRequests
     * const meetingRequests = await prisma.meetingRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const meetingRequestWithIdOnly = await prisma.meetingRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MeetingRequestFindManyArgs>(args?: SelectSubset<T, MeetingRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a MeetingRequest.
     * @param {MeetingRequestCreateArgs} args - Arguments to create a MeetingRequest.
     * @example
     * // Create one MeetingRequest
     * const MeetingRequest = await prisma.meetingRequest.create({
     *   data: {
     *     // ... data to create a MeetingRequest
     *   }
     * })
     * 
     */
    create<T extends MeetingRequestCreateArgs>(args: SelectSubset<T, MeetingRequestCreateArgs<ExtArgs>>): Prisma__MeetingRequestClient<$Result.GetResult<Prisma.$MeetingRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many MeetingRequests.
     * @param {MeetingRequestCreateManyArgs} args - Arguments to create many MeetingRequests.
     * @example
     * // Create many MeetingRequests
     * const meetingRequest = await prisma.meetingRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MeetingRequestCreateManyArgs>(args?: SelectSubset<T, MeetingRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many MeetingRequests and returns the data saved in the database.
     * @param {MeetingRequestCreateManyAndReturnArgs} args - Arguments to create many MeetingRequests.
     * @example
     * // Create many MeetingRequests
     * const meetingRequest = await prisma.meetingRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many MeetingRequests and only return the `id`
     * const meetingRequestWithIdOnly = await prisma.meetingRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MeetingRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, MeetingRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a MeetingRequest.
     * @param {MeetingRequestDeleteArgs} args - Arguments to delete one MeetingRequest.
     * @example
     * // Delete one MeetingRequest
     * const MeetingRequest = await prisma.meetingRequest.delete({
     *   where: {
     *     // ... filter to delete one MeetingRequest
     *   }
     * })
     * 
     */
    delete<T extends MeetingRequestDeleteArgs>(args: SelectSubset<T, MeetingRequestDeleteArgs<ExtArgs>>): Prisma__MeetingRequestClient<$Result.GetResult<Prisma.$MeetingRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one MeetingRequest.
     * @param {MeetingRequestUpdateArgs} args - Arguments to update one MeetingRequest.
     * @example
     * // Update one MeetingRequest
     * const meetingRequest = await prisma.meetingRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MeetingRequestUpdateArgs>(args: SelectSubset<T, MeetingRequestUpdateArgs<ExtArgs>>): Prisma__MeetingRequestClient<$Result.GetResult<Prisma.$MeetingRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more MeetingRequests.
     * @param {MeetingRequestDeleteManyArgs} args - Arguments to filter MeetingRequests to delete.
     * @example
     * // Delete a few MeetingRequests
     * const { count } = await prisma.meetingRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MeetingRequestDeleteManyArgs>(args?: SelectSubset<T, MeetingRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MeetingRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many MeetingRequests
     * const meetingRequest = await prisma.meetingRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MeetingRequestUpdateManyArgs>(args: SelectSubset<T, MeetingRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more MeetingRequests and returns the data updated in the database.
     * @param {MeetingRequestUpdateManyAndReturnArgs} args - Arguments to update many MeetingRequests.
     * @example
     * // Update many MeetingRequests
     * const meetingRequest = await prisma.meetingRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more MeetingRequests and only return the `id`
     * const meetingRequestWithIdOnly = await prisma.meetingRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MeetingRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, MeetingRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MeetingRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one MeetingRequest.
     * @param {MeetingRequestUpsertArgs} args - Arguments to update or create a MeetingRequest.
     * @example
     * // Update or create a MeetingRequest
     * const meetingRequest = await prisma.meetingRequest.upsert({
     *   create: {
     *     // ... data to create a MeetingRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the MeetingRequest we want to update
     *   }
     * })
     */
    upsert<T extends MeetingRequestUpsertArgs>(args: SelectSubset<T, MeetingRequestUpsertArgs<ExtArgs>>): Prisma__MeetingRequestClient<$Result.GetResult<Prisma.$MeetingRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of MeetingRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingRequestCountArgs} args - Arguments to filter MeetingRequests to count.
     * @example
     * // Count the number of MeetingRequests
     * const count = await prisma.meetingRequest.count({
     *   where: {
     *     // ... the filter for the MeetingRequests we want to count
     *   }
     * })
    **/
    count<T extends MeetingRequestCountArgs>(
      args?: Subset<T, MeetingRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MeetingRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a MeetingRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MeetingRequestAggregateArgs>(args: Subset<T, MeetingRequestAggregateArgs>): Prisma.PrismaPromise<GetMeetingRequestAggregateType<T>>

    /**
     * Group by MeetingRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MeetingRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MeetingRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MeetingRequestGroupByArgs['orderBy'] }
        : { orderBy?: MeetingRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MeetingRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMeetingRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the MeetingRequest model
   */
  readonly fields: MeetingRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for MeetingRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MeetingRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends MeetingRequest$projectArgs<ExtArgs> = {}>(args?: Subset<T, MeetingRequest$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    client<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the MeetingRequest model
   */
  interface MeetingRequestFieldRefs {
    readonly id: FieldRef<"MeetingRequest", 'String'>
    readonly project_id: FieldRef<"MeetingRequest", 'String'>
    readonly client_id: FieldRef<"MeetingRequest", 'String'>
    readonly requested_date: FieldRef<"MeetingRequest", 'DateTime'>
    readonly duration_minutes: FieldRef<"MeetingRequest", 'Int'>
    readonly purpose: FieldRef<"MeetingRequest", 'String'>
    readonly status: FieldRef<"MeetingRequest", 'MeetingStatus'>
    readonly meeting_link: FieldRef<"MeetingRequest", 'String'>
    readonly admin_notes: FieldRef<"MeetingRequest", 'String'>
    readonly created_at: FieldRef<"MeetingRequest", 'DateTime'>
    readonly updated_at: FieldRef<"MeetingRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * MeetingRequest findUnique
   */
  export type MeetingRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRequest
     */
    select?: MeetingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRequest
     */
    omit?: MeetingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRequestInclude<ExtArgs> | null
    /**
     * Filter, which MeetingRequest to fetch.
     */
    where: MeetingRequestWhereUniqueInput
  }

  /**
   * MeetingRequest findUniqueOrThrow
   */
  export type MeetingRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRequest
     */
    select?: MeetingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRequest
     */
    omit?: MeetingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRequestInclude<ExtArgs> | null
    /**
     * Filter, which MeetingRequest to fetch.
     */
    where: MeetingRequestWhereUniqueInput
  }

  /**
   * MeetingRequest findFirst
   */
  export type MeetingRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRequest
     */
    select?: MeetingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRequest
     */
    omit?: MeetingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRequestInclude<ExtArgs> | null
    /**
     * Filter, which MeetingRequest to fetch.
     */
    where?: MeetingRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeetingRequests to fetch.
     */
    orderBy?: MeetingRequestOrderByWithRelationInput | MeetingRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MeetingRequests.
     */
    cursor?: MeetingRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeetingRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeetingRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MeetingRequests.
     */
    distinct?: MeetingRequestScalarFieldEnum | MeetingRequestScalarFieldEnum[]
  }

  /**
   * MeetingRequest findFirstOrThrow
   */
  export type MeetingRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRequest
     */
    select?: MeetingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRequest
     */
    omit?: MeetingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRequestInclude<ExtArgs> | null
    /**
     * Filter, which MeetingRequest to fetch.
     */
    where?: MeetingRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeetingRequests to fetch.
     */
    orderBy?: MeetingRequestOrderByWithRelationInput | MeetingRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for MeetingRequests.
     */
    cursor?: MeetingRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeetingRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeetingRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of MeetingRequests.
     */
    distinct?: MeetingRequestScalarFieldEnum | MeetingRequestScalarFieldEnum[]
  }

  /**
   * MeetingRequest findMany
   */
  export type MeetingRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRequest
     */
    select?: MeetingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRequest
     */
    omit?: MeetingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRequestInclude<ExtArgs> | null
    /**
     * Filter, which MeetingRequests to fetch.
     */
    where?: MeetingRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of MeetingRequests to fetch.
     */
    orderBy?: MeetingRequestOrderByWithRelationInput | MeetingRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing MeetingRequests.
     */
    cursor?: MeetingRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` MeetingRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` MeetingRequests.
     */
    skip?: number
    distinct?: MeetingRequestScalarFieldEnum | MeetingRequestScalarFieldEnum[]
  }

  /**
   * MeetingRequest create
   */
  export type MeetingRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRequest
     */
    select?: MeetingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRequest
     */
    omit?: MeetingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a MeetingRequest.
     */
    data: XOR<MeetingRequestCreateInput, MeetingRequestUncheckedCreateInput>
  }

  /**
   * MeetingRequest createMany
   */
  export type MeetingRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many MeetingRequests.
     */
    data: MeetingRequestCreateManyInput | MeetingRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * MeetingRequest createManyAndReturn
   */
  export type MeetingRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRequest
     */
    select?: MeetingRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRequest
     */
    omit?: MeetingRequestOmit<ExtArgs> | null
    /**
     * The data used to create many MeetingRequests.
     */
    data: MeetingRequestCreateManyInput | MeetingRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * MeetingRequest update
   */
  export type MeetingRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRequest
     */
    select?: MeetingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRequest
     */
    omit?: MeetingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a MeetingRequest.
     */
    data: XOR<MeetingRequestUpdateInput, MeetingRequestUncheckedUpdateInput>
    /**
     * Choose, which MeetingRequest to update.
     */
    where: MeetingRequestWhereUniqueInput
  }

  /**
   * MeetingRequest updateMany
   */
  export type MeetingRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update MeetingRequests.
     */
    data: XOR<MeetingRequestUpdateManyMutationInput, MeetingRequestUncheckedUpdateManyInput>
    /**
     * Filter which MeetingRequests to update
     */
    where?: MeetingRequestWhereInput
    /**
     * Limit how many MeetingRequests to update.
     */
    limit?: number
  }

  /**
   * MeetingRequest updateManyAndReturn
   */
  export type MeetingRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRequest
     */
    select?: MeetingRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRequest
     */
    omit?: MeetingRequestOmit<ExtArgs> | null
    /**
     * The data used to update MeetingRequests.
     */
    data: XOR<MeetingRequestUpdateManyMutationInput, MeetingRequestUncheckedUpdateManyInput>
    /**
     * Filter which MeetingRequests to update
     */
    where?: MeetingRequestWhereInput
    /**
     * Limit how many MeetingRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * MeetingRequest upsert
   */
  export type MeetingRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRequest
     */
    select?: MeetingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRequest
     */
    omit?: MeetingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the MeetingRequest to update in case it exists.
     */
    where: MeetingRequestWhereUniqueInput
    /**
     * In case the MeetingRequest found by the `where` argument doesn't exist, create a new MeetingRequest with this data.
     */
    create: XOR<MeetingRequestCreateInput, MeetingRequestUncheckedCreateInput>
    /**
     * In case the MeetingRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MeetingRequestUpdateInput, MeetingRequestUncheckedUpdateInput>
  }

  /**
   * MeetingRequest delete
   */
  export type MeetingRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRequest
     */
    select?: MeetingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRequest
     */
    omit?: MeetingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRequestInclude<ExtArgs> | null
    /**
     * Filter which MeetingRequest to delete.
     */
    where: MeetingRequestWhereUniqueInput
  }

  /**
   * MeetingRequest deleteMany
   */
  export type MeetingRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which MeetingRequests to delete
     */
    where?: MeetingRequestWhereInput
    /**
     * Limit how many MeetingRequests to delete.
     */
    limit?: number
  }

  /**
   * MeetingRequest.project
   */
  export type MeetingRequest$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * MeetingRequest without action
   */
  export type MeetingRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the MeetingRequest
     */
    select?: MeetingRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the MeetingRequest
     */
    omit?: MeetingRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MeetingRequestInclude<ExtArgs> | null
  }


  /**
   * Model Invoice
   */

  export type AggregateInvoice = {
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  export type InvoiceAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type InvoiceSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type InvoiceMinAggregateOutputType = {
    id: string | null
    project_id: string | null
    client_id: string | null
    invoice_number: string | null
    amount: Decimal | null
    due_date: Date | null
    status: $Enums.InvoiceStatus | null
    payment_qr_url: string | null
    paid_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type InvoiceMaxAggregateOutputType = {
    id: string | null
    project_id: string | null
    client_id: string | null
    invoice_number: string | null
    amount: Decimal | null
    due_date: Date | null
    status: $Enums.InvoiceStatus | null
    payment_qr_url: string | null
    paid_at: Date | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type InvoiceCountAggregateOutputType = {
    id: number
    project_id: number
    client_id: number
    invoice_number: number
    amount: number
    due_date: number
    status: number
    payment_qr_url: number
    bank_details: number
    paid_at: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type InvoiceAvgAggregateInputType = {
    amount?: true
  }

  export type InvoiceSumAggregateInputType = {
    amount?: true
  }

  export type InvoiceMinAggregateInputType = {
    id?: true
    project_id?: true
    client_id?: true
    invoice_number?: true
    amount?: true
    due_date?: true
    status?: true
    payment_qr_url?: true
    paid_at?: true
    created_at?: true
    updated_at?: true
  }

  export type InvoiceMaxAggregateInputType = {
    id?: true
    project_id?: true
    client_id?: true
    invoice_number?: true
    amount?: true
    due_date?: true
    status?: true
    payment_qr_url?: true
    paid_at?: true
    created_at?: true
    updated_at?: true
  }

  export type InvoiceCountAggregateInputType = {
    id?: true
    project_id?: true
    client_id?: true
    invoice_number?: true
    amount?: true
    due_date?: true
    status?: true
    payment_qr_url?: true
    bank_details?: true
    paid_at?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type InvoiceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoice to aggregate.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Invoices
    **/
    _count?: true | InvoiceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InvoiceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InvoiceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InvoiceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InvoiceMaxAggregateInputType
  }

  export type GetInvoiceAggregateType<T extends InvoiceAggregateArgs> = {
        [P in keyof T & keyof AggregateInvoice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInvoice[P]>
      : GetScalarType<T[P], AggregateInvoice[P]>
  }




  export type InvoiceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InvoiceWhereInput
    orderBy?: InvoiceOrderByWithAggregationInput | InvoiceOrderByWithAggregationInput[]
    by: InvoiceScalarFieldEnum[] | InvoiceScalarFieldEnum
    having?: InvoiceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InvoiceCountAggregateInputType | true
    _avg?: InvoiceAvgAggregateInputType
    _sum?: InvoiceSumAggregateInputType
    _min?: InvoiceMinAggregateInputType
    _max?: InvoiceMaxAggregateInputType
  }

  export type InvoiceGroupByOutputType = {
    id: string
    project_id: string
    client_id: string
    invoice_number: string
    amount: Decimal
    due_date: Date
    status: $Enums.InvoiceStatus
    payment_qr_url: string | null
    bank_details: JsonValue | null
    paid_at: Date | null
    created_at: Date
    updated_at: Date
    _count: InvoiceCountAggregateOutputType | null
    _avg: InvoiceAvgAggregateOutputType | null
    _sum: InvoiceSumAggregateOutputType | null
    _min: InvoiceMinAggregateOutputType | null
    _max: InvoiceMaxAggregateOutputType | null
  }

  type GetInvoiceGroupByPayload<T extends InvoiceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InvoiceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InvoiceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
            : GetScalarType<T[P], InvoiceGroupByOutputType[P]>
        }
      >
    >


  export type InvoiceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    project_id?: boolean
    client_id?: boolean
    invoice_number?: boolean
    amount?: boolean
    due_date?: boolean
    status?: boolean
    payment_qr_url?: boolean
    bank_details?: boolean
    paid_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    project_id?: boolean
    client_id?: boolean
    invoice_number?: boolean
    amount?: boolean
    due_date?: boolean
    status?: boolean
    payment_qr_url?: boolean
    bank_details?: boolean
    paid_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    project_id?: boolean
    client_id?: boolean
    invoice_number?: boolean
    amount?: boolean
    due_date?: boolean
    status?: boolean
    payment_qr_url?: boolean
    bank_details?: boolean
    paid_at?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["invoice"]>

  export type InvoiceSelectScalar = {
    id?: boolean
    project_id?: boolean
    client_id?: boolean
    invoice_number?: boolean
    amount?: boolean
    due_date?: boolean
    status?: boolean
    payment_qr_url?: boolean
    bank_details?: boolean
    paid_at?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type InvoiceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "project_id" | "client_id" | "invoice_number" | "amount" | "due_date" | "status" | "payment_qr_url" | "bank_details" | "paid_at" | "created_at" | "updated_at", ExtArgs["result"]["invoice"]>
  export type InvoiceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
    payments?: boolean | Invoice$paymentsArgs<ExtArgs>
    _count?: boolean | InvoiceCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InvoiceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | ProjectDefaultArgs<ExtArgs>
    client?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InvoicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Invoice"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs>
      client: Prisma.$UserPayload<ExtArgs>
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      project_id: string
      client_id: string
      invoice_number: string
      amount: Prisma.Decimal
      due_date: Date
      status: $Enums.InvoiceStatus
      payment_qr_url: string | null
      bank_details: Prisma.JsonValue | null
      paid_at: Date | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["invoice"]>
    composites: {}
  }

  type InvoiceGetPayload<S extends boolean | null | undefined | InvoiceDefaultArgs> = $Result.GetResult<Prisma.$InvoicePayload, S>

  type InvoiceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InvoiceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InvoiceCountAggregateInputType | true
    }

  export interface InvoiceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Invoice'], meta: { name: 'Invoice' } }
    /**
     * Find zero or one Invoice that matches the filter.
     * @param {InvoiceFindUniqueArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InvoiceFindUniqueArgs>(args: SelectSubset<T, InvoiceFindUniqueArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Invoice that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InvoiceFindUniqueOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InvoiceFindUniqueOrThrowArgs>(args: SelectSubset<T, InvoiceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InvoiceFindFirstArgs>(args?: SelectSubset<T, InvoiceFindFirstArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Invoice that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindFirstOrThrowArgs} args - Arguments to find a Invoice
     * @example
     * // Get one Invoice
     * const invoice = await prisma.invoice.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InvoiceFindFirstOrThrowArgs>(args?: SelectSubset<T, InvoiceFindFirstOrThrowArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Invoices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Invoices
     * const invoices = await prisma.invoice.findMany()
     * 
     * // Get first 10 Invoices
     * const invoices = await prisma.invoice.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const invoiceWithIdOnly = await prisma.invoice.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InvoiceFindManyArgs>(args?: SelectSubset<T, InvoiceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Invoice.
     * @param {InvoiceCreateArgs} args - Arguments to create a Invoice.
     * @example
     * // Create one Invoice
     * const Invoice = await prisma.invoice.create({
     *   data: {
     *     // ... data to create a Invoice
     *   }
     * })
     * 
     */
    create<T extends InvoiceCreateArgs>(args: SelectSubset<T, InvoiceCreateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Invoices.
     * @param {InvoiceCreateManyArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InvoiceCreateManyArgs>(args?: SelectSubset<T, InvoiceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Invoices and returns the data saved in the database.
     * @param {InvoiceCreateManyAndReturnArgs} args - Arguments to create many Invoices.
     * @example
     * // Create many Invoices
     * const invoice = await prisma.invoice.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InvoiceCreateManyAndReturnArgs>(args?: SelectSubset<T, InvoiceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Invoice.
     * @param {InvoiceDeleteArgs} args - Arguments to delete one Invoice.
     * @example
     * // Delete one Invoice
     * const Invoice = await prisma.invoice.delete({
     *   where: {
     *     // ... filter to delete one Invoice
     *   }
     * })
     * 
     */
    delete<T extends InvoiceDeleteArgs>(args: SelectSubset<T, InvoiceDeleteArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Invoice.
     * @param {InvoiceUpdateArgs} args - Arguments to update one Invoice.
     * @example
     * // Update one Invoice
     * const invoice = await prisma.invoice.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InvoiceUpdateArgs>(args: SelectSubset<T, InvoiceUpdateArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Invoices.
     * @param {InvoiceDeleteManyArgs} args - Arguments to filter Invoices to delete.
     * @example
     * // Delete a few Invoices
     * const { count } = await prisma.invoice.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InvoiceDeleteManyArgs>(args?: SelectSubset<T, InvoiceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InvoiceUpdateManyArgs>(args: SelectSubset<T, InvoiceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Invoices and returns the data updated in the database.
     * @param {InvoiceUpdateManyAndReturnArgs} args - Arguments to update many Invoices.
     * @example
     * // Update many Invoices
     * const invoice = await prisma.invoice.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Invoices and only return the `id`
     * const invoiceWithIdOnly = await prisma.invoice.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InvoiceUpdateManyAndReturnArgs>(args: SelectSubset<T, InvoiceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Invoice.
     * @param {InvoiceUpsertArgs} args - Arguments to update or create a Invoice.
     * @example
     * // Update or create a Invoice
     * const invoice = await prisma.invoice.upsert({
     *   create: {
     *     // ... data to create a Invoice
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Invoice we want to update
     *   }
     * })
     */
    upsert<T extends InvoiceUpsertArgs>(args: SelectSubset<T, InvoiceUpsertArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Invoices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceCountArgs} args - Arguments to filter Invoices to count.
     * @example
     * // Count the number of Invoices
     * const count = await prisma.invoice.count({
     *   where: {
     *     // ... the filter for the Invoices we want to count
     *   }
     * })
    **/
    count<T extends InvoiceCountArgs>(
      args?: Subset<T, InvoiceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InvoiceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InvoiceAggregateArgs>(args: Subset<T, InvoiceAggregateArgs>): Prisma.PrismaPromise<GetInvoiceAggregateType<T>>

    /**
     * Group by Invoice.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InvoiceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InvoiceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InvoiceGroupByArgs['orderBy'] }
        : { orderBy?: InvoiceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InvoiceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInvoiceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Invoice model
   */
  readonly fields: InvoiceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Invoice.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InvoiceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    client<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    payments<T extends Invoice$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Invoice$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Invoice model
   */
  interface InvoiceFieldRefs {
    readonly id: FieldRef<"Invoice", 'String'>
    readonly project_id: FieldRef<"Invoice", 'String'>
    readonly client_id: FieldRef<"Invoice", 'String'>
    readonly invoice_number: FieldRef<"Invoice", 'String'>
    readonly amount: FieldRef<"Invoice", 'Decimal'>
    readonly due_date: FieldRef<"Invoice", 'DateTime'>
    readonly status: FieldRef<"Invoice", 'InvoiceStatus'>
    readonly payment_qr_url: FieldRef<"Invoice", 'String'>
    readonly bank_details: FieldRef<"Invoice", 'Json'>
    readonly paid_at: FieldRef<"Invoice", 'DateTime'>
    readonly created_at: FieldRef<"Invoice", 'DateTime'>
    readonly updated_at: FieldRef<"Invoice", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Invoice findUnique
   */
  export type InvoiceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findUniqueOrThrow
   */
  export type InvoiceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice findFirst
   */
  export type InvoiceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findFirstOrThrow
   */
  export type InvoiceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoice to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Invoices.
     */
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice findMany
   */
  export type InvoiceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter, which Invoices to fetch.
     */
    where?: InvoiceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Invoices to fetch.
     */
    orderBy?: InvoiceOrderByWithRelationInput | InvoiceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Invoices.
     */
    cursor?: InvoiceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Invoices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Invoices.
     */
    skip?: number
    distinct?: InvoiceScalarFieldEnum | InvoiceScalarFieldEnum[]
  }

  /**
   * Invoice create
   */
  export type InvoiceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to create a Invoice.
     */
    data: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
  }

  /**
   * Invoice createMany
   */
  export type InvoiceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Invoice createManyAndReturn
   */
  export type InvoiceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to create many Invoices.
     */
    data: InvoiceCreateManyInput | InvoiceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice update
   */
  export type InvoiceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The data needed to update a Invoice.
     */
    data: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
    /**
     * Choose, which Invoice to update.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice updateMany
   */
  export type InvoiceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
  }

  /**
   * Invoice updateManyAndReturn
   */
  export type InvoiceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * The data used to update Invoices.
     */
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyInput>
    /**
     * Filter which Invoices to update
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Invoice upsert
   */
  export type InvoiceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * The filter to search for the Invoice to update in case it exists.
     */
    where: InvoiceWhereUniqueInput
    /**
     * In case the Invoice found by the `where` argument doesn't exist, create a new Invoice with this data.
     */
    create: XOR<InvoiceCreateInput, InvoiceUncheckedCreateInput>
    /**
     * In case the Invoice was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InvoiceUpdateInput, InvoiceUncheckedUpdateInput>
  }

  /**
   * Invoice delete
   */
  export type InvoiceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
    /**
     * Filter which Invoice to delete.
     */
    where: InvoiceWhereUniqueInput
  }

  /**
   * Invoice deleteMany
   */
  export type InvoiceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Invoices to delete
     */
    where?: InvoiceWhereInput
    /**
     * Limit how many Invoices to delete.
     */
    limit?: number
  }

  /**
   * Invoice.payments
   */
  export type Invoice$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Invoice without action
   */
  export type InvoiceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Invoice
     */
    select?: InvoiceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Invoice
     */
    omit?: InvoiceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InvoiceInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    invoice_id: string | null
    amount: Decimal | null
    payment_method: string | null
    transaction_id: string | null
    payment_date: Date | null
    notes: string | null
    created_at: Date | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    invoice_id: string | null
    amount: Decimal | null
    payment_method: string | null
    transaction_id: string | null
    payment_date: Date | null
    notes: string | null
    created_at: Date | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    invoice_id: number
    amount: number
    payment_method: number
    transaction_id: number
    payment_date: number
    notes: number
    created_at: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    invoice_id?: true
    amount?: true
    payment_method?: true
    transaction_id?: true
    payment_date?: true
    notes?: true
    created_at?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    invoice_id?: true
    amount?: true
    payment_method?: true
    transaction_id?: true
    payment_date?: true
    notes?: true
    created_at?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    invoice_id?: true
    amount?: true
    payment_method?: true
    transaction_id?: true
    payment_date?: true
    notes?: true
    created_at?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    invoice_id: string
    amount: Decimal
    payment_method: string
    transaction_id: string | null
    payment_date: Date
    notes: string | null
    created_at: Date
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_id?: boolean
    amount?: boolean
    payment_method?: boolean
    transaction_id?: boolean
    payment_date?: boolean
    notes?: boolean
    created_at?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_id?: boolean
    amount?: boolean
    payment_method?: boolean
    transaction_id?: boolean
    payment_date?: boolean
    notes?: boolean
    created_at?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    invoice_id?: boolean
    amount?: boolean
    payment_method?: boolean
    transaction_id?: boolean
    payment_date?: boolean
    notes?: boolean
    created_at?: boolean
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    invoice_id?: boolean
    amount?: boolean
    payment_method?: boolean
    transaction_id?: boolean
    payment_date?: boolean
    notes?: boolean
    created_at?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "invoice_id" | "amount" | "payment_method" | "transaction_id" | "payment_date" | "notes" | "created_at", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    invoice?: boolean | InvoiceDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      invoice: Prisma.$InvoicePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      invoice_id: string
      amount: Prisma.Decimal
      payment_method: string
      transaction_id: string | null
      payment_date: Date
      notes: string | null
      created_at: Date
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    invoice<T extends InvoiceDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InvoiceDefaultArgs<ExtArgs>>): Prisma__InvoiceClient<$Result.GetResult<Prisma.$InvoicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly invoice_id: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly payment_method: FieldRef<"Payment", 'String'>
    readonly transaction_id: FieldRef<"Payment", 'String'>
    readonly payment_date: FieldRef<"Payment", 'DateTime'>
    readonly notes: FieldRef<"Payment", 'String'>
    readonly created_at: FieldRef<"Payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeAvgAggregateOutputType = {
    basic_salary: Decimal | null
    overtime_rate: Decimal | null
  }

  export type EmployeeSumAggregateOutputType = {
    basic_salary: Decimal | null
    overtime_rate: Decimal | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: string | null
    employee_id: string | null
    name: string | null
    role: string | null
    skill_type: string | null
    employment_type: string | null
    department: string | null
    joining_date: Date | null
    basic_salary: Decimal | null
    overtime_rate: Decimal | null
    status: $Enums.MemberStatus | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: string | null
    employee_id: string | null
    name: string | null
    role: string | null
    skill_type: string | null
    employment_type: string | null
    department: string | null
    joining_date: Date | null
    basic_salary: Decimal | null
    overtime_rate: Decimal | null
    status: $Enums.MemberStatus | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    employee_id: number
    name: number
    role: number
    skill_type: number
    employment_type: number
    department: number
    joining_date: number
    basic_salary: number
    overtime_rate: number
    bank_details: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type EmployeeAvgAggregateInputType = {
    basic_salary?: true
    overtime_rate?: true
  }

  export type EmployeeSumAggregateInputType = {
    basic_salary?: true
    overtime_rate?: true
  }

  export type EmployeeMinAggregateInputType = {
    id?: true
    employee_id?: true
    name?: true
    role?: true
    skill_type?: true
    employment_type?: true
    department?: true
    joining_date?: true
    basic_salary?: true
    overtime_rate?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    employee_id?: true
    name?: true
    role?: true
    skill_type?: true
    employment_type?: true
    department?: true
    joining_date?: true
    basic_salary?: true
    overtime_rate?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    employee_id?: true
    name?: true
    role?: true
    skill_type?: true
    employment_type?: true
    department?: true
    joining_date?: true
    basic_salary?: true
    overtime_rate?: true
    bank_details?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _avg?: EmployeeAvgAggregateInputType
    _sum?: EmployeeSumAggregateInputType
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: string
    employee_id: string
    name: string
    role: string
    skill_type: string
    employment_type: string
    department: string | null
    joining_date: Date
    basic_salary: Decimal
    overtime_rate: Decimal
    bank_details: JsonValue | null
    status: $Enums.MemberStatus
    created_at: Date
    updated_at: Date
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employee_id?: boolean
    name?: boolean
    role?: boolean
    skill_type?: boolean
    employment_type?: boolean
    department?: boolean
    joining_date?: boolean
    basic_salary?: boolean
    overtime_rate?: boolean
    bank_details?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    attendance?: boolean | Employee$attendanceArgs<ExtArgs>
    allocations?: boolean | Employee$allocationsArgs<ExtArgs>
    payroll_items?: boolean | Employee$payroll_itemsArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employee_id?: boolean
    name?: boolean
    role?: boolean
    skill_type?: boolean
    employment_type?: boolean
    department?: boolean
    joining_date?: boolean
    basic_salary?: boolean
    overtime_rate?: boolean
    bank_details?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employee_id?: boolean
    name?: boolean
    role?: boolean
    skill_type?: boolean
    employment_type?: boolean
    department?: boolean
    joining_date?: boolean
    basic_salary?: boolean
    overtime_rate?: boolean
    bank_details?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectScalar = {
    id?: boolean
    employee_id?: boolean
    name?: boolean
    role?: boolean
    skill_type?: boolean
    employment_type?: boolean
    department?: boolean
    joining_date?: boolean
    basic_salary?: boolean
    overtime_rate?: boolean
    bank_details?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type EmployeeOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employee_id" | "name" | "role" | "skill_type" | "employment_type" | "department" | "joining_date" | "basic_salary" | "overtime_rate" | "bank_details" | "status" | "created_at" | "updated_at", ExtArgs["result"]["employee"]>
  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    attendance?: boolean | Employee$attendanceArgs<ExtArgs>
    allocations?: boolean | Employee$allocationsArgs<ExtArgs>
    payroll_items?: boolean | Employee$payroll_itemsArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type EmployeeIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      attendance: Prisma.$AttendancePayload<ExtArgs>[]
      allocations: Prisma.$LabourAllocationPayload<ExtArgs>[]
      payroll_items: Prisma.$PayrollLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employee_id: string
      name: string
      role: string
      skill_type: string
      employment_type: string
      department: string | null
      joining_date: Date
      basic_salary: Prisma.Decimal
      overtime_rate: Prisma.Decimal
      bank_details: Prisma.JsonValue | null
      status: $Enums.MemberStatus
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees and returns the data updated in the database.
     * @param {EmployeeUpdateManyAndReturnArgs} args - Arguments to update many Employees.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmployeeUpdateManyAndReturnArgs>(args: SelectSubset<T, EmployeeUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    attendance<T extends Employee$attendanceArgs<ExtArgs> = {}>(args?: Subset<T, Employee$attendanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    allocations<T extends Employee$allocationsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$allocationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabourAllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payroll_items<T extends Employee$payroll_itemsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$payroll_itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */
  interface EmployeeFieldRefs {
    readonly id: FieldRef<"Employee", 'String'>
    readonly employee_id: FieldRef<"Employee", 'String'>
    readonly name: FieldRef<"Employee", 'String'>
    readonly role: FieldRef<"Employee", 'String'>
    readonly skill_type: FieldRef<"Employee", 'String'>
    readonly employment_type: FieldRef<"Employee", 'String'>
    readonly department: FieldRef<"Employee", 'String'>
    readonly joining_date: FieldRef<"Employee", 'DateTime'>
    readonly basic_salary: FieldRef<"Employee", 'Decimal'>
    readonly overtime_rate: FieldRef<"Employee", 'Decimal'>
    readonly bank_details: FieldRef<"Employee", 'Json'>
    readonly status: FieldRef<"Employee", 'MemberStatus'>
    readonly created_at: FieldRef<"Employee", 'DateTime'>
    readonly updated_at: FieldRef<"Employee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee createManyAndReturn
   */
  export type EmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee updateManyAndReturn
   */
  export type EmployeeUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to update.
     */
    limit?: number
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
    /**
     * Limit how many Employees to delete.
     */
    limit?: number
  }

  /**
   * Employee.attendance
   */
  export type Employee$attendanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Employee.allocations
   */
  export type Employee$allocationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourAllocation
     */
    select?: LabourAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourAllocation
     */
    omit?: LabourAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourAllocationInclude<ExtArgs> | null
    where?: LabourAllocationWhereInput
    orderBy?: LabourAllocationOrderByWithRelationInput | LabourAllocationOrderByWithRelationInput[]
    cursor?: LabourAllocationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LabourAllocationScalarFieldEnum | LabourAllocationScalarFieldEnum[]
  }

  /**
   * Employee.payroll_items
   */
  export type Employee$payroll_itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollLine
     */
    select?: PayrollLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollLine
     */
    omit?: PayrollLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollLineInclude<ExtArgs> | null
    where?: PayrollLineWhereInput
    orderBy?: PayrollLineOrderByWithRelationInput | PayrollLineOrderByWithRelationInput[]
    cursor?: PayrollLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayrollLineScalarFieldEnum | PayrollLineScalarFieldEnum[]
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Employee
     */
    omit?: EmployeeOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model Attendance
   */

  export type AggregateAttendance = {
    _count: AttendanceCountAggregateOutputType | null
    _avg: AttendanceAvgAggregateOutputType | null
    _sum: AttendanceSumAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  export type AttendanceAvgAggregateOutputType = {
    overtime_hours: number | null
  }

  export type AttendanceSumAggregateOutputType = {
    overtime_hours: number | null
  }

  export type AttendanceMinAggregateOutputType = {
    id: string | null
    employee_id: string | null
    date: Date | null
    status: string | null
    overtime_hours: number | null
    project_id: string | null
    check_in: Date | null
    check_out: Date | null
    created_at: Date | null
  }

  export type AttendanceMaxAggregateOutputType = {
    id: string | null
    employee_id: string | null
    date: Date | null
    status: string | null
    overtime_hours: number | null
    project_id: string | null
    check_in: Date | null
    check_out: Date | null
    created_at: Date | null
  }

  export type AttendanceCountAggregateOutputType = {
    id: number
    employee_id: number
    date: number
    status: number
    overtime_hours: number
    project_id: number
    check_in: number
    check_out: number
    created_at: number
    _all: number
  }


  export type AttendanceAvgAggregateInputType = {
    overtime_hours?: true
  }

  export type AttendanceSumAggregateInputType = {
    overtime_hours?: true
  }

  export type AttendanceMinAggregateInputType = {
    id?: true
    employee_id?: true
    date?: true
    status?: true
    overtime_hours?: true
    project_id?: true
    check_in?: true
    check_out?: true
    created_at?: true
  }

  export type AttendanceMaxAggregateInputType = {
    id?: true
    employee_id?: true
    date?: true
    status?: true
    overtime_hours?: true
    project_id?: true
    check_in?: true
    check_out?: true
    created_at?: true
  }

  export type AttendanceCountAggregateInputType = {
    id?: true
    employee_id?: true
    date?: true
    status?: true
    overtime_hours?: true
    project_id?: true
    check_in?: true
    check_out?: true
    created_at?: true
    _all?: true
  }

  export type AttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendance to aggregate.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attendances
    **/
    _count?: true | AttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceMaxAggregateInputType
  }

  export type GetAttendanceAggregateType<T extends AttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendance[P]>
      : GetScalarType<T[P], AggregateAttendance[P]>
  }




  export type AttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithAggregationInput | AttendanceOrderByWithAggregationInput[]
    by: AttendanceScalarFieldEnum[] | AttendanceScalarFieldEnum
    having?: AttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceCountAggregateInputType | true
    _avg?: AttendanceAvgAggregateInputType
    _sum?: AttendanceSumAggregateInputType
    _min?: AttendanceMinAggregateInputType
    _max?: AttendanceMaxAggregateInputType
  }

  export type AttendanceGroupByOutputType = {
    id: string
    employee_id: string
    date: Date
    status: string
    overtime_hours: number
    project_id: string | null
    check_in: Date | null
    check_out: Date | null
    created_at: Date
    _count: AttendanceCountAggregateOutputType | null
    _avg: AttendanceAvgAggregateOutputType | null
    _sum: AttendanceSumAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  type GetAttendanceGroupByPayload<T extends AttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employee_id?: boolean
    date?: boolean
    status?: boolean
    overtime_hours?: boolean
    project_id?: boolean
    check_in?: boolean
    check_out?: boolean
    created_at?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    project?: boolean | Attendance$projectArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employee_id?: boolean
    date?: boolean
    status?: boolean
    overtime_hours?: boolean
    project_id?: boolean
    check_in?: boolean
    check_out?: boolean
    created_at?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    project?: boolean | Attendance$projectArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employee_id?: boolean
    date?: boolean
    status?: boolean
    overtime_hours?: boolean
    project_id?: boolean
    check_in?: boolean
    check_out?: boolean
    created_at?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    project?: boolean | Attendance$projectArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectScalar = {
    id?: boolean
    employee_id?: boolean
    date?: boolean
    status?: boolean
    overtime_hours?: boolean
    project_id?: boolean
    check_in?: boolean
    check_out?: boolean
    created_at?: boolean
  }

  export type AttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employee_id" | "date" | "status" | "overtime_hours" | "project_id" | "check_in" | "check_out" | "created_at", ExtArgs["result"]["attendance"]>
  export type AttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    project?: boolean | Attendance$projectArgs<ExtArgs>
  }
  export type AttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    project?: boolean | Attendance$projectArgs<ExtArgs>
  }
  export type AttendanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    project?: boolean | Attendance$projectArgs<ExtArgs>
  }

  export type $AttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attendance"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employee_id: string
      date: Date
      status: string
      overtime_hours: number
      project_id: string | null
      check_in: Date | null
      check_out: Date | null
      created_at: Date
    }, ExtArgs["result"]["attendance"]>
    composites: {}
  }

  type AttendanceGetPayload<S extends boolean | null | undefined | AttendanceDefaultArgs> = $Result.GetResult<Prisma.$AttendancePayload, S>

  type AttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceCountAggregateInputType | true
    }

  export interface AttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attendance'], meta: { name: 'Attendance' } }
    /**
     * Find zero or one Attendance that matches the filter.
     * @param {AttendanceFindUniqueArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceFindUniqueArgs>(args: SelectSubset<T, AttendanceFindUniqueArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceFindUniqueOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceFindFirstArgs>(args?: SelectSubset<T, AttendanceFindFirstArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendance.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceWithIdOnly = await prisma.attendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceFindManyArgs>(args?: SelectSubset<T, AttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendance.
     * @param {AttendanceCreateArgs} args - Arguments to create a Attendance.
     * @example
     * // Create one Attendance
     * const Attendance = await prisma.attendance.create({
     *   data: {
     *     // ... data to create a Attendance
     *   }
     * })
     * 
     */
    create<T extends AttendanceCreateArgs>(args: SelectSubset<T, AttendanceCreateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendances.
     * @param {AttendanceCreateManyArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceCreateManyArgs>(args?: SelectSubset<T, AttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attendances and returns the data saved in the database.
     * @param {AttendanceCreateManyAndReturnArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attendance.
     * @param {AttendanceDeleteArgs} args - Arguments to delete one Attendance.
     * @example
     * // Delete one Attendance
     * const Attendance = await prisma.attendance.delete({
     *   where: {
     *     // ... filter to delete one Attendance
     *   }
     * })
     * 
     */
    delete<T extends AttendanceDeleteArgs>(args: SelectSubset<T, AttendanceDeleteArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendance.
     * @param {AttendanceUpdateArgs} args - Arguments to update one Attendance.
     * @example
     * // Update one Attendance
     * const attendance = await prisma.attendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceUpdateArgs>(args: SelectSubset<T, AttendanceUpdateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendances.
     * @param {AttendanceDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceDeleteManyArgs>(args?: SelectSubset<T, AttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceUpdateManyArgs>(args: SelectSubset<T, AttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances and returns the data updated in the database.
     * @param {AttendanceUpdateManyAndReturnArgs} args - Arguments to update many Attendances.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attendance.
     * @param {AttendanceUpsertArgs} args - Arguments to update or create a Attendance.
     * @example
     * // Update or create a Attendance
     * const attendance = await prisma.attendance.upsert({
     *   create: {
     *     // ... data to create a Attendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendance we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceUpsertArgs>(args: SelectSubset<T, AttendanceUpsertArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendance.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends AttendanceCountArgs>(
      args?: Subset<T, AttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceAggregateArgs>(args: Subset<T, AttendanceAggregateArgs>): Prisma.PrismaPromise<GetAttendanceAggregateType<T>>

    /**
     * Group by Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attendance model
   */
  readonly fields: AttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    project<T extends Attendance$projectArgs<ExtArgs> = {}>(args?: Subset<T, Attendance$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attendance model
   */
  interface AttendanceFieldRefs {
    readonly id: FieldRef<"Attendance", 'String'>
    readonly employee_id: FieldRef<"Attendance", 'String'>
    readonly date: FieldRef<"Attendance", 'DateTime'>
    readonly status: FieldRef<"Attendance", 'String'>
    readonly overtime_hours: FieldRef<"Attendance", 'Float'>
    readonly project_id: FieldRef<"Attendance", 'String'>
    readonly check_in: FieldRef<"Attendance", 'DateTime'>
    readonly check_out: FieldRef<"Attendance", 'DateTime'>
    readonly created_at: FieldRef<"Attendance", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Attendance findUnique
   */
  export type AttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findUniqueOrThrow
   */
  export type AttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findFirst
   */
  export type AttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findFirstOrThrow
   */
  export type AttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findMany
   */
  export type AttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance create
   */
  export type AttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Attendance.
     */
    data: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
  }

  /**
   * Attendance createMany
   */
  export type AttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attendance createManyAndReturn
   */
  export type AttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance update
   */
  export type AttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Attendance.
     */
    data: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
    /**
     * Choose, which Attendance to update.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance updateMany
   */
  export type AttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
  }

  /**
   * Attendance updateManyAndReturn
   */
  export type AttendanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance upsert
   */
  export type AttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Attendance to update in case it exists.
     */
    where: AttendanceWhereUniqueInput
    /**
     * In case the Attendance found by the `where` argument doesn't exist, create a new Attendance with this data.
     */
    create: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
    /**
     * In case the Attendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
  }

  /**
   * Attendance delete
   */
  export type AttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter which Attendance to delete.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance deleteMany
   */
  export type AttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendances to delete
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to delete.
     */
    limit?: number
  }

  /**
   * Attendance.project
   */
  export type Attendance$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * Attendance without action
   */
  export type AttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
  }


  /**
   * Model LabourAllocation
   */

  export type AggregateLabourAllocation = {
    _count: LabourAllocationCountAggregateOutputType | null
    _min: LabourAllocationMinAggregateOutputType | null
    _max: LabourAllocationMaxAggregateOutputType | null
  }

  export type LabourAllocationMinAggregateOutputType = {
    id: string | null
    employee_id: string | null
    project_id: string | null
    start_date: Date | null
    end_date: Date | null
    status: string | null
    created_at: Date | null
  }

  export type LabourAllocationMaxAggregateOutputType = {
    id: string | null
    employee_id: string | null
    project_id: string | null
    start_date: Date | null
    end_date: Date | null
    status: string | null
    created_at: Date | null
  }

  export type LabourAllocationCountAggregateOutputType = {
    id: number
    employee_id: number
    project_id: number
    start_date: number
    end_date: number
    status: number
    created_at: number
    _all: number
  }


  export type LabourAllocationMinAggregateInputType = {
    id?: true
    employee_id?: true
    project_id?: true
    start_date?: true
    end_date?: true
    status?: true
    created_at?: true
  }

  export type LabourAllocationMaxAggregateInputType = {
    id?: true
    employee_id?: true
    project_id?: true
    start_date?: true
    end_date?: true
    status?: true
    created_at?: true
  }

  export type LabourAllocationCountAggregateInputType = {
    id?: true
    employee_id?: true
    project_id?: true
    start_date?: true
    end_date?: true
    status?: true
    created_at?: true
    _all?: true
  }

  export type LabourAllocationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabourAllocation to aggregate.
     */
    where?: LabourAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabourAllocations to fetch.
     */
    orderBy?: LabourAllocationOrderByWithRelationInput | LabourAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LabourAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabourAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabourAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LabourAllocations
    **/
    _count?: true | LabourAllocationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LabourAllocationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LabourAllocationMaxAggregateInputType
  }

  export type GetLabourAllocationAggregateType<T extends LabourAllocationAggregateArgs> = {
        [P in keyof T & keyof AggregateLabourAllocation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLabourAllocation[P]>
      : GetScalarType<T[P], AggregateLabourAllocation[P]>
  }




  export type LabourAllocationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LabourAllocationWhereInput
    orderBy?: LabourAllocationOrderByWithAggregationInput | LabourAllocationOrderByWithAggregationInput[]
    by: LabourAllocationScalarFieldEnum[] | LabourAllocationScalarFieldEnum
    having?: LabourAllocationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LabourAllocationCountAggregateInputType | true
    _min?: LabourAllocationMinAggregateInputType
    _max?: LabourAllocationMaxAggregateInputType
  }

  export type LabourAllocationGroupByOutputType = {
    id: string
    employee_id: string
    project_id: string
    start_date: Date
    end_date: Date | null
    status: string
    created_at: Date
    _count: LabourAllocationCountAggregateOutputType | null
    _min: LabourAllocationMinAggregateOutputType | null
    _max: LabourAllocationMaxAggregateOutputType | null
  }

  type GetLabourAllocationGroupByPayload<T extends LabourAllocationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LabourAllocationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LabourAllocationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LabourAllocationGroupByOutputType[P]>
            : GetScalarType<T[P], LabourAllocationGroupByOutputType[P]>
        }
      >
    >


  export type LabourAllocationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employee_id?: boolean
    project_id?: boolean
    start_date?: boolean
    end_date?: boolean
    status?: boolean
    created_at?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labourAllocation"]>

  export type LabourAllocationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employee_id?: boolean
    project_id?: boolean
    start_date?: boolean
    end_date?: boolean
    status?: boolean
    created_at?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labourAllocation"]>

  export type LabourAllocationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employee_id?: boolean
    project_id?: boolean
    start_date?: boolean
    end_date?: boolean
    status?: boolean
    created_at?: boolean
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["labourAllocation"]>

  export type LabourAllocationSelectScalar = {
    id?: boolean
    employee_id?: boolean
    project_id?: boolean
    start_date?: boolean
    end_date?: boolean
    status?: boolean
    created_at?: boolean
  }

  export type LabourAllocationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "employee_id" | "project_id" | "start_date" | "end_date" | "status" | "created_at", ExtArgs["result"]["labourAllocation"]>
  export type LabourAllocationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type LabourAllocationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }
  export type LabourAllocationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    project?: boolean | ProjectDefaultArgs<ExtArgs>
  }

  export type $LabourAllocationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LabourAllocation"
    objects: {
      employee: Prisma.$EmployeePayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employee_id: string
      project_id: string
      start_date: Date
      end_date: Date | null
      status: string
      created_at: Date
    }, ExtArgs["result"]["labourAllocation"]>
    composites: {}
  }

  type LabourAllocationGetPayload<S extends boolean | null | undefined | LabourAllocationDefaultArgs> = $Result.GetResult<Prisma.$LabourAllocationPayload, S>

  type LabourAllocationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LabourAllocationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LabourAllocationCountAggregateInputType | true
    }

  export interface LabourAllocationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LabourAllocation'], meta: { name: 'LabourAllocation' } }
    /**
     * Find zero or one LabourAllocation that matches the filter.
     * @param {LabourAllocationFindUniqueArgs} args - Arguments to find a LabourAllocation
     * @example
     * // Get one LabourAllocation
     * const labourAllocation = await prisma.labourAllocation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LabourAllocationFindUniqueArgs>(args: SelectSubset<T, LabourAllocationFindUniqueArgs<ExtArgs>>): Prisma__LabourAllocationClient<$Result.GetResult<Prisma.$LabourAllocationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one LabourAllocation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LabourAllocationFindUniqueOrThrowArgs} args - Arguments to find a LabourAllocation
     * @example
     * // Get one LabourAllocation
     * const labourAllocation = await prisma.labourAllocation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LabourAllocationFindUniqueOrThrowArgs>(args: SelectSubset<T, LabourAllocationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LabourAllocationClient<$Result.GetResult<Prisma.$LabourAllocationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabourAllocation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourAllocationFindFirstArgs} args - Arguments to find a LabourAllocation
     * @example
     * // Get one LabourAllocation
     * const labourAllocation = await prisma.labourAllocation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LabourAllocationFindFirstArgs>(args?: SelectSubset<T, LabourAllocationFindFirstArgs<ExtArgs>>): Prisma__LabourAllocationClient<$Result.GetResult<Prisma.$LabourAllocationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first LabourAllocation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourAllocationFindFirstOrThrowArgs} args - Arguments to find a LabourAllocation
     * @example
     * // Get one LabourAllocation
     * const labourAllocation = await prisma.labourAllocation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LabourAllocationFindFirstOrThrowArgs>(args?: SelectSubset<T, LabourAllocationFindFirstOrThrowArgs<ExtArgs>>): Prisma__LabourAllocationClient<$Result.GetResult<Prisma.$LabourAllocationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more LabourAllocations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourAllocationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LabourAllocations
     * const labourAllocations = await prisma.labourAllocation.findMany()
     * 
     * // Get first 10 LabourAllocations
     * const labourAllocations = await prisma.labourAllocation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const labourAllocationWithIdOnly = await prisma.labourAllocation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LabourAllocationFindManyArgs>(args?: SelectSubset<T, LabourAllocationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabourAllocationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a LabourAllocation.
     * @param {LabourAllocationCreateArgs} args - Arguments to create a LabourAllocation.
     * @example
     * // Create one LabourAllocation
     * const LabourAllocation = await prisma.labourAllocation.create({
     *   data: {
     *     // ... data to create a LabourAllocation
     *   }
     * })
     * 
     */
    create<T extends LabourAllocationCreateArgs>(args: SelectSubset<T, LabourAllocationCreateArgs<ExtArgs>>): Prisma__LabourAllocationClient<$Result.GetResult<Prisma.$LabourAllocationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many LabourAllocations.
     * @param {LabourAllocationCreateManyArgs} args - Arguments to create many LabourAllocations.
     * @example
     * // Create many LabourAllocations
     * const labourAllocation = await prisma.labourAllocation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LabourAllocationCreateManyArgs>(args?: SelectSubset<T, LabourAllocationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LabourAllocations and returns the data saved in the database.
     * @param {LabourAllocationCreateManyAndReturnArgs} args - Arguments to create many LabourAllocations.
     * @example
     * // Create many LabourAllocations
     * const labourAllocation = await prisma.labourAllocation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LabourAllocations and only return the `id`
     * const labourAllocationWithIdOnly = await prisma.labourAllocation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LabourAllocationCreateManyAndReturnArgs>(args?: SelectSubset<T, LabourAllocationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabourAllocationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a LabourAllocation.
     * @param {LabourAllocationDeleteArgs} args - Arguments to delete one LabourAllocation.
     * @example
     * // Delete one LabourAllocation
     * const LabourAllocation = await prisma.labourAllocation.delete({
     *   where: {
     *     // ... filter to delete one LabourAllocation
     *   }
     * })
     * 
     */
    delete<T extends LabourAllocationDeleteArgs>(args: SelectSubset<T, LabourAllocationDeleteArgs<ExtArgs>>): Prisma__LabourAllocationClient<$Result.GetResult<Prisma.$LabourAllocationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one LabourAllocation.
     * @param {LabourAllocationUpdateArgs} args - Arguments to update one LabourAllocation.
     * @example
     * // Update one LabourAllocation
     * const labourAllocation = await prisma.labourAllocation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LabourAllocationUpdateArgs>(args: SelectSubset<T, LabourAllocationUpdateArgs<ExtArgs>>): Prisma__LabourAllocationClient<$Result.GetResult<Prisma.$LabourAllocationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more LabourAllocations.
     * @param {LabourAllocationDeleteManyArgs} args - Arguments to filter LabourAllocations to delete.
     * @example
     * // Delete a few LabourAllocations
     * const { count } = await prisma.labourAllocation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LabourAllocationDeleteManyArgs>(args?: SelectSubset<T, LabourAllocationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabourAllocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourAllocationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LabourAllocations
     * const labourAllocation = await prisma.labourAllocation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LabourAllocationUpdateManyArgs>(args: SelectSubset<T, LabourAllocationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LabourAllocations and returns the data updated in the database.
     * @param {LabourAllocationUpdateManyAndReturnArgs} args - Arguments to update many LabourAllocations.
     * @example
     * // Update many LabourAllocations
     * const labourAllocation = await prisma.labourAllocation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more LabourAllocations and only return the `id`
     * const labourAllocationWithIdOnly = await prisma.labourAllocation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LabourAllocationUpdateManyAndReturnArgs>(args: SelectSubset<T, LabourAllocationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LabourAllocationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one LabourAllocation.
     * @param {LabourAllocationUpsertArgs} args - Arguments to update or create a LabourAllocation.
     * @example
     * // Update or create a LabourAllocation
     * const labourAllocation = await prisma.labourAllocation.upsert({
     *   create: {
     *     // ... data to create a LabourAllocation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LabourAllocation we want to update
     *   }
     * })
     */
    upsert<T extends LabourAllocationUpsertArgs>(args: SelectSubset<T, LabourAllocationUpsertArgs<ExtArgs>>): Prisma__LabourAllocationClient<$Result.GetResult<Prisma.$LabourAllocationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of LabourAllocations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourAllocationCountArgs} args - Arguments to filter LabourAllocations to count.
     * @example
     * // Count the number of LabourAllocations
     * const count = await prisma.labourAllocation.count({
     *   where: {
     *     // ... the filter for the LabourAllocations we want to count
     *   }
     * })
    **/
    count<T extends LabourAllocationCountArgs>(
      args?: Subset<T, LabourAllocationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LabourAllocationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LabourAllocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourAllocationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LabourAllocationAggregateArgs>(args: Subset<T, LabourAllocationAggregateArgs>): Prisma.PrismaPromise<GetLabourAllocationAggregateType<T>>

    /**
     * Group by LabourAllocation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LabourAllocationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LabourAllocationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LabourAllocationGroupByArgs['orderBy'] }
        : { orderBy?: LabourAllocationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LabourAllocationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLabourAllocationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LabourAllocation model
   */
  readonly fields: LabourAllocationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LabourAllocation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LabourAllocationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    project<T extends ProjectDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProjectDefaultArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LabourAllocation model
   */
  interface LabourAllocationFieldRefs {
    readonly id: FieldRef<"LabourAllocation", 'String'>
    readonly employee_id: FieldRef<"LabourAllocation", 'String'>
    readonly project_id: FieldRef<"LabourAllocation", 'String'>
    readonly start_date: FieldRef<"LabourAllocation", 'DateTime'>
    readonly end_date: FieldRef<"LabourAllocation", 'DateTime'>
    readonly status: FieldRef<"LabourAllocation", 'String'>
    readonly created_at: FieldRef<"LabourAllocation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LabourAllocation findUnique
   */
  export type LabourAllocationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourAllocation
     */
    select?: LabourAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourAllocation
     */
    omit?: LabourAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourAllocationInclude<ExtArgs> | null
    /**
     * Filter, which LabourAllocation to fetch.
     */
    where: LabourAllocationWhereUniqueInput
  }

  /**
   * LabourAllocation findUniqueOrThrow
   */
  export type LabourAllocationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourAllocation
     */
    select?: LabourAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourAllocation
     */
    omit?: LabourAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourAllocationInclude<ExtArgs> | null
    /**
     * Filter, which LabourAllocation to fetch.
     */
    where: LabourAllocationWhereUniqueInput
  }

  /**
   * LabourAllocation findFirst
   */
  export type LabourAllocationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourAllocation
     */
    select?: LabourAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourAllocation
     */
    omit?: LabourAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourAllocationInclude<ExtArgs> | null
    /**
     * Filter, which LabourAllocation to fetch.
     */
    where?: LabourAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabourAllocations to fetch.
     */
    orderBy?: LabourAllocationOrderByWithRelationInput | LabourAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabourAllocations.
     */
    cursor?: LabourAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabourAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabourAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabourAllocations.
     */
    distinct?: LabourAllocationScalarFieldEnum | LabourAllocationScalarFieldEnum[]
  }

  /**
   * LabourAllocation findFirstOrThrow
   */
  export type LabourAllocationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourAllocation
     */
    select?: LabourAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourAllocation
     */
    omit?: LabourAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourAllocationInclude<ExtArgs> | null
    /**
     * Filter, which LabourAllocation to fetch.
     */
    where?: LabourAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabourAllocations to fetch.
     */
    orderBy?: LabourAllocationOrderByWithRelationInput | LabourAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LabourAllocations.
     */
    cursor?: LabourAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabourAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabourAllocations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LabourAllocations.
     */
    distinct?: LabourAllocationScalarFieldEnum | LabourAllocationScalarFieldEnum[]
  }

  /**
   * LabourAllocation findMany
   */
  export type LabourAllocationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourAllocation
     */
    select?: LabourAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourAllocation
     */
    omit?: LabourAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourAllocationInclude<ExtArgs> | null
    /**
     * Filter, which LabourAllocations to fetch.
     */
    where?: LabourAllocationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LabourAllocations to fetch.
     */
    orderBy?: LabourAllocationOrderByWithRelationInput | LabourAllocationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LabourAllocations.
     */
    cursor?: LabourAllocationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LabourAllocations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LabourAllocations.
     */
    skip?: number
    distinct?: LabourAllocationScalarFieldEnum | LabourAllocationScalarFieldEnum[]
  }

  /**
   * LabourAllocation create
   */
  export type LabourAllocationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourAllocation
     */
    select?: LabourAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourAllocation
     */
    omit?: LabourAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourAllocationInclude<ExtArgs> | null
    /**
     * The data needed to create a LabourAllocation.
     */
    data: XOR<LabourAllocationCreateInput, LabourAllocationUncheckedCreateInput>
  }

  /**
   * LabourAllocation createMany
   */
  export type LabourAllocationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LabourAllocations.
     */
    data: LabourAllocationCreateManyInput | LabourAllocationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LabourAllocation createManyAndReturn
   */
  export type LabourAllocationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourAllocation
     */
    select?: LabourAllocationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabourAllocation
     */
    omit?: LabourAllocationOmit<ExtArgs> | null
    /**
     * The data used to create many LabourAllocations.
     */
    data: LabourAllocationCreateManyInput | LabourAllocationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourAllocationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabourAllocation update
   */
  export type LabourAllocationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourAllocation
     */
    select?: LabourAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourAllocation
     */
    omit?: LabourAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourAllocationInclude<ExtArgs> | null
    /**
     * The data needed to update a LabourAllocation.
     */
    data: XOR<LabourAllocationUpdateInput, LabourAllocationUncheckedUpdateInput>
    /**
     * Choose, which LabourAllocation to update.
     */
    where: LabourAllocationWhereUniqueInput
  }

  /**
   * LabourAllocation updateMany
   */
  export type LabourAllocationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LabourAllocations.
     */
    data: XOR<LabourAllocationUpdateManyMutationInput, LabourAllocationUncheckedUpdateManyInput>
    /**
     * Filter which LabourAllocations to update
     */
    where?: LabourAllocationWhereInput
    /**
     * Limit how many LabourAllocations to update.
     */
    limit?: number
  }

  /**
   * LabourAllocation updateManyAndReturn
   */
  export type LabourAllocationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourAllocation
     */
    select?: LabourAllocationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the LabourAllocation
     */
    omit?: LabourAllocationOmit<ExtArgs> | null
    /**
     * The data used to update LabourAllocations.
     */
    data: XOR<LabourAllocationUpdateManyMutationInput, LabourAllocationUncheckedUpdateManyInput>
    /**
     * Filter which LabourAllocations to update
     */
    where?: LabourAllocationWhereInput
    /**
     * Limit how many LabourAllocations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourAllocationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * LabourAllocation upsert
   */
  export type LabourAllocationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourAllocation
     */
    select?: LabourAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourAllocation
     */
    omit?: LabourAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourAllocationInclude<ExtArgs> | null
    /**
     * The filter to search for the LabourAllocation to update in case it exists.
     */
    where: LabourAllocationWhereUniqueInput
    /**
     * In case the LabourAllocation found by the `where` argument doesn't exist, create a new LabourAllocation with this data.
     */
    create: XOR<LabourAllocationCreateInput, LabourAllocationUncheckedCreateInput>
    /**
     * In case the LabourAllocation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LabourAllocationUpdateInput, LabourAllocationUncheckedUpdateInput>
  }

  /**
   * LabourAllocation delete
   */
  export type LabourAllocationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourAllocation
     */
    select?: LabourAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourAllocation
     */
    omit?: LabourAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourAllocationInclude<ExtArgs> | null
    /**
     * Filter which LabourAllocation to delete.
     */
    where: LabourAllocationWhereUniqueInput
  }

  /**
   * LabourAllocation deleteMany
   */
  export type LabourAllocationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LabourAllocations to delete
     */
    where?: LabourAllocationWhereInput
    /**
     * Limit how many LabourAllocations to delete.
     */
    limit?: number
  }

  /**
   * LabourAllocation without action
   */
  export type LabourAllocationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LabourAllocation
     */
    select?: LabourAllocationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the LabourAllocation
     */
    omit?: LabourAllocationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LabourAllocationInclude<ExtArgs> | null
  }


  /**
   * Model Payroll
   */

  export type AggregatePayroll = {
    _count: PayrollCountAggregateOutputType | null
    _avg: PayrollAvgAggregateOutputType | null
    _sum: PayrollSumAggregateOutputType | null
    _min: PayrollMinAggregateOutputType | null
    _max: PayrollMaxAggregateOutputType | null
  }

  export type PayrollAvgAggregateOutputType = {
    total_amount: Decimal | null
  }

  export type PayrollSumAggregateOutputType = {
    total_amount: Decimal | null
  }

  export type PayrollMinAggregateOutputType = {
    id: string | null
    month: string | null
    status: string | null
    total_amount: Decimal | null
    approved_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PayrollMaxAggregateOutputType = {
    id: string | null
    month: string | null
    status: string | null
    total_amount: Decimal | null
    approved_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PayrollCountAggregateOutputType = {
    id: number
    month: number
    status: number
    total_amount: number
    approved_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PayrollAvgAggregateInputType = {
    total_amount?: true
  }

  export type PayrollSumAggregateInputType = {
    total_amount?: true
  }

  export type PayrollMinAggregateInputType = {
    id?: true
    month?: true
    status?: true
    total_amount?: true
    approved_by?: true
    created_at?: true
    updated_at?: true
  }

  export type PayrollMaxAggregateInputType = {
    id?: true
    month?: true
    status?: true
    total_amount?: true
    approved_by?: true
    created_at?: true
    updated_at?: true
  }

  export type PayrollCountAggregateInputType = {
    id?: true
    month?: true
    status?: true
    total_amount?: true
    approved_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PayrollAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payroll to aggregate.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payrolls
    **/
    _count?: true | PayrollCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayrollAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayrollSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayrollMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayrollMaxAggregateInputType
  }

  export type GetPayrollAggregateType<T extends PayrollAggregateArgs> = {
        [P in keyof T & keyof AggregatePayroll]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayroll[P]>
      : GetScalarType<T[P], AggregatePayroll[P]>
  }




  export type PayrollGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollWhereInput
    orderBy?: PayrollOrderByWithAggregationInput | PayrollOrderByWithAggregationInput[]
    by: PayrollScalarFieldEnum[] | PayrollScalarFieldEnum
    having?: PayrollScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayrollCountAggregateInputType | true
    _avg?: PayrollAvgAggregateInputType
    _sum?: PayrollSumAggregateInputType
    _min?: PayrollMinAggregateInputType
    _max?: PayrollMaxAggregateInputType
  }

  export type PayrollGroupByOutputType = {
    id: string
    month: string
    status: string
    total_amount: Decimal
    approved_by: string | null
    created_at: Date
    updated_at: Date
    _count: PayrollCountAggregateOutputType | null
    _avg: PayrollAvgAggregateOutputType | null
    _sum: PayrollSumAggregateOutputType | null
    _min: PayrollMinAggregateOutputType | null
    _max: PayrollMaxAggregateOutputType | null
  }

  type GetPayrollGroupByPayload<T extends PayrollGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayrollGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayrollGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayrollGroupByOutputType[P]>
            : GetScalarType<T[P], PayrollGroupByOutputType[P]>
        }
      >
    >


  export type PayrollSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    month?: boolean
    status?: boolean
    total_amount?: boolean
    approved_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    lines?: boolean | Payroll$linesArgs<ExtArgs>
    _count?: boolean | PayrollCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payroll"]>

  export type PayrollSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    month?: boolean
    status?: boolean
    total_amount?: boolean
    approved_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["payroll"]>

  export type PayrollSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    month?: boolean
    status?: boolean
    total_amount?: boolean
    approved_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["payroll"]>

  export type PayrollSelectScalar = {
    id?: boolean
    month?: boolean
    status?: boolean
    total_amount?: boolean
    approved_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type PayrollOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "month" | "status" | "total_amount" | "approved_by" | "created_at" | "updated_at", ExtArgs["result"]["payroll"]>
  export type PayrollInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lines?: boolean | Payroll$linesArgs<ExtArgs>
    _count?: boolean | PayrollCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PayrollIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type PayrollIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $PayrollPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payroll"
    objects: {
      lines: Prisma.$PayrollLinePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      month: string
      status: string
      total_amount: Prisma.Decimal
      approved_by: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["payroll"]>
    composites: {}
  }

  type PayrollGetPayload<S extends boolean | null | undefined | PayrollDefaultArgs> = $Result.GetResult<Prisma.$PayrollPayload, S>

  type PayrollCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PayrollFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PayrollCountAggregateInputType | true
    }

  export interface PayrollDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payroll'], meta: { name: 'Payroll' } }
    /**
     * Find zero or one Payroll that matches the filter.
     * @param {PayrollFindUniqueArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PayrollFindUniqueArgs>(args: SelectSubset<T, PayrollFindUniqueArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payroll that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PayrollFindUniqueOrThrowArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PayrollFindUniqueOrThrowArgs>(args: SelectSubset<T, PayrollFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payroll that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollFindFirstArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PayrollFindFirstArgs>(args?: SelectSubset<T, PayrollFindFirstArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payroll that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollFindFirstOrThrowArgs} args - Arguments to find a Payroll
     * @example
     * // Get one Payroll
     * const payroll = await prisma.payroll.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PayrollFindFirstOrThrowArgs>(args?: SelectSubset<T, PayrollFindFirstOrThrowArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payrolls that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payrolls
     * const payrolls = await prisma.payroll.findMany()
     * 
     * // Get first 10 Payrolls
     * const payrolls = await prisma.payroll.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payrollWithIdOnly = await prisma.payroll.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PayrollFindManyArgs>(args?: SelectSubset<T, PayrollFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payroll.
     * @param {PayrollCreateArgs} args - Arguments to create a Payroll.
     * @example
     * // Create one Payroll
     * const Payroll = await prisma.payroll.create({
     *   data: {
     *     // ... data to create a Payroll
     *   }
     * })
     * 
     */
    create<T extends PayrollCreateArgs>(args: SelectSubset<T, PayrollCreateArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payrolls.
     * @param {PayrollCreateManyArgs} args - Arguments to create many Payrolls.
     * @example
     * // Create many Payrolls
     * const payroll = await prisma.payroll.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PayrollCreateManyArgs>(args?: SelectSubset<T, PayrollCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payrolls and returns the data saved in the database.
     * @param {PayrollCreateManyAndReturnArgs} args - Arguments to create many Payrolls.
     * @example
     * // Create many Payrolls
     * const payroll = await prisma.payroll.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payrolls and only return the `id`
     * const payrollWithIdOnly = await prisma.payroll.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PayrollCreateManyAndReturnArgs>(args?: SelectSubset<T, PayrollCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payroll.
     * @param {PayrollDeleteArgs} args - Arguments to delete one Payroll.
     * @example
     * // Delete one Payroll
     * const Payroll = await prisma.payroll.delete({
     *   where: {
     *     // ... filter to delete one Payroll
     *   }
     * })
     * 
     */
    delete<T extends PayrollDeleteArgs>(args: SelectSubset<T, PayrollDeleteArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payroll.
     * @param {PayrollUpdateArgs} args - Arguments to update one Payroll.
     * @example
     * // Update one Payroll
     * const payroll = await prisma.payroll.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PayrollUpdateArgs>(args: SelectSubset<T, PayrollUpdateArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payrolls.
     * @param {PayrollDeleteManyArgs} args - Arguments to filter Payrolls to delete.
     * @example
     * // Delete a few Payrolls
     * const { count } = await prisma.payroll.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PayrollDeleteManyArgs>(args?: SelectSubset<T, PayrollDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payrolls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payrolls
     * const payroll = await prisma.payroll.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PayrollUpdateManyArgs>(args: SelectSubset<T, PayrollUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payrolls and returns the data updated in the database.
     * @param {PayrollUpdateManyAndReturnArgs} args - Arguments to update many Payrolls.
     * @example
     * // Update many Payrolls
     * const payroll = await prisma.payroll.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payrolls and only return the `id`
     * const payrollWithIdOnly = await prisma.payroll.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PayrollUpdateManyAndReturnArgs>(args: SelectSubset<T, PayrollUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payroll.
     * @param {PayrollUpsertArgs} args - Arguments to update or create a Payroll.
     * @example
     * // Update or create a Payroll
     * const payroll = await prisma.payroll.upsert({
     *   create: {
     *     // ... data to create a Payroll
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payroll we want to update
     *   }
     * })
     */
    upsert<T extends PayrollUpsertArgs>(args: SelectSubset<T, PayrollUpsertArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payrolls.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollCountArgs} args - Arguments to filter Payrolls to count.
     * @example
     * // Count the number of Payrolls
     * const count = await prisma.payroll.count({
     *   where: {
     *     // ... the filter for the Payrolls we want to count
     *   }
     * })
    **/
    count<T extends PayrollCountArgs>(
      args?: Subset<T, PayrollCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayrollCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payroll.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayrollAggregateArgs>(args: Subset<T, PayrollAggregateArgs>): Prisma.PrismaPromise<GetPayrollAggregateType<T>>

    /**
     * Group by Payroll.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayrollGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayrollGroupByArgs['orderBy'] }
        : { orderBy?: PayrollGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayrollGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayrollGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payroll model
   */
  readonly fields: PayrollFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payroll.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayrollClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lines<T extends Payroll$linesArgs<ExtArgs> = {}>(args?: Subset<T, Payroll$linesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payroll model
   */
  interface PayrollFieldRefs {
    readonly id: FieldRef<"Payroll", 'String'>
    readonly month: FieldRef<"Payroll", 'String'>
    readonly status: FieldRef<"Payroll", 'String'>
    readonly total_amount: FieldRef<"Payroll", 'Decimal'>
    readonly approved_by: FieldRef<"Payroll", 'String'>
    readonly created_at: FieldRef<"Payroll", 'DateTime'>
    readonly updated_at: FieldRef<"Payroll", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Payroll findUnique
   */
  export type PayrollFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll findUniqueOrThrow
   */
  export type PayrollFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll findFirst
   */
  export type PayrollFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payrolls.
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payrolls.
     */
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * Payroll findFirstOrThrow
   */
  export type PayrollFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payroll to fetch.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payrolls.
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payrolls.
     */
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * Payroll findMany
   */
  export type PayrollFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter, which Payrolls to fetch.
     */
    where?: PayrollWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payrolls to fetch.
     */
    orderBy?: PayrollOrderByWithRelationInput | PayrollOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payrolls.
     */
    cursor?: PayrollWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Payrolls from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payrolls.
     */
    skip?: number
    distinct?: PayrollScalarFieldEnum | PayrollScalarFieldEnum[]
  }

  /**
   * Payroll create
   */
  export type PayrollCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * The data needed to create a Payroll.
     */
    data: XOR<PayrollCreateInput, PayrollUncheckedCreateInput>
  }

  /**
   * Payroll createMany
   */
  export type PayrollCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payrolls.
     */
    data: PayrollCreateManyInput | PayrollCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payroll createManyAndReturn
   */
  export type PayrollCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * The data used to create many Payrolls.
     */
    data: PayrollCreateManyInput | PayrollCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payroll update
   */
  export type PayrollUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * The data needed to update a Payroll.
     */
    data: XOR<PayrollUpdateInput, PayrollUncheckedUpdateInput>
    /**
     * Choose, which Payroll to update.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll updateMany
   */
  export type PayrollUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payrolls.
     */
    data: XOR<PayrollUpdateManyMutationInput, PayrollUncheckedUpdateManyInput>
    /**
     * Filter which Payrolls to update
     */
    where?: PayrollWhereInput
    /**
     * Limit how many Payrolls to update.
     */
    limit?: number
  }

  /**
   * Payroll updateManyAndReturn
   */
  export type PayrollUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * The data used to update Payrolls.
     */
    data: XOR<PayrollUpdateManyMutationInput, PayrollUncheckedUpdateManyInput>
    /**
     * Filter which Payrolls to update
     */
    where?: PayrollWhereInput
    /**
     * Limit how many Payrolls to update.
     */
    limit?: number
  }

  /**
   * Payroll upsert
   */
  export type PayrollUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * The filter to search for the Payroll to update in case it exists.
     */
    where: PayrollWhereUniqueInput
    /**
     * In case the Payroll found by the `where` argument doesn't exist, create a new Payroll with this data.
     */
    create: XOR<PayrollCreateInput, PayrollUncheckedCreateInput>
    /**
     * In case the Payroll was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayrollUpdateInput, PayrollUncheckedUpdateInput>
  }

  /**
   * Payroll delete
   */
  export type PayrollDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
    /**
     * Filter which Payroll to delete.
     */
    where: PayrollWhereUniqueInput
  }

  /**
   * Payroll deleteMany
   */
  export type PayrollDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payrolls to delete
     */
    where?: PayrollWhereInput
    /**
     * Limit how many Payrolls to delete.
     */
    limit?: number
  }

  /**
   * Payroll.lines
   */
  export type Payroll$linesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollLine
     */
    select?: PayrollLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollLine
     */
    omit?: PayrollLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollLineInclude<ExtArgs> | null
    where?: PayrollLineWhereInput
    orderBy?: PayrollLineOrderByWithRelationInput | PayrollLineOrderByWithRelationInput[]
    cursor?: PayrollLineWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayrollLineScalarFieldEnum | PayrollLineScalarFieldEnum[]
  }

  /**
   * Payroll without action
   */
  export type PayrollDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payroll
     */
    select?: PayrollSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payroll
     */
    omit?: PayrollOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollInclude<ExtArgs> | null
  }


  /**
   * Model PayrollLine
   */

  export type AggregatePayrollLine = {
    _count: PayrollLineCountAggregateOutputType | null
    _avg: PayrollLineAvgAggregateOutputType | null
    _sum: PayrollLineSumAggregateOutputType | null
    _min: PayrollLineMinAggregateOutputType | null
    _max: PayrollLineMaxAggregateOutputType | null
  }

  export type PayrollLineAvgAggregateOutputType = {
    basic_pay: Decimal | null
    overtime_pay: Decimal | null
    deductions: Decimal | null
    total_pay: Decimal | null
  }

  export type PayrollLineSumAggregateOutputType = {
    basic_pay: Decimal | null
    overtime_pay: Decimal | null
    deductions: Decimal | null
    total_pay: Decimal | null
  }

  export type PayrollLineMinAggregateOutputType = {
    id: string | null
    payroll_id: string | null
    employee_id: string | null
    basic_pay: Decimal | null
    overtime_pay: Decimal | null
    deductions: Decimal | null
    total_pay: Decimal | null
    status: string | null
  }

  export type PayrollLineMaxAggregateOutputType = {
    id: string | null
    payroll_id: string | null
    employee_id: string | null
    basic_pay: Decimal | null
    overtime_pay: Decimal | null
    deductions: Decimal | null
    total_pay: Decimal | null
    status: string | null
  }

  export type PayrollLineCountAggregateOutputType = {
    id: number
    payroll_id: number
    employee_id: number
    basic_pay: number
    overtime_pay: number
    deductions: number
    total_pay: number
    status: number
    _all: number
  }


  export type PayrollLineAvgAggregateInputType = {
    basic_pay?: true
    overtime_pay?: true
    deductions?: true
    total_pay?: true
  }

  export type PayrollLineSumAggregateInputType = {
    basic_pay?: true
    overtime_pay?: true
    deductions?: true
    total_pay?: true
  }

  export type PayrollLineMinAggregateInputType = {
    id?: true
    payroll_id?: true
    employee_id?: true
    basic_pay?: true
    overtime_pay?: true
    deductions?: true
    total_pay?: true
    status?: true
  }

  export type PayrollLineMaxAggregateInputType = {
    id?: true
    payroll_id?: true
    employee_id?: true
    basic_pay?: true
    overtime_pay?: true
    deductions?: true
    total_pay?: true
    status?: true
  }

  export type PayrollLineCountAggregateInputType = {
    id?: true
    payroll_id?: true
    employee_id?: true
    basic_pay?: true
    overtime_pay?: true
    deductions?: true
    total_pay?: true
    status?: true
    _all?: true
  }

  export type PayrollLineAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayrollLine to aggregate.
     */
    where?: PayrollLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollLines to fetch.
     */
    orderBy?: PayrollLineOrderByWithRelationInput | PayrollLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayrollLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PayrollLines
    **/
    _count?: true | PayrollLineCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayrollLineAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayrollLineSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayrollLineMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayrollLineMaxAggregateInputType
  }

  export type GetPayrollLineAggregateType<T extends PayrollLineAggregateArgs> = {
        [P in keyof T & keyof AggregatePayrollLine]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayrollLine[P]>
      : GetScalarType<T[P], AggregatePayrollLine[P]>
  }




  export type PayrollLineGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollLineWhereInput
    orderBy?: PayrollLineOrderByWithAggregationInput | PayrollLineOrderByWithAggregationInput[]
    by: PayrollLineScalarFieldEnum[] | PayrollLineScalarFieldEnum
    having?: PayrollLineScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayrollLineCountAggregateInputType | true
    _avg?: PayrollLineAvgAggregateInputType
    _sum?: PayrollLineSumAggregateInputType
    _min?: PayrollLineMinAggregateInputType
    _max?: PayrollLineMaxAggregateInputType
  }

  export type PayrollLineGroupByOutputType = {
    id: string
    payroll_id: string
    employee_id: string
    basic_pay: Decimal
    overtime_pay: Decimal
    deductions: Decimal
    total_pay: Decimal
    status: string
    _count: PayrollLineCountAggregateOutputType | null
    _avg: PayrollLineAvgAggregateOutputType | null
    _sum: PayrollLineSumAggregateOutputType | null
    _min: PayrollLineMinAggregateOutputType | null
    _max: PayrollLineMaxAggregateOutputType | null
  }

  type GetPayrollLineGroupByPayload<T extends PayrollLineGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayrollLineGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayrollLineGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayrollLineGroupByOutputType[P]>
            : GetScalarType<T[P], PayrollLineGroupByOutputType[P]>
        }
      >
    >


  export type PayrollLineSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    payroll_id?: boolean
    employee_id?: boolean
    basic_pay?: boolean
    overtime_pay?: boolean
    deductions?: boolean
    total_pay?: boolean
    status?: boolean
    payroll?: boolean | PayrollDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payrollLine"]>

  export type PayrollLineSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    payroll_id?: boolean
    employee_id?: boolean
    basic_pay?: boolean
    overtime_pay?: boolean
    deductions?: boolean
    total_pay?: boolean
    status?: boolean
    payroll?: boolean | PayrollDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payrollLine"]>

  export type PayrollLineSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    payroll_id?: boolean
    employee_id?: boolean
    basic_pay?: boolean
    overtime_pay?: boolean
    deductions?: boolean
    total_pay?: boolean
    status?: boolean
    payroll?: boolean | PayrollDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payrollLine"]>

  export type PayrollLineSelectScalar = {
    id?: boolean
    payroll_id?: boolean
    employee_id?: boolean
    basic_pay?: boolean
    overtime_pay?: boolean
    deductions?: boolean
    total_pay?: boolean
    status?: boolean
  }

  export type PayrollLineOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "payroll_id" | "employee_id" | "basic_pay" | "overtime_pay" | "deductions" | "total_pay" | "status", ExtArgs["result"]["payrollLine"]>
  export type PayrollLineInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payroll?: boolean | PayrollDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type PayrollLineIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payroll?: boolean | PayrollDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type PayrollLineIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    payroll?: boolean | PayrollDefaultArgs<ExtArgs>
    employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $PayrollLinePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PayrollLine"
    objects: {
      payroll: Prisma.$PayrollPayload<ExtArgs>
      employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      payroll_id: string
      employee_id: string
      basic_pay: Prisma.Decimal
      overtime_pay: Prisma.Decimal
      deductions: Prisma.Decimal
      total_pay: Prisma.Decimal
      status: string
    }, ExtArgs["result"]["payrollLine"]>
    composites: {}
  }

  type PayrollLineGetPayload<S extends boolean | null | undefined | PayrollLineDefaultArgs> = $Result.GetResult<Prisma.$PayrollLinePayload, S>

  type PayrollLineCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PayrollLineFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PayrollLineCountAggregateInputType | true
    }

  export interface PayrollLineDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PayrollLine'], meta: { name: 'PayrollLine' } }
    /**
     * Find zero or one PayrollLine that matches the filter.
     * @param {PayrollLineFindUniqueArgs} args - Arguments to find a PayrollLine
     * @example
     * // Get one PayrollLine
     * const payrollLine = await prisma.payrollLine.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PayrollLineFindUniqueArgs>(args: SelectSubset<T, PayrollLineFindUniqueArgs<ExtArgs>>): Prisma__PayrollLineClient<$Result.GetResult<Prisma.$PayrollLinePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PayrollLine that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PayrollLineFindUniqueOrThrowArgs} args - Arguments to find a PayrollLine
     * @example
     * // Get one PayrollLine
     * const payrollLine = await prisma.payrollLine.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PayrollLineFindUniqueOrThrowArgs>(args: SelectSubset<T, PayrollLineFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PayrollLineClient<$Result.GetResult<Prisma.$PayrollLinePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PayrollLine that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollLineFindFirstArgs} args - Arguments to find a PayrollLine
     * @example
     * // Get one PayrollLine
     * const payrollLine = await prisma.payrollLine.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PayrollLineFindFirstArgs>(args?: SelectSubset<T, PayrollLineFindFirstArgs<ExtArgs>>): Prisma__PayrollLineClient<$Result.GetResult<Prisma.$PayrollLinePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PayrollLine that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollLineFindFirstOrThrowArgs} args - Arguments to find a PayrollLine
     * @example
     * // Get one PayrollLine
     * const payrollLine = await prisma.payrollLine.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PayrollLineFindFirstOrThrowArgs>(args?: SelectSubset<T, PayrollLineFindFirstOrThrowArgs<ExtArgs>>): Prisma__PayrollLineClient<$Result.GetResult<Prisma.$PayrollLinePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PayrollLines that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollLineFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PayrollLines
     * const payrollLines = await prisma.payrollLine.findMany()
     * 
     * // Get first 10 PayrollLines
     * const payrollLines = await prisma.payrollLine.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payrollLineWithIdOnly = await prisma.payrollLine.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PayrollLineFindManyArgs>(args?: SelectSubset<T, PayrollLineFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollLinePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PayrollLine.
     * @param {PayrollLineCreateArgs} args - Arguments to create a PayrollLine.
     * @example
     * // Create one PayrollLine
     * const PayrollLine = await prisma.payrollLine.create({
     *   data: {
     *     // ... data to create a PayrollLine
     *   }
     * })
     * 
     */
    create<T extends PayrollLineCreateArgs>(args: SelectSubset<T, PayrollLineCreateArgs<ExtArgs>>): Prisma__PayrollLineClient<$Result.GetResult<Prisma.$PayrollLinePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PayrollLines.
     * @param {PayrollLineCreateManyArgs} args - Arguments to create many PayrollLines.
     * @example
     * // Create many PayrollLines
     * const payrollLine = await prisma.payrollLine.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PayrollLineCreateManyArgs>(args?: SelectSubset<T, PayrollLineCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PayrollLines and returns the data saved in the database.
     * @param {PayrollLineCreateManyAndReturnArgs} args - Arguments to create many PayrollLines.
     * @example
     * // Create many PayrollLines
     * const payrollLine = await prisma.payrollLine.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PayrollLines and only return the `id`
     * const payrollLineWithIdOnly = await prisma.payrollLine.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PayrollLineCreateManyAndReturnArgs>(args?: SelectSubset<T, PayrollLineCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollLinePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PayrollLine.
     * @param {PayrollLineDeleteArgs} args - Arguments to delete one PayrollLine.
     * @example
     * // Delete one PayrollLine
     * const PayrollLine = await prisma.payrollLine.delete({
     *   where: {
     *     // ... filter to delete one PayrollLine
     *   }
     * })
     * 
     */
    delete<T extends PayrollLineDeleteArgs>(args: SelectSubset<T, PayrollLineDeleteArgs<ExtArgs>>): Prisma__PayrollLineClient<$Result.GetResult<Prisma.$PayrollLinePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PayrollLine.
     * @param {PayrollLineUpdateArgs} args - Arguments to update one PayrollLine.
     * @example
     * // Update one PayrollLine
     * const payrollLine = await prisma.payrollLine.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PayrollLineUpdateArgs>(args: SelectSubset<T, PayrollLineUpdateArgs<ExtArgs>>): Prisma__PayrollLineClient<$Result.GetResult<Prisma.$PayrollLinePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PayrollLines.
     * @param {PayrollLineDeleteManyArgs} args - Arguments to filter PayrollLines to delete.
     * @example
     * // Delete a few PayrollLines
     * const { count } = await prisma.payrollLine.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PayrollLineDeleteManyArgs>(args?: SelectSubset<T, PayrollLineDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PayrollLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollLineUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PayrollLines
     * const payrollLine = await prisma.payrollLine.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PayrollLineUpdateManyArgs>(args: SelectSubset<T, PayrollLineUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PayrollLines and returns the data updated in the database.
     * @param {PayrollLineUpdateManyAndReturnArgs} args - Arguments to update many PayrollLines.
     * @example
     * // Update many PayrollLines
     * const payrollLine = await prisma.payrollLine.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PayrollLines and only return the `id`
     * const payrollLineWithIdOnly = await prisma.payrollLine.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PayrollLineUpdateManyAndReturnArgs>(args: SelectSubset<T, PayrollLineUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollLinePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PayrollLine.
     * @param {PayrollLineUpsertArgs} args - Arguments to update or create a PayrollLine.
     * @example
     * // Update or create a PayrollLine
     * const payrollLine = await prisma.payrollLine.upsert({
     *   create: {
     *     // ... data to create a PayrollLine
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PayrollLine we want to update
     *   }
     * })
     */
    upsert<T extends PayrollLineUpsertArgs>(args: SelectSubset<T, PayrollLineUpsertArgs<ExtArgs>>): Prisma__PayrollLineClient<$Result.GetResult<Prisma.$PayrollLinePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PayrollLines.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollLineCountArgs} args - Arguments to filter PayrollLines to count.
     * @example
     * // Count the number of PayrollLines
     * const count = await prisma.payrollLine.count({
     *   where: {
     *     // ... the filter for the PayrollLines we want to count
     *   }
     * })
    **/
    count<T extends PayrollLineCountArgs>(
      args?: Subset<T, PayrollLineCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayrollLineCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PayrollLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollLineAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayrollLineAggregateArgs>(args: Subset<T, PayrollLineAggregateArgs>): Prisma.PrismaPromise<GetPayrollLineAggregateType<T>>

    /**
     * Group by PayrollLine.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollLineGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayrollLineGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayrollLineGroupByArgs['orderBy'] }
        : { orderBy?: PayrollLineGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayrollLineGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayrollLineGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PayrollLine model
   */
  readonly fields: PayrollLineFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PayrollLine.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayrollLineClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    payroll<T extends PayrollDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PayrollDefaultArgs<ExtArgs>>): Prisma__PayrollClient<$Result.GetResult<Prisma.$PayrollPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PayrollLine model
   */
  interface PayrollLineFieldRefs {
    readonly id: FieldRef<"PayrollLine", 'String'>
    readonly payroll_id: FieldRef<"PayrollLine", 'String'>
    readonly employee_id: FieldRef<"PayrollLine", 'String'>
    readonly basic_pay: FieldRef<"PayrollLine", 'Decimal'>
    readonly overtime_pay: FieldRef<"PayrollLine", 'Decimal'>
    readonly deductions: FieldRef<"PayrollLine", 'Decimal'>
    readonly total_pay: FieldRef<"PayrollLine", 'Decimal'>
    readonly status: FieldRef<"PayrollLine", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PayrollLine findUnique
   */
  export type PayrollLineFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollLine
     */
    select?: PayrollLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollLine
     */
    omit?: PayrollLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollLineInclude<ExtArgs> | null
    /**
     * Filter, which PayrollLine to fetch.
     */
    where: PayrollLineWhereUniqueInput
  }

  /**
   * PayrollLine findUniqueOrThrow
   */
  export type PayrollLineFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollLine
     */
    select?: PayrollLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollLine
     */
    omit?: PayrollLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollLineInclude<ExtArgs> | null
    /**
     * Filter, which PayrollLine to fetch.
     */
    where: PayrollLineWhereUniqueInput
  }

  /**
   * PayrollLine findFirst
   */
  export type PayrollLineFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollLine
     */
    select?: PayrollLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollLine
     */
    omit?: PayrollLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollLineInclude<ExtArgs> | null
    /**
     * Filter, which PayrollLine to fetch.
     */
    where?: PayrollLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollLines to fetch.
     */
    orderBy?: PayrollLineOrderByWithRelationInput | PayrollLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayrollLines.
     */
    cursor?: PayrollLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayrollLines.
     */
    distinct?: PayrollLineScalarFieldEnum | PayrollLineScalarFieldEnum[]
  }

  /**
   * PayrollLine findFirstOrThrow
   */
  export type PayrollLineFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollLine
     */
    select?: PayrollLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollLine
     */
    omit?: PayrollLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollLineInclude<ExtArgs> | null
    /**
     * Filter, which PayrollLine to fetch.
     */
    where?: PayrollLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollLines to fetch.
     */
    orderBy?: PayrollLineOrderByWithRelationInput | PayrollLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayrollLines.
     */
    cursor?: PayrollLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollLines.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayrollLines.
     */
    distinct?: PayrollLineScalarFieldEnum | PayrollLineScalarFieldEnum[]
  }

  /**
   * PayrollLine findMany
   */
  export type PayrollLineFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollLine
     */
    select?: PayrollLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollLine
     */
    omit?: PayrollLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollLineInclude<ExtArgs> | null
    /**
     * Filter, which PayrollLines to fetch.
     */
    where?: PayrollLineWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollLines to fetch.
     */
    orderBy?: PayrollLineOrderByWithRelationInput | PayrollLineOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PayrollLines.
     */
    cursor?: PayrollLineWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollLines from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollLines.
     */
    skip?: number
    distinct?: PayrollLineScalarFieldEnum | PayrollLineScalarFieldEnum[]
  }

  /**
   * PayrollLine create
   */
  export type PayrollLineCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollLine
     */
    select?: PayrollLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollLine
     */
    omit?: PayrollLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollLineInclude<ExtArgs> | null
    /**
     * The data needed to create a PayrollLine.
     */
    data: XOR<PayrollLineCreateInput, PayrollLineUncheckedCreateInput>
  }

  /**
   * PayrollLine createMany
   */
  export type PayrollLineCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PayrollLines.
     */
    data: PayrollLineCreateManyInput | PayrollLineCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PayrollLine createManyAndReturn
   */
  export type PayrollLineCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollLine
     */
    select?: PayrollLineSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollLine
     */
    omit?: PayrollLineOmit<ExtArgs> | null
    /**
     * The data used to create many PayrollLines.
     */
    data: PayrollLineCreateManyInput | PayrollLineCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollLineIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PayrollLine update
   */
  export type PayrollLineUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollLine
     */
    select?: PayrollLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollLine
     */
    omit?: PayrollLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollLineInclude<ExtArgs> | null
    /**
     * The data needed to update a PayrollLine.
     */
    data: XOR<PayrollLineUpdateInput, PayrollLineUncheckedUpdateInput>
    /**
     * Choose, which PayrollLine to update.
     */
    where: PayrollLineWhereUniqueInput
  }

  /**
   * PayrollLine updateMany
   */
  export type PayrollLineUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PayrollLines.
     */
    data: XOR<PayrollLineUpdateManyMutationInput, PayrollLineUncheckedUpdateManyInput>
    /**
     * Filter which PayrollLines to update
     */
    where?: PayrollLineWhereInput
    /**
     * Limit how many PayrollLines to update.
     */
    limit?: number
  }

  /**
   * PayrollLine updateManyAndReturn
   */
  export type PayrollLineUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollLine
     */
    select?: PayrollLineSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollLine
     */
    omit?: PayrollLineOmit<ExtArgs> | null
    /**
     * The data used to update PayrollLines.
     */
    data: XOR<PayrollLineUpdateManyMutationInput, PayrollLineUncheckedUpdateManyInput>
    /**
     * Filter which PayrollLines to update
     */
    where?: PayrollLineWhereInput
    /**
     * Limit how many PayrollLines to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollLineIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PayrollLine upsert
   */
  export type PayrollLineUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollLine
     */
    select?: PayrollLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollLine
     */
    omit?: PayrollLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollLineInclude<ExtArgs> | null
    /**
     * The filter to search for the PayrollLine to update in case it exists.
     */
    where: PayrollLineWhereUniqueInput
    /**
     * In case the PayrollLine found by the `where` argument doesn't exist, create a new PayrollLine with this data.
     */
    create: XOR<PayrollLineCreateInput, PayrollLineUncheckedCreateInput>
    /**
     * In case the PayrollLine was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayrollLineUpdateInput, PayrollLineUncheckedUpdateInput>
  }

  /**
   * PayrollLine delete
   */
  export type PayrollLineDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollLine
     */
    select?: PayrollLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollLine
     */
    omit?: PayrollLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollLineInclude<ExtArgs> | null
    /**
     * Filter which PayrollLine to delete.
     */
    where: PayrollLineWhereUniqueInput
  }

  /**
   * PayrollLine deleteMany
   */
  export type PayrollLineDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayrollLines to delete
     */
    where?: PayrollLineWhereInput
    /**
     * Limit how many PayrollLines to delete.
     */
    limit?: number
  }

  /**
   * PayrollLine without action
   */
  export type PayrollLineDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollLine
     */
    select?: PayrollLineSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PayrollLine
     */
    omit?: PayrollLineOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollLineInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    user_id: string | null
    title: string | null
    message: string | null
    type: $Enums.NotificationType | null
    link: string | null
    read: boolean | null
    created_at: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    user_id: string | null
    title: string | null
    message: string | null
    type: $Enums.NotificationType | null
    link: string | null
    read: boolean | null
    created_at: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    user_id: number
    title: number
    message: number
    type: number
    link: number
    read: number
    created_at: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    message?: true
    type?: true
    link?: true
    read?: true
    created_at?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    message?: true
    type?: true
    link?: true
    read?: true
    created_at?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    user_id?: true
    title?: true
    message?: true
    type?: true
    link?: true
    read?: true
    created_at?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    user_id: string
    title: string
    message: string
    type: $Enums.NotificationType
    link: string | null
    read: boolean
    created_at: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    link?: boolean
    read?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    link?: boolean
    read?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    user_id?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    link?: boolean
    read?: boolean
    created_at?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    user_id?: boolean
    title?: boolean
    message?: boolean
    type?: boolean
    link?: boolean
    read?: boolean
    created_at?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "user_id" | "title" | "message" | "type" | "link" | "read" | "created_at", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      user_id: string
      title: string
      message: string
      type: $Enums.NotificationType
      link: string | null
      read: boolean
      created_at: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly user_id: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly link: FieldRef<"Notification", 'String'>
    readonly read: FieldRef<"Notification", 'Boolean'>
    readonly created_at: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model SystemSettings
   */

  export type AggregateSystemSettings = {
    _count: SystemSettingsCountAggregateOutputType | null
    _min: SystemSettingsMinAggregateOutputType | null
    _max: SystemSettingsMaxAggregateOutputType | null
  }

  export type SystemSettingsMinAggregateOutputType = {
    id: string | null
    key: string | null
    updated_at: Date | null
  }

  export type SystemSettingsMaxAggregateOutputType = {
    id: string | null
    key: string | null
    updated_at: Date | null
  }

  export type SystemSettingsCountAggregateOutputType = {
    id: number
    key: number
    value: number
    updated_at: number
    _all: number
  }


  export type SystemSettingsMinAggregateInputType = {
    id?: true
    key?: true
    updated_at?: true
  }

  export type SystemSettingsMaxAggregateInputType = {
    id?: true
    key?: true
    updated_at?: true
  }

  export type SystemSettingsCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    updated_at?: true
    _all?: true
  }

  export type SystemSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to aggregate.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SystemSettings
    **/
    _count?: true | SystemSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SystemSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SystemSettingsMaxAggregateInputType
  }

  export type GetSystemSettingsAggregateType<T extends SystemSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateSystemSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSystemSettings[P]>
      : GetScalarType<T[P], AggregateSystemSettings[P]>
  }




  export type SystemSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SystemSettingsWhereInput
    orderBy?: SystemSettingsOrderByWithAggregationInput | SystemSettingsOrderByWithAggregationInput[]
    by: SystemSettingsScalarFieldEnum[] | SystemSettingsScalarFieldEnum
    having?: SystemSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SystemSettingsCountAggregateInputType | true
    _min?: SystemSettingsMinAggregateInputType
    _max?: SystemSettingsMaxAggregateInputType
  }

  export type SystemSettingsGroupByOutputType = {
    id: string
    key: string
    value: JsonValue
    updated_at: Date
    _count: SystemSettingsCountAggregateOutputType | null
    _min: SystemSettingsMinAggregateOutputType | null
    _max: SystemSettingsMaxAggregateOutputType | null
  }

  type GetSystemSettingsGroupByPayload<T extends SystemSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SystemSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SystemSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SystemSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], SystemSettingsGroupByOutputType[P]>
        }
      >
    >


  export type SystemSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["systemSettings"]>

  export type SystemSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["systemSettings"]>

  export type SystemSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["systemSettings"]>

  export type SystemSettingsSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    updated_at?: boolean
  }

  export type SystemSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "value" | "updated_at", ExtArgs["result"]["systemSettings"]>

  export type $SystemSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SystemSettings"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: Prisma.JsonValue
      updated_at: Date
    }, ExtArgs["result"]["systemSettings"]>
    composites: {}
  }

  type SystemSettingsGetPayload<S extends boolean | null | undefined | SystemSettingsDefaultArgs> = $Result.GetResult<Prisma.$SystemSettingsPayload, S>

  type SystemSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SystemSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SystemSettingsCountAggregateInputType | true
    }

  export interface SystemSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SystemSettings'], meta: { name: 'SystemSettings' } }
    /**
     * Find zero or one SystemSettings that matches the filter.
     * @param {SystemSettingsFindUniqueArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SystemSettingsFindUniqueArgs>(args: SelectSubset<T, SystemSettingsFindUniqueArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SystemSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SystemSettingsFindUniqueOrThrowArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SystemSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, SystemSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindFirstArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SystemSettingsFindFirstArgs>(args?: SelectSubset<T, SystemSettingsFindFirstArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SystemSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindFirstOrThrowArgs} args - Arguments to find a SystemSettings
     * @example
     * // Get one SystemSettings
     * const systemSettings = await prisma.systemSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SystemSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, SystemSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SystemSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SystemSettings
     * const systemSettings = await prisma.systemSettings.findMany()
     * 
     * // Get first 10 SystemSettings
     * const systemSettings = await prisma.systemSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const systemSettingsWithIdOnly = await prisma.systemSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SystemSettingsFindManyArgs>(args?: SelectSubset<T, SystemSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SystemSettings.
     * @param {SystemSettingsCreateArgs} args - Arguments to create a SystemSettings.
     * @example
     * // Create one SystemSettings
     * const SystemSettings = await prisma.systemSettings.create({
     *   data: {
     *     // ... data to create a SystemSettings
     *   }
     * })
     * 
     */
    create<T extends SystemSettingsCreateArgs>(args: SelectSubset<T, SystemSettingsCreateArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SystemSettings.
     * @param {SystemSettingsCreateManyArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSettings = await prisma.systemSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SystemSettingsCreateManyArgs>(args?: SelectSubset<T, SystemSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SystemSettings and returns the data saved in the database.
     * @param {SystemSettingsCreateManyAndReturnArgs} args - Arguments to create many SystemSettings.
     * @example
     * // Create many SystemSettings
     * const systemSettings = await prisma.systemSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SystemSettings and only return the `id`
     * const systemSettingsWithIdOnly = await prisma.systemSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SystemSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, SystemSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SystemSettings.
     * @param {SystemSettingsDeleteArgs} args - Arguments to delete one SystemSettings.
     * @example
     * // Delete one SystemSettings
     * const SystemSettings = await prisma.systemSettings.delete({
     *   where: {
     *     // ... filter to delete one SystemSettings
     *   }
     * })
     * 
     */
    delete<T extends SystemSettingsDeleteArgs>(args: SelectSubset<T, SystemSettingsDeleteArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SystemSettings.
     * @param {SystemSettingsUpdateArgs} args - Arguments to update one SystemSettings.
     * @example
     * // Update one SystemSettings
     * const systemSettings = await prisma.systemSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SystemSettingsUpdateArgs>(args: SelectSubset<T, SystemSettingsUpdateArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SystemSettings.
     * @param {SystemSettingsDeleteManyArgs} args - Arguments to filter SystemSettings to delete.
     * @example
     * // Delete a few SystemSettings
     * const { count } = await prisma.systemSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SystemSettingsDeleteManyArgs>(args?: SelectSubset<T, SystemSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SystemSettings
     * const systemSettings = await prisma.systemSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SystemSettingsUpdateManyArgs>(args: SelectSubset<T, SystemSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SystemSettings and returns the data updated in the database.
     * @param {SystemSettingsUpdateManyAndReturnArgs} args - Arguments to update many SystemSettings.
     * @example
     * // Update many SystemSettings
     * const systemSettings = await prisma.systemSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SystemSettings and only return the `id`
     * const systemSettingsWithIdOnly = await prisma.systemSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SystemSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, SystemSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SystemSettings.
     * @param {SystemSettingsUpsertArgs} args - Arguments to update or create a SystemSettings.
     * @example
     * // Update or create a SystemSettings
     * const systemSettings = await prisma.systemSettings.upsert({
     *   create: {
     *     // ... data to create a SystemSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SystemSettings we want to update
     *   }
     * })
     */
    upsert<T extends SystemSettingsUpsertArgs>(args: SelectSubset<T, SystemSettingsUpsertArgs<ExtArgs>>): Prisma__SystemSettingsClient<$Result.GetResult<Prisma.$SystemSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsCountArgs} args - Arguments to filter SystemSettings to count.
     * @example
     * // Count the number of SystemSettings
     * const count = await prisma.systemSettings.count({
     *   where: {
     *     // ... the filter for the SystemSettings we want to count
     *   }
     * })
    **/
    count<T extends SystemSettingsCountArgs>(
      args?: Subset<T, SystemSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SystemSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SystemSettingsAggregateArgs>(args: Subset<T, SystemSettingsAggregateArgs>): Prisma.PrismaPromise<GetSystemSettingsAggregateType<T>>

    /**
     * Group by SystemSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SystemSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SystemSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SystemSettingsGroupByArgs['orderBy'] }
        : { orderBy?: SystemSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SystemSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSystemSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SystemSettings model
   */
  readonly fields: SystemSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SystemSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SystemSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SystemSettings model
   */
  interface SystemSettingsFieldRefs {
    readonly id: FieldRef<"SystemSettings", 'String'>
    readonly key: FieldRef<"SystemSettings", 'String'>
    readonly value: FieldRef<"SystemSettings", 'Json'>
    readonly updated_at: FieldRef<"SystemSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * SystemSettings findUnique
   */
  export type SystemSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings findUniqueOrThrow
   */
  export type SystemSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings findFirst
   */
  export type SystemSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings findFirstOrThrow
   */
  export type SystemSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SystemSettings.
     */
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings findMany
   */
  export type SystemSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter, which SystemSettings to fetch.
     */
    where?: SystemSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SystemSettings to fetch.
     */
    orderBy?: SystemSettingsOrderByWithRelationInput | SystemSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SystemSettings.
     */
    cursor?: SystemSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SystemSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SystemSettings.
     */
    skip?: number
    distinct?: SystemSettingsScalarFieldEnum | SystemSettingsScalarFieldEnum[]
  }

  /**
   * SystemSettings create
   */
  export type SystemSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The data needed to create a SystemSettings.
     */
    data: XOR<SystemSettingsCreateInput, SystemSettingsUncheckedCreateInput>
  }

  /**
   * SystemSettings createMany
   */
  export type SystemSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingsCreateManyInput | SystemSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSettings createManyAndReturn
   */
  export type SystemSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many SystemSettings.
     */
    data: SystemSettingsCreateManyInput | SystemSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SystemSettings update
   */
  export type SystemSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The data needed to update a SystemSettings.
     */
    data: XOR<SystemSettingsUpdateInput, SystemSettingsUncheckedUpdateInput>
    /**
     * Choose, which SystemSettings to update.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings updateMany
   */
  export type SystemSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingsUpdateManyMutationInput, SystemSettingsUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingsWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSettings updateManyAndReturn
   */
  export type SystemSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The data used to update SystemSettings.
     */
    data: XOR<SystemSettingsUpdateManyMutationInput, SystemSettingsUncheckedUpdateManyInput>
    /**
     * Filter which SystemSettings to update
     */
    where?: SystemSettingsWhereInput
    /**
     * Limit how many SystemSettings to update.
     */
    limit?: number
  }

  /**
   * SystemSettings upsert
   */
  export type SystemSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * The filter to search for the SystemSettings to update in case it exists.
     */
    where: SystemSettingsWhereUniqueInput
    /**
     * In case the SystemSettings found by the `where` argument doesn't exist, create a new SystemSettings with this data.
     */
    create: XOR<SystemSettingsCreateInput, SystemSettingsUncheckedCreateInput>
    /**
     * In case the SystemSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SystemSettingsUpdateInput, SystemSettingsUncheckedUpdateInput>
  }

  /**
   * SystemSettings delete
   */
  export type SystemSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
    /**
     * Filter which SystemSettings to delete.
     */
    where: SystemSettingsWhereUniqueInput
  }

  /**
   * SystemSettings deleteMany
   */
  export type SystemSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SystemSettings to delete
     */
    where?: SystemSettingsWhereInput
    /**
     * Limit how many SystemSettings to delete.
     */
    limit?: number
  }

  /**
   * SystemSettings without action
   */
  export type SystemSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SystemSettings
     */
    select?: SystemSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SystemSettings
     */
    omit?: SystemSettingsOmit<ExtArgs> | null
  }


  /**
   * Model Transaction
   */

  export type AggregateTransaction = {
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  export type TransactionAvgAggregateOutputType = {
    amount: Decimal | null
    exchange_rate: Decimal | null
  }

  export type TransactionSumAggregateOutputType = {
    amount: Decimal | null
    exchange_rate: Decimal | null
  }

  export type TransactionMinAggregateOutputType = {
    id: string | null
    type: $Enums.TransactionType | null
    category: string | null
    amount: Decimal | null
    currency: string | null
    exchange_rate: Decimal | null
    date: Date | null
    description: string | null
    notes: string | null
    payment_method: string | null
    reference_number: string | null
    attachment_url: string | null
    tax_rate_id: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TransactionMaxAggregateOutputType = {
    id: string | null
    type: $Enums.TransactionType | null
    category: string | null
    amount: Decimal | null
    currency: string | null
    exchange_rate: Decimal | null
    date: Date | null
    description: string | null
    notes: string | null
    payment_method: string | null
    reference_number: string | null
    attachment_url: string | null
    tax_rate_id: string | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type TransactionCountAggregateOutputType = {
    id: number
    type: number
    category: number
    amount: number
    currency: number
    exchange_rate: number
    date: number
    description: number
    notes: number
    payment_method: number
    reference_number: number
    attachment_url: number
    tax_rate_id: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type TransactionAvgAggregateInputType = {
    amount?: true
    exchange_rate?: true
  }

  export type TransactionSumAggregateInputType = {
    amount?: true
    exchange_rate?: true
  }

  export type TransactionMinAggregateInputType = {
    id?: true
    type?: true
    category?: true
    amount?: true
    currency?: true
    exchange_rate?: true
    date?: true
    description?: true
    notes?: true
    payment_method?: true
    reference_number?: true
    attachment_url?: true
    tax_rate_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type TransactionMaxAggregateInputType = {
    id?: true
    type?: true
    category?: true
    amount?: true
    currency?: true
    exchange_rate?: true
    date?: true
    description?: true
    notes?: true
    payment_method?: true
    reference_number?: true
    attachment_url?: true
    tax_rate_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type TransactionCountAggregateInputType = {
    id?: true
    type?: true
    category?: true
    amount?: true
    currency?: true
    exchange_rate?: true
    date?: true
    description?: true
    notes?: true
    payment_method?: true
    reference_number?: true
    attachment_url?: true
    tax_rate_id?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type TransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transaction to aggregate.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Transactions
    **/
    _count?: true | TransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TransactionMaxAggregateInputType
  }

  export type GetTransactionAggregateType<T extends TransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTransaction[P]>
      : GetScalarType<T[P], AggregateTransaction[P]>
  }




  export type TransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TransactionWhereInput
    orderBy?: TransactionOrderByWithAggregationInput | TransactionOrderByWithAggregationInput[]
    by: TransactionScalarFieldEnum[] | TransactionScalarFieldEnum
    having?: TransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TransactionCountAggregateInputType | true
    _avg?: TransactionAvgAggregateInputType
    _sum?: TransactionSumAggregateInputType
    _min?: TransactionMinAggregateInputType
    _max?: TransactionMaxAggregateInputType
  }

  export type TransactionGroupByOutputType = {
    id: string
    type: $Enums.TransactionType
    category: string
    amount: Decimal
    currency: string
    exchange_rate: Decimal | null
    date: Date
    description: string | null
    notes: string | null
    payment_method: string | null
    reference_number: string | null
    attachment_url: string | null
    tax_rate_id: string | null
    created_by: string
    created_at: Date
    updated_at: Date
    _count: TransactionCountAggregateOutputType | null
    _avg: TransactionAvgAggregateOutputType | null
    _sum: TransactionSumAggregateOutputType | null
    _min: TransactionMinAggregateOutputType | null
    _max: TransactionMaxAggregateOutputType | null
  }

  type GetTransactionGroupByPayload<T extends TransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TransactionGroupByOutputType[P]>
            : GetScalarType<T[P], TransactionGroupByOutputType[P]>
        }
      >
    >


  export type TransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    category?: boolean
    amount?: boolean
    currency?: boolean
    exchange_rate?: boolean
    date?: boolean
    description?: boolean
    notes?: boolean
    payment_method?: boolean
    reference_number?: boolean
    attachment_url?: boolean
    tax_rate_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    category?: boolean
    amount?: boolean
    currency?: boolean
    exchange_rate?: boolean
    date?: boolean
    description?: boolean
    notes?: boolean
    payment_method?: boolean
    reference_number?: boolean
    attachment_url?: boolean
    tax_rate_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    type?: boolean
    category?: boolean
    amount?: boolean
    currency?: boolean
    exchange_rate?: boolean
    date?: boolean
    description?: boolean
    notes?: boolean
    payment_method?: boolean
    reference_number?: boolean
    attachment_url?: boolean
    tax_rate_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["transaction"]>

  export type TransactionSelectScalar = {
    id?: boolean
    type?: boolean
    category?: boolean
    amount?: boolean
    currency?: boolean
    exchange_rate?: boolean
    date?: boolean
    description?: boolean
    notes?: boolean
    payment_method?: boolean
    reference_number?: boolean
    attachment_url?: boolean
    tax_rate_id?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type TransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "type" | "category" | "amount" | "currency" | "exchange_rate" | "date" | "description" | "notes" | "payment_method" | "reference_number" | "attachment_url" | "tax_rate_id" | "created_by" | "created_at" | "updated_at", ExtArgs["result"]["transaction"]>
  export type TransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Transaction"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      type: $Enums.TransactionType
      category: string
      amount: Prisma.Decimal
      currency: string
      exchange_rate: Prisma.Decimal | null
      date: Date
      description: string | null
      notes: string | null
      payment_method: string | null
      reference_number: string | null
      attachment_url: string | null
      tax_rate_id: string | null
      created_by: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["transaction"]>
    composites: {}
  }

  type TransactionGetPayload<S extends boolean | null | undefined | TransactionDefaultArgs> = $Result.GetResult<Prisma.$TransactionPayload, S>

  type TransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TransactionCountAggregateInputType | true
    }

  export interface TransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Transaction'], meta: { name: 'Transaction' } }
    /**
     * Find zero or one Transaction that matches the filter.
     * @param {TransactionFindUniqueArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TransactionFindUniqueArgs>(args: SelectSubset<T, TransactionFindUniqueArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Transaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TransactionFindUniqueOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, TransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TransactionFindFirstArgs>(args?: SelectSubset<T, TransactionFindFirstArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Transaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindFirstOrThrowArgs} args - Arguments to find a Transaction
     * @example
     * // Get one Transaction
     * const transaction = await prisma.transaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, TransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Transactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Transactions
     * const transactions = await prisma.transaction.findMany()
     * 
     * // Get first 10 Transactions
     * const transactions = await prisma.transaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const transactionWithIdOnly = await prisma.transaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TransactionFindManyArgs>(args?: SelectSubset<T, TransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Transaction.
     * @param {TransactionCreateArgs} args - Arguments to create a Transaction.
     * @example
     * // Create one Transaction
     * const Transaction = await prisma.transaction.create({
     *   data: {
     *     // ... data to create a Transaction
     *   }
     * })
     * 
     */
    create<T extends TransactionCreateArgs>(args: SelectSubset<T, TransactionCreateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Transactions.
     * @param {TransactionCreateManyArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TransactionCreateManyArgs>(args?: SelectSubset<T, TransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Transactions and returns the data saved in the database.
     * @param {TransactionCreateManyAndReturnArgs} args - Arguments to create many Transactions.
     * @example
     * // Create many Transactions
     * const transaction = await prisma.transaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, TransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Transaction.
     * @param {TransactionDeleteArgs} args - Arguments to delete one Transaction.
     * @example
     * // Delete one Transaction
     * const Transaction = await prisma.transaction.delete({
     *   where: {
     *     // ... filter to delete one Transaction
     *   }
     * })
     * 
     */
    delete<T extends TransactionDeleteArgs>(args: SelectSubset<T, TransactionDeleteArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Transaction.
     * @param {TransactionUpdateArgs} args - Arguments to update one Transaction.
     * @example
     * // Update one Transaction
     * const transaction = await prisma.transaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TransactionUpdateArgs>(args: SelectSubset<T, TransactionUpdateArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Transactions.
     * @param {TransactionDeleteManyArgs} args - Arguments to filter Transactions to delete.
     * @example
     * // Delete a few Transactions
     * const { count } = await prisma.transaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TransactionDeleteManyArgs>(args?: SelectSubset<T, TransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TransactionUpdateManyArgs>(args: SelectSubset<T, TransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Transactions and returns the data updated in the database.
     * @param {TransactionUpdateManyAndReturnArgs} args - Arguments to update many Transactions.
     * @example
     * // Update many Transactions
     * const transaction = await prisma.transaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Transactions and only return the `id`
     * const transactionWithIdOnly = await prisma.transaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, TransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Transaction.
     * @param {TransactionUpsertArgs} args - Arguments to update or create a Transaction.
     * @example
     * // Update or create a Transaction
     * const transaction = await prisma.transaction.upsert({
     *   create: {
     *     // ... data to create a Transaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Transaction we want to update
     *   }
     * })
     */
    upsert<T extends TransactionUpsertArgs>(args: SelectSubset<T, TransactionUpsertArgs<ExtArgs>>): Prisma__TransactionClient<$Result.GetResult<Prisma.$TransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Transactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionCountArgs} args - Arguments to filter Transactions to count.
     * @example
     * // Count the number of Transactions
     * const count = await prisma.transaction.count({
     *   where: {
     *     // ... the filter for the Transactions we want to count
     *   }
     * })
    **/
    count<T extends TransactionCountArgs>(
      args?: Subset<T, TransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TransactionAggregateArgs>(args: Subset<T, TransactionAggregateArgs>): Prisma.PrismaPromise<GetTransactionAggregateType<T>>

    /**
     * Group by Transaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TransactionGroupByArgs['orderBy'] }
        : { orderBy?: TransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Transaction model
   */
  readonly fields: TransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Transaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Transaction model
   */
  interface TransactionFieldRefs {
    readonly id: FieldRef<"Transaction", 'String'>
    readonly type: FieldRef<"Transaction", 'TransactionType'>
    readonly category: FieldRef<"Transaction", 'String'>
    readonly amount: FieldRef<"Transaction", 'Decimal'>
    readonly currency: FieldRef<"Transaction", 'String'>
    readonly exchange_rate: FieldRef<"Transaction", 'Decimal'>
    readonly date: FieldRef<"Transaction", 'DateTime'>
    readonly description: FieldRef<"Transaction", 'String'>
    readonly notes: FieldRef<"Transaction", 'String'>
    readonly payment_method: FieldRef<"Transaction", 'String'>
    readonly reference_number: FieldRef<"Transaction", 'String'>
    readonly attachment_url: FieldRef<"Transaction", 'String'>
    readonly tax_rate_id: FieldRef<"Transaction", 'String'>
    readonly created_by: FieldRef<"Transaction", 'String'>
    readonly created_at: FieldRef<"Transaction", 'DateTime'>
    readonly updated_at: FieldRef<"Transaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Transaction findUnique
   */
  export type TransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findUniqueOrThrow
   */
  export type TransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction findFirst
   */
  export type TransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findFirstOrThrow
   */
  export type TransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transaction to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Transactions.
     */
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction findMany
   */
  export type TransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter, which Transactions to fetch.
     */
    where?: TransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Transactions to fetch.
     */
    orderBy?: TransactionOrderByWithRelationInput | TransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Transactions.
     */
    cursor?: TransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Transactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Transactions.
     */
    skip?: number
    distinct?: TransactionScalarFieldEnum | TransactionScalarFieldEnum[]
  }

  /**
   * Transaction create
   */
  export type TransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a Transaction.
     */
    data: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
  }

  /**
   * Transaction createMany
   */
  export type TransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Transaction createManyAndReturn
   */
  export type TransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to create many Transactions.
     */
    data: TransactionCreateManyInput | TransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction update
   */
  export type TransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a Transaction.
     */
    data: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
    /**
     * Choose, which Transaction to update.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction updateMany
   */
  export type TransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
  }

  /**
   * Transaction updateManyAndReturn
   */
  export type TransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * The data used to update Transactions.
     */
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyInput>
    /**
     * Filter which Transactions to update
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Transaction upsert
   */
  export type TransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the Transaction to update in case it exists.
     */
    where: TransactionWhereUniqueInput
    /**
     * In case the Transaction found by the `where` argument doesn't exist, create a new Transaction with this data.
     */
    create: XOR<TransactionCreateInput, TransactionUncheckedCreateInput>
    /**
     * In case the Transaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TransactionUpdateInput, TransactionUncheckedUpdateInput>
  }

  /**
   * Transaction delete
   */
  export type TransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
    /**
     * Filter which Transaction to delete.
     */
    where: TransactionWhereUniqueInput
  }

  /**
   * Transaction deleteMany
   */
  export type TransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Transactions to delete
     */
    where?: TransactionWhereInput
    /**
     * Limit how many Transactions to delete.
     */
    limit?: number
  }

  /**
   * Transaction without action
   */
  export type TransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Transaction
     */
    select?: TransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Transaction
     */
    omit?: TransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TransactionInclude<ExtArgs> | null
  }


  /**
   * Model InventoryItem
   */

  export type AggregateInventoryItem = {
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  export type InventoryItemAvgAggregateOutputType = {
    current_stock: number | null
    min_stock: number | null
    cost_price: Decimal | null
  }

  export type InventoryItemSumAggregateOutputType = {
    current_stock: number | null
    min_stock: number | null
    cost_price: Decimal | null
  }

  export type InventoryItemMinAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    category: string | null
    unit: string | null
    current_stock: number | null
    min_stock: number | null
    cost_price: Decimal | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type InventoryItemMaxAggregateOutputType = {
    id: string | null
    code: string | null
    name: string | null
    category: string | null
    unit: string | null
    current_stock: number | null
    min_stock: number | null
    cost_price: Decimal | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type InventoryItemCountAggregateOutputType = {
    id: number
    code: number
    name: number
    category: number
    unit: number
    current_stock: number
    min_stock: number
    cost_price: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type InventoryItemAvgAggregateInputType = {
    current_stock?: true
    min_stock?: true
    cost_price?: true
  }

  export type InventoryItemSumAggregateInputType = {
    current_stock?: true
    min_stock?: true
    cost_price?: true
  }

  export type InventoryItemMinAggregateInputType = {
    id?: true
    code?: true
    name?: true
    category?: true
    unit?: true
    current_stock?: true
    min_stock?: true
    cost_price?: true
    created_at?: true
    updated_at?: true
  }

  export type InventoryItemMaxAggregateInputType = {
    id?: true
    code?: true
    name?: true
    category?: true
    unit?: true
    current_stock?: true
    min_stock?: true
    cost_price?: true
    created_at?: true
    updated_at?: true
  }

  export type InventoryItemCountAggregateInputType = {
    id?: true
    code?: true
    name?: true
    category?: true
    unit?: true
    current_stock?: true
    min_stock?: true
    cost_price?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type InventoryItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItem to aggregate.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryItems
    **/
    _count?: true | InventoryItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryItemMaxAggregateInputType
  }

  export type GetInventoryItemAggregateType<T extends InventoryItemAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryItem[P]>
      : GetScalarType<T[P], AggregateInventoryItem[P]>
  }




  export type InventoryItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryItemWhereInput
    orderBy?: InventoryItemOrderByWithAggregationInput | InventoryItemOrderByWithAggregationInput[]
    by: InventoryItemScalarFieldEnum[] | InventoryItemScalarFieldEnum
    having?: InventoryItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryItemCountAggregateInputType | true
    _avg?: InventoryItemAvgAggregateInputType
    _sum?: InventoryItemSumAggregateInputType
    _min?: InventoryItemMinAggregateInputType
    _max?: InventoryItemMaxAggregateInputType
  }

  export type InventoryItemGroupByOutputType = {
    id: string
    code: string
    name: string
    category: string
    unit: string
    current_stock: number
    min_stock: number | null
    cost_price: Decimal | null
    created_at: Date
    updated_at: Date
    _count: InventoryItemCountAggregateOutputType | null
    _avg: InventoryItemAvgAggregateOutputType | null
    _sum: InventoryItemSumAggregateOutputType | null
    _min: InventoryItemMinAggregateOutputType | null
    _max: InventoryItemMaxAggregateOutputType | null
  }

  type GetInventoryItemGroupByPayload<T extends InventoryItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryItemGroupByOutputType[P]>
        }
      >
    >


  export type InventoryItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    unit?: boolean
    current_stock?: boolean
    min_stock?: boolean
    cost_price?: boolean
    created_at?: boolean
    updated_at?: boolean
    transactions?: boolean | InventoryItem$transactionsArgs<ExtArgs>
    _count?: boolean | InventoryItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    unit?: boolean
    current_stock?: boolean
    min_stock?: boolean
    cost_price?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    unit?: boolean
    current_stock?: boolean
    min_stock?: boolean
    cost_price?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["inventoryItem"]>

  export type InventoryItemSelectScalar = {
    id?: boolean
    code?: boolean
    name?: boolean
    category?: boolean
    unit?: boolean
    current_stock?: boolean
    min_stock?: boolean
    cost_price?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type InventoryItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "code" | "name" | "category" | "unit" | "current_stock" | "min_stock" | "cost_price" | "created_at" | "updated_at", ExtArgs["result"]["inventoryItem"]>
  export type InventoryItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | InventoryItem$transactionsArgs<ExtArgs>
    _count?: boolean | InventoryItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type InventoryItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type InventoryItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $InventoryItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryItem"
    objects: {
      transactions: Prisma.$InventoryTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      code: string
      name: string
      category: string
      unit: string
      current_stock: number
      min_stock: number | null
      cost_price: Prisma.Decimal | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["inventoryItem"]>
    composites: {}
  }

  type InventoryItemGetPayload<S extends boolean | null | undefined | InventoryItemDefaultArgs> = $Result.GetResult<Prisma.$InventoryItemPayload, S>

  type InventoryItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryItemCountAggregateInputType | true
    }

  export interface InventoryItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryItem'], meta: { name: 'InventoryItem' } }
    /**
     * Find zero or one InventoryItem that matches the filter.
     * @param {InventoryItemFindUniqueArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryItemFindUniqueArgs>(args: SelectSubset<T, InventoryItemFindUniqueArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryItemFindUniqueOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryItemFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryItemFindFirstArgs>(args?: SelectSubset<T, InventoryItemFindFirstArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindFirstOrThrowArgs} args - Arguments to find a InventoryItem
     * @example
     * // Get one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryItemFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany()
     * 
     * // Get first 10 InventoryItems
     * const inventoryItems = await prisma.inventoryItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryItemFindManyArgs>(args?: SelectSubset<T, InventoryItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryItem.
     * @param {InventoryItemCreateArgs} args - Arguments to create a InventoryItem.
     * @example
     * // Create one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.create({
     *   data: {
     *     // ... data to create a InventoryItem
     *   }
     * })
     * 
     */
    create<T extends InventoryItemCreateArgs>(args: SelectSubset<T, InventoryItemCreateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryItems.
     * @param {InventoryItemCreateManyArgs} args - Arguments to create many InventoryItems.
     * @example
     * // Create many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryItemCreateManyArgs>(args?: SelectSubset<T, InventoryItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryItems and returns the data saved in the database.
     * @param {InventoryItemCreateManyAndReturnArgs} args - Arguments to create many InventoryItems.
     * @example
     * // Create many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryItems and only return the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryItemCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventoryItem.
     * @param {InventoryItemDeleteArgs} args - Arguments to delete one InventoryItem.
     * @example
     * // Delete one InventoryItem
     * const InventoryItem = await prisma.inventoryItem.delete({
     *   where: {
     *     // ... filter to delete one InventoryItem
     *   }
     * })
     * 
     */
    delete<T extends InventoryItemDeleteArgs>(args: SelectSubset<T, InventoryItemDeleteArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryItem.
     * @param {InventoryItemUpdateArgs} args - Arguments to update one InventoryItem.
     * @example
     * // Update one InventoryItem
     * const inventoryItem = await prisma.inventoryItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryItemUpdateArgs>(args: SelectSubset<T, InventoryItemUpdateArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryItems.
     * @param {InventoryItemDeleteManyArgs} args - Arguments to filter InventoryItems to delete.
     * @example
     * // Delete a few InventoryItems
     * const { count } = await prisma.inventoryItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryItemDeleteManyArgs>(args?: SelectSubset<T, InventoryItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryItemUpdateManyArgs>(args: SelectSubset<T, InventoryItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryItems and returns the data updated in the database.
     * @param {InventoryItemUpdateManyAndReturnArgs} args - Arguments to update many InventoryItems.
     * @example
     * // Update many InventoryItems
     * const inventoryItem = await prisma.inventoryItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventoryItems and only return the `id`
     * const inventoryItemWithIdOnly = await prisma.inventoryItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryItemUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventoryItem.
     * @param {InventoryItemUpsertArgs} args - Arguments to update or create a InventoryItem.
     * @example
     * // Update or create a InventoryItem
     * const inventoryItem = await prisma.inventoryItem.upsert({
     *   create: {
     *     // ... data to create a InventoryItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryItem we want to update
     *   }
     * })
     */
    upsert<T extends InventoryItemUpsertArgs>(args: SelectSubset<T, InventoryItemUpsertArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemCountArgs} args - Arguments to filter InventoryItems to count.
     * @example
     * // Count the number of InventoryItems
     * const count = await prisma.inventoryItem.count({
     *   where: {
     *     // ... the filter for the InventoryItems we want to count
     *   }
     * })
    **/
    count<T extends InventoryItemCountArgs>(
      args?: Subset<T, InventoryItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryItemAggregateArgs>(args: Subset<T, InventoryItemAggregateArgs>): Prisma.PrismaPromise<GetInventoryItemAggregateType<T>>

    /**
     * Group by InventoryItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryItemGroupByArgs['orderBy'] }
        : { orderBy?: InventoryItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryItem model
   */
  readonly fields: InventoryItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends InventoryItem$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItem$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryItem model
   */
  interface InventoryItemFieldRefs {
    readonly id: FieldRef<"InventoryItem", 'String'>
    readonly code: FieldRef<"InventoryItem", 'String'>
    readonly name: FieldRef<"InventoryItem", 'String'>
    readonly category: FieldRef<"InventoryItem", 'String'>
    readonly unit: FieldRef<"InventoryItem", 'String'>
    readonly current_stock: FieldRef<"InventoryItem", 'Float'>
    readonly min_stock: FieldRef<"InventoryItem", 'Float'>
    readonly cost_price: FieldRef<"InventoryItem", 'Decimal'>
    readonly created_at: FieldRef<"InventoryItem", 'DateTime'>
    readonly updated_at: FieldRef<"InventoryItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryItem findUnique
   */
  export type InventoryItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findUniqueOrThrow
   */
  export type InventoryItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem findFirst
   */
  export type InventoryItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findFirstOrThrow
   */
  export type InventoryItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItem to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryItems.
     */
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem findMany
   */
  export type InventoryItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter, which InventoryItems to fetch.
     */
    where?: InventoryItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryItems to fetch.
     */
    orderBy?: InventoryItemOrderByWithRelationInput | InventoryItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryItems.
     */
    cursor?: InventoryItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryItems.
     */
    skip?: number
    distinct?: InventoryItemScalarFieldEnum | InventoryItemScalarFieldEnum[]
  }

  /**
   * InventoryItem create
   */
  export type InventoryItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryItem.
     */
    data: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
  }

  /**
   * InventoryItem createMany
   */
  export type InventoryItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryItems.
     */
    data: InventoryItemCreateManyInput | InventoryItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryItem createManyAndReturn
   */
  export type InventoryItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * The data used to create many InventoryItems.
     */
    data: InventoryItemCreateManyInput | InventoryItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryItem update
   */
  export type InventoryItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryItem.
     */
    data: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
    /**
     * Choose, which InventoryItem to update.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem updateMany
   */
  export type InventoryItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryItems.
     */
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyInput>
    /**
     * Filter which InventoryItems to update
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to update.
     */
    limit?: number
  }

  /**
   * InventoryItem updateManyAndReturn
   */
  export type InventoryItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * The data used to update InventoryItems.
     */
    data: XOR<InventoryItemUpdateManyMutationInput, InventoryItemUncheckedUpdateManyInput>
    /**
     * Filter which InventoryItems to update
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to update.
     */
    limit?: number
  }

  /**
   * InventoryItem upsert
   */
  export type InventoryItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryItem to update in case it exists.
     */
    where: InventoryItemWhereUniqueInput
    /**
     * In case the InventoryItem found by the `where` argument doesn't exist, create a new InventoryItem with this data.
     */
    create: XOR<InventoryItemCreateInput, InventoryItemUncheckedCreateInput>
    /**
     * In case the InventoryItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryItemUpdateInput, InventoryItemUncheckedUpdateInput>
  }

  /**
   * InventoryItem delete
   */
  export type InventoryItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
    /**
     * Filter which InventoryItem to delete.
     */
    where: InventoryItemWhereUniqueInput
  }

  /**
   * InventoryItem deleteMany
   */
  export type InventoryItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryItems to delete
     */
    where?: InventoryItemWhereInput
    /**
     * Limit how many InventoryItems to delete.
     */
    limit?: number
  }

  /**
   * InventoryItem.transactions
   */
  export type InventoryItem$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    where?: InventoryTransactionWhereInput
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    cursor?: InventoryTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InventoryTransactionScalarFieldEnum | InventoryTransactionScalarFieldEnum[]
  }

  /**
   * InventoryItem without action
   */
  export type InventoryItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryItem
     */
    select?: InventoryItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryItem
     */
    omit?: InventoryItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryItemInclude<ExtArgs> | null
  }


  /**
   * Model InventoryTransaction
   */

  export type AggregateInventoryTransaction = {
    _count: InventoryTransactionCountAggregateOutputType | null
    _avg: InventoryTransactionAvgAggregateOutputType | null
    _sum: InventoryTransactionSumAggregateOutputType | null
    _min: InventoryTransactionMinAggregateOutputType | null
    _max: InventoryTransactionMaxAggregateOutputType | null
  }

  export type InventoryTransactionAvgAggregateOutputType = {
    quantity: number | null
  }

  export type InventoryTransactionSumAggregateOutputType = {
    quantity: number | null
  }

  export type InventoryTransactionMinAggregateOutputType = {
    id: string | null
    item_id: string | null
    project_id: string | null
    type: $Enums.InventoryTransactionType | null
    quantity: number | null
    date: Date | null
    reference_no: string | null
    notes: string | null
    created_by: string | null
    created_at: Date | null
  }

  export type InventoryTransactionMaxAggregateOutputType = {
    id: string | null
    item_id: string | null
    project_id: string | null
    type: $Enums.InventoryTransactionType | null
    quantity: number | null
    date: Date | null
    reference_no: string | null
    notes: string | null
    created_by: string | null
    created_at: Date | null
  }

  export type InventoryTransactionCountAggregateOutputType = {
    id: number
    item_id: number
    project_id: number
    type: number
    quantity: number
    date: number
    reference_no: number
    notes: number
    created_by: number
    created_at: number
    _all: number
  }


  export type InventoryTransactionAvgAggregateInputType = {
    quantity?: true
  }

  export type InventoryTransactionSumAggregateInputType = {
    quantity?: true
  }

  export type InventoryTransactionMinAggregateInputType = {
    id?: true
    item_id?: true
    project_id?: true
    type?: true
    quantity?: true
    date?: true
    reference_no?: true
    notes?: true
    created_by?: true
    created_at?: true
  }

  export type InventoryTransactionMaxAggregateInputType = {
    id?: true
    item_id?: true
    project_id?: true
    type?: true
    quantity?: true
    date?: true
    reference_no?: true
    notes?: true
    created_by?: true
    created_at?: true
  }

  export type InventoryTransactionCountAggregateInputType = {
    id?: true
    item_id?: true
    project_id?: true
    type?: true
    quantity?: true
    date?: true
    reference_no?: true
    notes?: true
    created_by?: true
    created_at?: true
    _all?: true
  }

  export type InventoryTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryTransaction to aggregate.
     */
    where?: InventoryTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryTransactions to fetch.
     */
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InventoryTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InventoryTransactions
    **/
    _count?: true | InventoryTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InventoryTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InventoryTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InventoryTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InventoryTransactionMaxAggregateInputType
  }

  export type GetInventoryTransactionAggregateType<T extends InventoryTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateInventoryTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInventoryTransaction[P]>
      : GetScalarType<T[P], AggregateInventoryTransaction[P]>
  }




  export type InventoryTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InventoryTransactionWhereInput
    orderBy?: InventoryTransactionOrderByWithAggregationInput | InventoryTransactionOrderByWithAggregationInput[]
    by: InventoryTransactionScalarFieldEnum[] | InventoryTransactionScalarFieldEnum
    having?: InventoryTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InventoryTransactionCountAggregateInputType | true
    _avg?: InventoryTransactionAvgAggregateInputType
    _sum?: InventoryTransactionSumAggregateInputType
    _min?: InventoryTransactionMinAggregateInputType
    _max?: InventoryTransactionMaxAggregateInputType
  }

  export type InventoryTransactionGroupByOutputType = {
    id: string
    item_id: string
    project_id: string | null
    type: $Enums.InventoryTransactionType
    quantity: number
    date: Date
    reference_no: string | null
    notes: string | null
    created_by: string
    created_at: Date
    _count: InventoryTransactionCountAggregateOutputType | null
    _avg: InventoryTransactionAvgAggregateOutputType | null
    _sum: InventoryTransactionSumAggregateOutputType | null
    _min: InventoryTransactionMinAggregateOutputType | null
    _max: InventoryTransactionMaxAggregateOutputType | null
  }

  type GetInventoryTransactionGroupByPayload<T extends InventoryTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InventoryTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InventoryTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InventoryTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], InventoryTransactionGroupByOutputType[P]>
        }
      >
    >


  export type InventoryTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item_id?: boolean
    project_id?: boolean
    type?: boolean
    quantity?: boolean
    date?: boolean
    reference_no?: boolean
    notes?: boolean
    created_by?: boolean
    created_at?: boolean
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
    project?: boolean | InventoryTransaction$projectArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryTransaction"]>

  export type InventoryTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item_id?: boolean
    project_id?: boolean
    type?: boolean
    quantity?: boolean
    date?: boolean
    reference_no?: boolean
    notes?: boolean
    created_by?: boolean
    created_at?: boolean
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
    project?: boolean | InventoryTransaction$projectArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryTransaction"]>

  export type InventoryTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    item_id?: boolean
    project_id?: boolean
    type?: boolean
    quantity?: boolean
    date?: boolean
    reference_no?: boolean
    notes?: boolean
    created_by?: boolean
    created_at?: boolean
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
    project?: boolean | InventoryTransaction$projectArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["inventoryTransaction"]>

  export type InventoryTransactionSelectScalar = {
    id?: boolean
    item_id?: boolean
    project_id?: boolean
    type?: boolean
    quantity?: boolean
    date?: boolean
    reference_no?: boolean
    notes?: boolean
    created_by?: boolean
    created_at?: boolean
  }

  export type InventoryTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "item_id" | "project_id" | "type" | "quantity" | "date" | "reference_no" | "notes" | "created_by" | "created_at", ExtArgs["result"]["inventoryTransaction"]>
  export type InventoryTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
    project?: boolean | InventoryTransaction$projectArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InventoryTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
    project?: boolean | InventoryTransaction$projectArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type InventoryTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | InventoryItemDefaultArgs<ExtArgs>
    project?: boolean | InventoryTransaction$projectArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $InventoryTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InventoryTransaction"
    objects: {
      item: Prisma.$InventoryItemPayload<ExtArgs>
      project: Prisma.$ProjectPayload<ExtArgs> | null
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      item_id: string
      project_id: string | null
      type: $Enums.InventoryTransactionType
      quantity: number
      date: Date
      reference_no: string | null
      notes: string | null
      created_by: string
      created_at: Date
    }, ExtArgs["result"]["inventoryTransaction"]>
    composites: {}
  }

  type InventoryTransactionGetPayload<S extends boolean | null | undefined | InventoryTransactionDefaultArgs> = $Result.GetResult<Prisma.$InventoryTransactionPayload, S>

  type InventoryTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<InventoryTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: InventoryTransactionCountAggregateInputType | true
    }

  export interface InventoryTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InventoryTransaction'], meta: { name: 'InventoryTransaction' } }
    /**
     * Find zero or one InventoryTransaction that matches the filter.
     * @param {InventoryTransactionFindUniqueArgs} args - Arguments to find a InventoryTransaction
     * @example
     * // Get one InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InventoryTransactionFindUniqueArgs>(args: SelectSubset<T, InventoryTransactionFindUniqueArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one InventoryTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {InventoryTransactionFindUniqueOrThrowArgs} args - Arguments to find a InventoryTransaction
     * @example
     * // Get one InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InventoryTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, InventoryTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionFindFirstArgs} args - Arguments to find a InventoryTransaction
     * @example
     * // Get one InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InventoryTransactionFindFirstArgs>(args?: SelectSubset<T, InventoryTransactionFindFirstArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first InventoryTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionFindFirstOrThrowArgs} args - Arguments to find a InventoryTransaction
     * @example
     * // Get one InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InventoryTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, InventoryTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more InventoryTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InventoryTransactions
     * const inventoryTransactions = await prisma.inventoryTransaction.findMany()
     * 
     * // Get first 10 InventoryTransactions
     * const inventoryTransactions = await prisma.inventoryTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inventoryTransactionWithIdOnly = await prisma.inventoryTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InventoryTransactionFindManyArgs>(args?: SelectSubset<T, InventoryTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a InventoryTransaction.
     * @param {InventoryTransactionCreateArgs} args - Arguments to create a InventoryTransaction.
     * @example
     * // Create one InventoryTransaction
     * const InventoryTransaction = await prisma.inventoryTransaction.create({
     *   data: {
     *     // ... data to create a InventoryTransaction
     *   }
     * })
     * 
     */
    create<T extends InventoryTransactionCreateArgs>(args: SelectSubset<T, InventoryTransactionCreateArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many InventoryTransactions.
     * @param {InventoryTransactionCreateManyArgs} args - Arguments to create many InventoryTransactions.
     * @example
     * // Create many InventoryTransactions
     * const inventoryTransaction = await prisma.inventoryTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InventoryTransactionCreateManyArgs>(args?: SelectSubset<T, InventoryTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InventoryTransactions and returns the data saved in the database.
     * @param {InventoryTransactionCreateManyAndReturnArgs} args - Arguments to create many InventoryTransactions.
     * @example
     * // Create many InventoryTransactions
     * const inventoryTransaction = await prisma.inventoryTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InventoryTransactions and only return the `id`
     * const inventoryTransactionWithIdOnly = await prisma.inventoryTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InventoryTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, InventoryTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a InventoryTransaction.
     * @param {InventoryTransactionDeleteArgs} args - Arguments to delete one InventoryTransaction.
     * @example
     * // Delete one InventoryTransaction
     * const InventoryTransaction = await prisma.inventoryTransaction.delete({
     *   where: {
     *     // ... filter to delete one InventoryTransaction
     *   }
     * })
     * 
     */
    delete<T extends InventoryTransactionDeleteArgs>(args: SelectSubset<T, InventoryTransactionDeleteArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one InventoryTransaction.
     * @param {InventoryTransactionUpdateArgs} args - Arguments to update one InventoryTransaction.
     * @example
     * // Update one InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InventoryTransactionUpdateArgs>(args: SelectSubset<T, InventoryTransactionUpdateArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more InventoryTransactions.
     * @param {InventoryTransactionDeleteManyArgs} args - Arguments to filter InventoryTransactions to delete.
     * @example
     * // Delete a few InventoryTransactions
     * const { count } = await prisma.inventoryTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InventoryTransactionDeleteManyArgs>(args?: SelectSubset<T, InventoryTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InventoryTransactions
     * const inventoryTransaction = await prisma.inventoryTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InventoryTransactionUpdateManyArgs>(args: SelectSubset<T, InventoryTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InventoryTransactions and returns the data updated in the database.
     * @param {InventoryTransactionUpdateManyAndReturnArgs} args - Arguments to update many InventoryTransactions.
     * @example
     * // Update many InventoryTransactions
     * const inventoryTransaction = await prisma.inventoryTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more InventoryTransactions and only return the `id`
     * const inventoryTransactionWithIdOnly = await prisma.inventoryTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends InventoryTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, InventoryTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one InventoryTransaction.
     * @param {InventoryTransactionUpsertArgs} args - Arguments to update or create a InventoryTransaction.
     * @example
     * // Update or create a InventoryTransaction
     * const inventoryTransaction = await prisma.inventoryTransaction.upsert({
     *   create: {
     *     // ... data to create a InventoryTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InventoryTransaction we want to update
     *   }
     * })
     */
    upsert<T extends InventoryTransactionUpsertArgs>(args: SelectSubset<T, InventoryTransactionUpsertArgs<ExtArgs>>): Prisma__InventoryTransactionClient<$Result.GetResult<Prisma.$InventoryTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of InventoryTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionCountArgs} args - Arguments to filter InventoryTransactions to count.
     * @example
     * // Count the number of InventoryTransactions
     * const count = await prisma.inventoryTransaction.count({
     *   where: {
     *     // ... the filter for the InventoryTransactions we want to count
     *   }
     * })
    **/
    count<T extends InventoryTransactionCountArgs>(
      args?: Subset<T, InventoryTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InventoryTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InventoryTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InventoryTransactionAggregateArgs>(args: Subset<T, InventoryTransactionAggregateArgs>): Prisma.PrismaPromise<GetInventoryTransactionAggregateType<T>>

    /**
     * Group by InventoryTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InventoryTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InventoryTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InventoryTransactionGroupByArgs['orderBy'] }
        : { orderBy?: InventoryTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InventoryTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInventoryTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InventoryTransaction model
   */
  readonly fields: InventoryTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InventoryTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InventoryTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends InventoryItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, InventoryItemDefaultArgs<ExtArgs>>): Prisma__InventoryItemClient<$Result.GetResult<Prisma.$InventoryItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    project<T extends InventoryTransaction$projectArgs<ExtArgs> = {}>(args?: Subset<T, InventoryTransaction$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InventoryTransaction model
   */
  interface InventoryTransactionFieldRefs {
    readonly id: FieldRef<"InventoryTransaction", 'String'>
    readonly item_id: FieldRef<"InventoryTransaction", 'String'>
    readonly project_id: FieldRef<"InventoryTransaction", 'String'>
    readonly type: FieldRef<"InventoryTransaction", 'InventoryTransactionType'>
    readonly quantity: FieldRef<"InventoryTransaction", 'Float'>
    readonly date: FieldRef<"InventoryTransaction", 'DateTime'>
    readonly reference_no: FieldRef<"InventoryTransaction", 'String'>
    readonly notes: FieldRef<"InventoryTransaction", 'String'>
    readonly created_by: FieldRef<"InventoryTransaction", 'String'>
    readonly created_at: FieldRef<"InventoryTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InventoryTransaction findUnique
   */
  export type InventoryTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryTransaction to fetch.
     */
    where: InventoryTransactionWhereUniqueInput
  }

  /**
   * InventoryTransaction findUniqueOrThrow
   */
  export type InventoryTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryTransaction to fetch.
     */
    where: InventoryTransactionWhereUniqueInput
  }

  /**
   * InventoryTransaction findFirst
   */
  export type InventoryTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryTransaction to fetch.
     */
    where?: InventoryTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryTransactions to fetch.
     */
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryTransactions.
     */
    cursor?: InventoryTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryTransactions.
     */
    distinct?: InventoryTransactionScalarFieldEnum | InventoryTransactionScalarFieldEnum[]
  }

  /**
   * InventoryTransaction findFirstOrThrow
   */
  export type InventoryTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryTransaction to fetch.
     */
    where?: InventoryTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryTransactions to fetch.
     */
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InventoryTransactions.
     */
    cursor?: InventoryTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InventoryTransactions.
     */
    distinct?: InventoryTransactionScalarFieldEnum | InventoryTransactionScalarFieldEnum[]
  }

  /**
   * InventoryTransaction findMany
   */
  export type InventoryTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter, which InventoryTransactions to fetch.
     */
    where?: InventoryTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InventoryTransactions to fetch.
     */
    orderBy?: InventoryTransactionOrderByWithRelationInput | InventoryTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InventoryTransactions.
     */
    cursor?: InventoryTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InventoryTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InventoryTransactions.
     */
    skip?: number
    distinct?: InventoryTransactionScalarFieldEnum | InventoryTransactionScalarFieldEnum[]
  }

  /**
   * InventoryTransaction create
   */
  export type InventoryTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a InventoryTransaction.
     */
    data: XOR<InventoryTransactionCreateInput, InventoryTransactionUncheckedCreateInput>
  }

  /**
   * InventoryTransaction createMany
   */
  export type InventoryTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InventoryTransactions.
     */
    data: InventoryTransactionCreateManyInput | InventoryTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InventoryTransaction createManyAndReturn
   */
  export type InventoryTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many InventoryTransactions.
     */
    data: InventoryTransactionCreateManyInput | InventoryTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryTransaction update
   */
  export type InventoryTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a InventoryTransaction.
     */
    data: XOR<InventoryTransactionUpdateInput, InventoryTransactionUncheckedUpdateInput>
    /**
     * Choose, which InventoryTransaction to update.
     */
    where: InventoryTransactionWhereUniqueInput
  }

  /**
   * InventoryTransaction updateMany
   */
  export type InventoryTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InventoryTransactions.
     */
    data: XOR<InventoryTransactionUpdateManyMutationInput, InventoryTransactionUncheckedUpdateManyInput>
    /**
     * Filter which InventoryTransactions to update
     */
    where?: InventoryTransactionWhereInput
    /**
     * Limit how many InventoryTransactions to update.
     */
    limit?: number
  }

  /**
   * InventoryTransaction updateManyAndReturn
   */
  export type InventoryTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * The data used to update InventoryTransactions.
     */
    data: XOR<InventoryTransactionUpdateManyMutationInput, InventoryTransactionUncheckedUpdateManyInput>
    /**
     * Filter which InventoryTransactions to update
     */
    where?: InventoryTransactionWhereInput
    /**
     * Limit how many InventoryTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * InventoryTransaction upsert
   */
  export type InventoryTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the InventoryTransaction to update in case it exists.
     */
    where: InventoryTransactionWhereUniqueInput
    /**
     * In case the InventoryTransaction found by the `where` argument doesn't exist, create a new InventoryTransaction with this data.
     */
    create: XOR<InventoryTransactionCreateInput, InventoryTransactionUncheckedCreateInput>
    /**
     * In case the InventoryTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InventoryTransactionUpdateInput, InventoryTransactionUncheckedUpdateInput>
  }

  /**
   * InventoryTransaction delete
   */
  export type InventoryTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
    /**
     * Filter which InventoryTransaction to delete.
     */
    where: InventoryTransactionWhereUniqueInput
  }

  /**
   * InventoryTransaction deleteMany
   */
  export type InventoryTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InventoryTransactions to delete
     */
    where?: InventoryTransactionWhereInput
    /**
     * Limit how many InventoryTransactions to delete.
     */
    limit?: number
  }

  /**
   * InventoryTransaction.project
   */
  export type InventoryTransaction$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * InventoryTransaction without action
   */
  export type InventoryTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InventoryTransaction
     */
    select?: InventoryTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the InventoryTransaction
     */
    omit?: InventoryTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InventoryTransactionInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseRequest
   */

  export type AggregatePurchaseRequest = {
    _count: PurchaseRequestCountAggregateOutputType | null
    _avg: PurchaseRequestAvgAggregateOutputType | null
    _sum: PurchaseRequestSumAggregateOutputType | null
    _min: PurchaseRequestMinAggregateOutputType | null
    _max: PurchaseRequestMaxAggregateOutputType | null
  }

  export type PurchaseRequestAvgAggregateOutputType = {
    quantity: number | null
    estimated_cost: Decimal | null
  }

  export type PurchaseRequestSumAggregateOutputType = {
    quantity: number | null
    estimated_cost: Decimal | null
  }

  export type PurchaseRequestMinAggregateOutputType = {
    id: string | null
    project_id: string | null
    item_name: string | null
    quantity: number | null
    unit: string | null
    estimated_cost: Decimal | null
    priority: $Enums.PriorityLevel | null
    status: $Enums.PurchaseStatus | null
    requested_by: string | null
    needed_by: Date | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PurchaseRequestMaxAggregateOutputType = {
    id: string | null
    project_id: string | null
    item_name: string | null
    quantity: number | null
    unit: string | null
    estimated_cost: Decimal | null
    priority: $Enums.PriorityLevel | null
    status: $Enums.PurchaseStatus | null
    requested_by: string | null
    needed_by: Date | null
    notes: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PurchaseRequestCountAggregateOutputType = {
    id: number
    project_id: number
    item_name: number
    quantity: number
    unit: number
    estimated_cost: number
    priority: number
    status: number
    requested_by: number
    needed_by: number
    notes: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PurchaseRequestAvgAggregateInputType = {
    quantity?: true
    estimated_cost?: true
  }

  export type PurchaseRequestSumAggregateInputType = {
    quantity?: true
    estimated_cost?: true
  }

  export type PurchaseRequestMinAggregateInputType = {
    id?: true
    project_id?: true
    item_name?: true
    quantity?: true
    unit?: true
    estimated_cost?: true
    priority?: true
    status?: true
    requested_by?: true
    needed_by?: true
    notes?: true
    created_at?: true
    updated_at?: true
  }

  export type PurchaseRequestMaxAggregateInputType = {
    id?: true
    project_id?: true
    item_name?: true
    quantity?: true
    unit?: true
    estimated_cost?: true
    priority?: true
    status?: true
    requested_by?: true
    needed_by?: true
    notes?: true
    created_at?: true
    updated_at?: true
  }

  export type PurchaseRequestCountAggregateInputType = {
    id?: true
    project_id?: true
    item_name?: true
    quantity?: true
    unit?: true
    estimated_cost?: true
    priority?: true
    status?: true
    requested_by?: true
    needed_by?: true
    notes?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PurchaseRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseRequest to aggregate.
     */
    where?: PurchaseRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseRequests to fetch.
     */
    orderBy?: PurchaseRequestOrderByWithRelationInput | PurchaseRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseRequests
    **/
    _count?: true | PurchaseRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseRequestMaxAggregateInputType
  }

  export type GetPurchaseRequestAggregateType<T extends PurchaseRequestAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseRequest[P]>
      : GetScalarType<T[P], AggregatePurchaseRequest[P]>
  }




  export type PurchaseRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseRequestWhereInput
    orderBy?: PurchaseRequestOrderByWithAggregationInput | PurchaseRequestOrderByWithAggregationInput[]
    by: PurchaseRequestScalarFieldEnum[] | PurchaseRequestScalarFieldEnum
    having?: PurchaseRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseRequestCountAggregateInputType | true
    _avg?: PurchaseRequestAvgAggregateInputType
    _sum?: PurchaseRequestSumAggregateInputType
    _min?: PurchaseRequestMinAggregateInputType
    _max?: PurchaseRequestMaxAggregateInputType
  }

  export type PurchaseRequestGroupByOutputType = {
    id: string
    project_id: string | null
    item_name: string
    quantity: number
    unit: string
    estimated_cost: Decimal | null
    priority: $Enums.PriorityLevel
    status: $Enums.PurchaseStatus
    requested_by: string
    needed_by: Date | null
    notes: string | null
    created_at: Date
    updated_at: Date
    _count: PurchaseRequestCountAggregateOutputType | null
    _avg: PurchaseRequestAvgAggregateOutputType | null
    _sum: PurchaseRequestSumAggregateOutputType | null
    _min: PurchaseRequestMinAggregateOutputType | null
    _max: PurchaseRequestMaxAggregateOutputType | null
  }

  type GetPurchaseRequestGroupByPayload<T extends PurchaseRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseRequestGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseRequestGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    project_id?: boolean
    item_name?: boolean
    quantity?: boolean
    unit?: boolean
    estimated_cost?: boolean
    priority?: boolean
    status?: boolean
    requested_by?: boolean
    needed_by?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | PurchaseRequest$projectArgs<ExtArgs>
    requester?: boolean | UserDefaultArgs<ExtArgs>
    purchase_orders?: boolean | PurchaseRequest$purchase_ordersArgs<ExtArgs>
    _count?: boolean | PurchaseRequestCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseRequest"]>

  export type PurchaseRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    project_id?: boolean
    item_name?: boolean
    quantity?: boolean
    unit?: boolean
    estimated_cost?: boolean
    priority?: boolean
    status?: boolean
    requested_by?: boolean
    needed_by?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | PurchaseRequest$projectArgs<ExtArgs>
    requester?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseRequest"]>

  export type PurchaseRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    project_id?: boolean
    item_name?: boolean
    quantity?: boolean
    unit?: boolean
    estimated_cost?: boolean
    priority?: boolean
    status?: boolean
    requested_by?: boolean
    needed_by?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
    project?: boolean | PurchaseRequest$projectArgs<ExtArgs>
    requester?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseRequest"]>

  export type PurchaseRequestSelectScalar = {
    id?: boolean
    project_id?: boolean
    item_name?: boolean
    quantity?: boolean
    unit?: boolean
    estimated_cost?: boolean
    priority?: boolean
    status?: boolean
    requested_by?: boolean
    needed_by?: boolean
    notes?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type PurchaseRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "project_id" | "item_name" | "quantity" | "unit" | "estimated_cost" | "priority" | "status" | "requested_by" | "needed_by" | "notes" | "created_at" | "updated_at", ExtArgs["result"]["purchaseRequest"]>
  export type PurchaseRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | PurchaseRequest$projectArgs<ExtArgs>
    requester?: boolean | UserDefaultArgs<ExtArgs>
    purchase_orders?: boolean | PurchaseRequest$purchase_ordersArgs<ExtArgs>
    _count?: boolean | PurchaseRequestCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | PurchaseRequest$projectArgs<ExtArgs>
    requester?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PurchaseRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    project?: boolean | PurchaseRequest$projectArgs<ExtArgs>
    requester?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PurchaseRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseRequest"
    objects: {
      project: Prisma.$ProjectPayload<ExtArgs> | null
      requester: Prisma.$UserPayload<ExtArgs>
      purchase_orders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      project_id: string | null
      item_name: string
      quantity: number
      unit: string
      estimated_cost: Prisma.Decimal | null
      priority: $Enums.PriorityLevel
      status: $Enums.PurchaseStatus
      requested_by: string
      needed_by: Date | null
      notes: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["purchaseRequest"]>
    composites: {}
  }

  type PurchaseRequestGetPayload<S extends boolean | null | undefined | PurchaseRequestDefaultArgs> = $Result.GetResult<Prisma.$PurchaseRequestPayload, S>

  type PurchaseRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseRequestCountAggregateInputType | true
    }

  export interface PurchaseRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseRequest'], meta: { name: 'PurchaseRequest' } }
    /**
     * Find zero or one PurchaseRequest that matches the filter.
     * @param {PurchaseRequestFindUniqueArgs} args - Arguments to find a PurchaseRequest
     * @example
     * // Get one PurchaseRequest
     * const purchaseRequest = await prisma.purchaseRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseRequestFindUniqueArgs>(args: SelectSubset<T, PurchaseRequestFindUniqueArgs<ExtArgs>>): Prisma__PurchaseRequestClient<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseRequestFindUniqueOrThrowArgs} args - Arguments to find a PurchaseRequest
     * @example
     * // Get one PurchaseRequest
     * const purchaseRequest = await prisma.purchaseRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseRequestClient<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseRequestFindFirstArgs} args - Arguments to find a PurchaseRequest
     * @example
     * // Get one PurchaseRequest
     * const purchaseRequest = await prisma.purchaseRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseRequestFindFirstArgs>(args?: SelectSubset<T, PurchaseRequestFindFirstArgs<ExtArgs>>): Prisma__PurchaseRequestClient<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseRequestFindFirstOrThrowArgs} args - Arguments to find a PurchaseRequest
     * @example
     * // Get one PurchaseRequest
     * const purchaseRequest = await prisma.purchaseRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseRequestClient<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseRequests
     * const purchaseRequests = await prisma.purchaseRequest.findMany()
     * 
     * // Get first 10 PurchaseRequests
     * const purchaseRequests = await prisma.purchaseRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseRequestWithIdOnly = await prisma.purchaseRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseRequestFindManyArgs>(args?: SelectSubset<T, PurchaseRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseRequest.
     * @param {PurchaseRequestCreateArgs} args - Arguments to create a PurchaseRequest.
     * @example
     * // Create one PurchaseRequest
     * const PurchaseRequest = await prisma.purchaseRequest.create({
     *   data: {
     *     // ... data to create a PurchaseRequest
     *   }
     * })
     * 
     */
    create<T extends PurchaseRequestCreateArgs>(args: SelectSubset<T, PurchaseRequestCreateArgs<ExtArgs>>): Prisma__PurchaseRequestClient<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseRequests.
     * @param {PurchaseRequestCreateManyArgs} args - Arguments to create many PurchaseRequests.
     * @example
     * // Create many PurchaseRequests
     * const purchaseRequest = await prisma.purchaseRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseRequestCreateManyArgs>(args?: SelectSubset<T, PurchaseRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseRequests and returns the data saved in the database.
     * @param {PurchaseRequestCreateManyAndReturnArgs} args - Arguments to create many PurchaseRequests.
     * @example
     * // Create many PurchaseRequests
     * const purchaseRequest = await prisma.purchaseRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseRequests and only return the `id`
     * const purchaseRequestWithIdOnly = await prisma.purchaseRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseRequest.
     * @param {PurchaseRequestDeleteArgs} args - Arguments to delete one PurchaseRequest.
     * @example
     * // Delete one PurchaseRequest
     * const PurchaseRequest = await prisma.purchaseRequest.delete({
     *   where: {
     *     // ... filter to delete one PurchaseRequest
     *   }
     * })
     * 
     */
    delete<T extends PurchaseRequestDeleteArgs>(args: SelectSubset<T, PurchaseRequestDeleteArgs<ExtArgs>>): Prisma__PurchaseRequestClient<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseRequest.
     * @param {PurchaseRequestUpdateArgs} args - Arguments to update one PurchaseRequest.
     * @example
     * // Update one PurchaseRequest
     * const purchaseRequest = await prisma.purchaseRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseRequestUpdateArgs>(args: SelectSubset<T, PurchaseRequestUpdateArgs<ExtArgs>>): Prisma__PurchaseRequestClient<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseRequests.
     * @param {PurchaseRequestDeleteManyArgs} args - Arguments to filter PurchaseRequests to delete.
     * @example
     * // Delete a few PurchaseRequests
     * const { count } = await prisma.purchaseRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseRequestDeleteManyArgs>(args?: SelectSubset<T, PurchaseRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseRequests
     * const purchaseRequest = await prisma.purchaseRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseRequestUpdateManyArgs>(args: SelectSubset<T, PurchaseRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseRequests and returns the data updated in the database.
     * @param {PurchaseRequestUpdateManyAndReturnArgs} args - Arguments to update many PurchaseRequests.
     * @example
     * // Update many PurchaseRequests
     * const purchaseRequest = await prisma.purchaseRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseRequests and only return the `id`
     * const purchaseRequestWithIdOnly = await prisma.purchaseRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseRequest.
     * @param {PurchaseRequestUpsertArgs} args - Arguments to update or create a PurchaseRequest.
     * @example
     * // Update or create a PurchaseRequest
     * const purchaseRequest = await prisma.purchaseRequest.upsert({
     *   create: {
     *     // ... data to create a PurchaseRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseRequest we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseRequestUpsertArgs>(args: SelectSubset<T, PurchaseRequestUpsertArgs<ExtArgs>>): Prisma__PurchaseRequestClient<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseRequestCountArgs} args - Arguments to filter PurchaseRequests to count.
     * @example
     * // Count the number of PurchaseRequests
     * const count = await prisma.purchaseRequest.count({
     *   where: {
     *     // ... the filter for the PurchaseRequests we want to count
     *   }
     * })
    **/
    count<T extends PurchaseRequestCountArgs>(
      args?: Subset<T, PurchaseRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseRequestAggregateArgs>(args: Subset<T, PurchaseRequestAggregateArgs>): Prisma.PrismaPromise<GetPurchaseRequestAggregateType<T>>

    /**
     * Group by PurchaseRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseRequestGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseRequest model
   */
  readonly fields: PurchaseRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    project<T extends PurchaseRequest$projectArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseRequest$projectArgs<ExtArgs>>): Prisma__ProjectClient<$Result.GetResult<Prisma.$ProjectPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    requester<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    purchase_orders<T extends PurchaseRequest$purchase_ordersArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseRequest$purchase_ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseRequest model
   */
  interface PurchaseRequestFieldRefs {
    readonly id: FieldRef<"PurchaseRequest", 'String'>
    readonly project_id: FieldRef<"PurchaseRequest", 'String'>
    readonly item_name: FieldRef<"PurchaseRequest", 'String'>
    readonly quantity: FieldRef<"PurchaseRequest", 'Float'>
    readonly unit: FieldRef<"PurchaseRequest", 'String'>
    readonly estimated_cost: FieldRef<"PurchaseRequest", 'Decimal'>
    readonly priority: FieldRef<"PurchaseRequest", 'PriorityLevel'>
    readonly status: FieldRef<"PurchaseRequest", 'PurchaseStatus'>
    readonly requested_by: FieldRef<"PurchaseRequest", 'String'>
    readonly needed_by: FieldRef<"PurchaseRequest", 'DateTime'>
    readonly notes: FieldRef<"PurchaseRequest", 'String'>
    readonly created_at: FieldRef<"PurchaseRequest", 'DateTime'>
    readonly updated_at: FieldRef<"PurchaseRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseRequest findUnique
   */
  export type PurchaseRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseRequest
     */
    omit?: PurchaseRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseRequest to fetch.
     */
    where: PurchaseRequestWhereUniqueInput
  }

  /**
   * PurchaseRequest findUniqueOrThrow
   */
  export type PurchaseRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseRequest
     */
    omit?: PurchaseRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseRequest to fetch.
     */
    where: PurchaseRequestWhereUniqueInput
  }

  /**
   * PurchaseRequest findFirst
   */
  export type PurchaseRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseRequest
     */
    omit?: PurchaseRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseRequest to fetch.
     */
    where?: PurchaseRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseRequests to fetch.
     */
    orderBy?: PurchaseRequestOrderByWithRelationInput | PurchaseRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseRequests.
     */
    cursor?: PurchaseRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseRequests.
     */
    distinct?: PurchaseRequestScalarFieldEnum | PurchaseRequestScalarFieldEnum[]
  }

  /**
   * PurchaseRequest findFirstOrThrow
   */
  export type PurchaseRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseRequest
     */
    omit?: PurchaseRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseRequest to fetch.
     */
    where?: PurchaseRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseRequests to fetch.
     */
    orderBy?: PurchaseRequestOrderByWithRelationInput | PurchaseRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseRequests.
     */
    cursor?: PurchaseRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseRequests.
     */
    distinct?: PurchaseRequestScalarFieldEnum | PurchaseRequestScalarFieldEnum[]
  }

  /**
   * PurchaseRequest findMany
   */
  export type PurchaseRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseRequest
     */
    omit?: PurchaseRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseRequests to fetch.
     */
    where?: PurchaseRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseRequests to fetch.
     */
    orderBy?: PurchaseRequestOrderByWithRelationInput | PurchaseRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseRequests.
     */
    cursor?: PurchaseRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseRequests.
     */
    skip?: number
    distinct?: PurchaseRequestScalarFieldEnum | PurchaseRequestScalarFieldEnum[]
  }

  /**
   * PurchaseRequest create
   */
  export type PurchaseRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseRequest
     */
    omit?: PurchaseRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseRequest.
     */
    data: XOR<PurchaseRequestCreateInput, PurchaseRequestUncheckedCreateInput>
  }

  /**
   * PurchaseRequest createMany
   */
  export type PurchaseRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseRequests.
     */
    data: PurchaseRequestCreateManyInput | PurchaseRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseRequest createManyAndReturn
   */
  export type PurchaseRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseRequest
     */
    omit?: PurchaseRequestOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseRequests.
     */
    data: PurchaseRequestCreateManyInput | PurchaseRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseRequest update
   */
  export type PurchaseRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseRequest
     */
    omit?: PurchaseRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseRequest.
     */
    data: XOR<PurchaseRequestUpdateInput, PurchaseRequestUncheckedUpdateInput>
    /**
     * Choose, which PurchaseRequest to update.
     */
    where: PurchaseRequestWhereUniqueInput
  }

  /**
   * PurchaseRequest updateMany
   */
  export type PurchaseRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseRequests.
     */
    data: XOR<PurchaseRequestUpdateManyMutationInput, PurchaseRequestUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseRequests to update
     */
    where?: PurchaseRequestWhereInput
    /**
     * Limit how many PurchaseRequests to update.
     */
    limit?: number
  }

  /**
   * PurchaseRequest updateManyAndReturn
   */
  export type PurchaseRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseRequest
     */
    omit?: PurchaseRequestOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseRequests.
     */
    data: XOR<PurchaseRequestUpdateManyMutationInput, PurchaseRequestUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseRequests to update
     */
    where?: PurchaseRequestWhereInput
    /**
     * Limit how many PurchaseRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseRequest upsert
   */
  export type PurchaseRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseRequest
     */
    omit?: PurchaseRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseRequest to update in case it exists.
     */
    where: PurchaseRequestWhereUniqueInput
    /**
     * In case the PurchaseRequest found by the `where` argument doesn't exist, create a new PurchaseRequest with this data.
     */
    create: XOR<PurchaseRequestCreateInput, PurchaseRequestUncheckedCreateInput>
    /**
     * In case the PurchaseRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseRequestUpdateInput, PurchaseRequestUncheckedUpdateInput>
  }

  /**
   * PurchaseRequest delete
   */
  export type PurchaseRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseRequest
     */
    omit?: PurchaseRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
    /**
     * Filter which PurchaseRequest to delete.
     */
    where: PurchaseRequestWhereUniqueInput
  }

  /**
   * PurchaseRequest deleteMany
   */
  export type PurchaseRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseRequests to delete
     */
    where?: PurchaseRequestWhereInput
    /**
     * Limit how many PurchaseRequests to delete.
     */
    limit?: number
  }

  /**
   * PurchaseRequest.project
   */
  export type PurchaseRequest$projectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Project
     */
    select?: ProjectSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Project
     */
    omit?: ProjectOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProjectInclude<ExtArgs> | null
    where?: ProjectWhereInput
  }

  /**
   * PurchaseRequest.purchase_orders
   */
  export type PurchaseRequest$purchase_ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseRequest without action
   */
  export type PurchaseRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseRequest
     */
    omit?: PurchaseRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
  }


  /**
   * Model Vendor
   */

  export type AggregateVendor = {
    _count: VendorCountAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  export type VendorMinAggregateOutputType = {
    id: string | null
    name: string | null
    contact_person: string | null
    email: string | null
    phone: string | null
    address: string | null
    vat_no: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VendorMaxAggregateOutputType = {
    id: string | null
    name: string | null
    contact_person: string | null
    email: string | null
    phone: string | null
    address: string | null
    vat_no: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VendorCountAggregateOutputType = {
    id: number
    name: number
    contact_person: number
    email: number
    phone: number
    address: number
    vat_no: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type VendorMinAggregateInputType = {
    id?: true
    name?: true
    contact_person?: true
    email?: true
    phone?: true
    address?: true
    vat_no?: true
    created_at?: true
    updated_at?: true
  }

  export type VendorMaxAggregateInputType = {
    id?: true
    name?: true
    contact_person?: true
    email?: true
    phone?: true
    address?: true
    vat_no?: true
    created_at?: true
    updated_at?: true
  }

  export type VendorCountAggregateInputType = {
    id?: true
    name?: true
    contact_person?: true
    email?: true
    phone?: true
    address?: true
    vat_no?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type VendorAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendor to aggregate.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Vendors
    **/
    _count?: true | VendorCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorMaxAggregateInputType
  }

  export type GetVendorAggregateType<T extends VendorAggregateArgs> = {
        [P in keyof T & keyof AggregateVendor]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendor[P]>
      : GetScalarType<T[P], AggregateVendor[P]>
  }




  export type VendorGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorWhereInput
    orderBy?: VendorOrderByWithAggregationInput | VendorOrderByWithAggregationInput[]
    by: VendorScalarFieldEnum[] | VendorScalarFieldEnum
    having?: VendorScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorCountAggregateInputType | true
    _min?: VendorMinAggregateInputType
    _max?: VendorMaxAggregateInputType
  }

  export type VendorGroupByOutputType = {
    id: string
    name: string
    contact_person: string | null
    email: string | null
    phone: string | null
    address: string | null
    vat_no: string | null
    created_at: Date
    updated_at: Date
    _count: VendorCountAggregateOutputType | null
    _min: VendorMinAggregateOutputType | null
    _max: VendorMaxAggregateOutputType | null
  }

  type GetVendorGroupByPayload<T extends VendorGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorGroupByOutputType[P]>
            : GetScalarType<T[P], VendorGroupByOutputType[P]>
        }
      >
    >


  export type VendorSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contact_person?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    vat_no?: boolean
    created_at?: boolean
    updated_at?: boolean
    purchase_orders?: boolean | Vendor$purchase_ordersArgs<ExtArgs>
    vendor_bills?: boolean | Vendor$vendor_billsArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contact_person?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    vat_no?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    contact_person?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    vat_no?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["vendor"]>

  export type VendorSelectScalar = {
    id?: boolean
    name?: boolean
    contact_person?: boolean
    email?: boolean
    phone?: boolean
    address?: boolean
    vat_no?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type VendorOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "contact_person" | "email" | "phone" | "address" | "vat_no" | "created_at" | "updated_at", ExtArgs["result"]["vendor"]>
  export type VendorInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase_orders?: boolean | Vendor$purchase_ordersArgs<ExtArgs>
    vendor_bills?: boolean | Vendor$vendor_billsArgs<ExtArgs>
    _count?: boolean | VendorCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VendorIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type VendorIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $VendorPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Vendor"
    objects: {
      purchase_orders: Prisma.$PurchaseOrderPayload<ExtArgs>[]
      vendor_bills: Prisma.$VendorBillPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      contact_person: string | null
      email: string | null
      phone: string | null
      address: string | null
      vat_no: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["vendor"]>
    composites: {}
  }

  type VendorGetPayload<S extends boolean | null | undefined | VendorDefaultArgs> = $Result.GetResult<Prisma.$VendorPayload, S>

  type VendorCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorCountAggregateInputType | true
    }

  export interface VendorDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Vendor'], meta: { name: 'Vendor' } }
    /**
     * Find zero or one Vendor that matches the filter.
     * @param {VendorFindUniqueArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorFindUniqueArgs>(args: SelectSubset<T, VendorFindUniqueArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vendor that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorFindUniqueOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vendor that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorFindFirstArgs>(args?: SelectSubset<T, VendorFindFirstArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vendor that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindFirstOrThrowArgs} args - Arguments to find a Vendor
     * @example
     * // Get one Vendor
     * const vendor = await prisma.vendor.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vendors that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vendors
     * const vendors = await prisma.vendor.findMany()
     * 
     * // Get first 10 Vendors
     * const vendors = await prisma.vendor.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorWithIdOnly = await prisma.vendor.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorFindManyArgs>(args?: SelectSubset<T, VendorFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vendor.
     * @param {VendorCreateArgs} args - Arguments to create a Vendor.
     * @example
     * // Create one Vendor
     * const Vendor = await prisma.vendor.create({
     *   data: {
     *     // ... data to create a Vendor
     *   }
     * })
     * 
     */
    create<T extends VendorCreateArgs>(args: SelectSubset<T, VendorCreateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vendors.
     * @param {VendorCreateManyArgs} args - Arguments to create many Vendors.
     * @example
     * // Create many Vendors
     * const vendor = await prisma.vendor.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorCreateManyArgs>(args?: SelectSubset<T, VendorCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Vendors and returns the data saved in the database.
     * @param {VendorCreateManyAndReturnArgs} args - Arguments to create many Vendors.
     * @example
     * // Create many Vendors
     * const vendor = await prisma.vendor.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Vendors and only return the `id`
     * const vendorWithIdOnly = await prisma.vendor.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Vendor.
     * @param {VendorDeleteArgs} args - Arguments to delete one Vendor.
     * @example
     * // Delete one Vendor
     * const Vendor = await prisma.vendor.delete({
     *   where: {
     *     // ... filter to delete one Vendor
     *   }
     * })
     * 
     */
    delete<T extends VendorDeleteArgs>(args: SelectSubset<T, VendorDeleteArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vendor.
     * @param {VendorUpdateArgs} args - Arguments to update one Vendor.
     * @example
     * // Update one Vendor
     * const vendor = await prisma.vendor.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorUpdateArgs>(args: SelectSubset<T, VendorUpdateArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vendors.
     * @param {VendorDeleteManyArgs} args - Arguments to filter Vendors to delete.
     * @example
     * // Delete a few Vendors
     * const { count } = await prisma.vendor.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorDeleteManyArgs>(args?: SelectSubset<T, VendorDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vendors
     * const vendor = await prisma.vendor.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorUpdateManyArgs>(args: SelectSubset<T, VendorUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vendors and returns the data updated in the database.
     * @param {VendorUpdateManyAndReturnArgs} args - Arguments to update many Vendors.
     * @example
     * // Update many Vendors
     * const vendor = await prisma.vendor.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Vendors and only return the `id`
     * const vendorWithIdOnly = await prisma.vendor.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VendorUpdateManyAndReturnArgs>(args: SelectSubset<T, VendorUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Vendor.
     * @param {VendorUpsertArgs} args - Arguments to update or create a Vendor.
     * @example
     * // Update or create a Vendor
     * const vendor = await prisma.vendor.upsert({
     *   create: {
     *     // ... data to create a Vendor
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vendor we want to update
     *   }
     * })
     */
    upsert<T extends VendorUpsertArgs>(args: SelectSubset<T, VendorUpsertArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Vendors.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorCountArgs} args - Arguments to filter Vendors to count.
     * @example
     * // Count the number of Vendors
     * const count = await prisma.vendor.count({
     *   where: {
     *     // ... the filter for the Vendors we want to count
     *   }
     * })
    **/
    count<T extends VendorCountArgs>(
      args?: Subset<T, VendorCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorAggregateArgs>(args: Subset<T, VendorAggregateArgs>): Prisma.PrismaPromise<GetVendorAggregateType<T>>

    /**
     * Group by Vendor.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorGroupByArgs['orderBy'] }
        : { orderBy?: VendorGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Vendor model
   */
  readonly fields: VendorFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Vendor.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchase_orders<T extends Vendor$purchase_ordersArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$purchase_ordersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vendor_bills<T extends Vendor$vendor_billsArgs<ExtArgs> = {}>(args?: Subset<T, Vendor$vendor_billsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorBillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Vendor model
   */
  interface VendorFieldRefs {
    readonly id: FieldRef<"Vendor", 'String'>
    readonly name: FieldRef<"Vendor", 'String'>
    readonly contact_person: FieldRef<"Vendor", 'String'>
    readonly email: FieldRef<"Vendor", 'String'>
    readonly phone: FieldRef<"Vendor", 'String'>
    readonly address: FieldRef<"Vendor", 'String'>
    readonly vat_no: FieldRef<"Vendor", 'String'>
    readonly created_at: FieldRef<"Vendor", 'DateTime'>
    readonly updated_at: FieldRef<"Vendor", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Vendor findUnique
   */
  export type VendorFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findUniqueOrThrow
   */
  export type VendorFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor findFirst
   */
  export type VendorFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findFirstOrThrow
   */
  export type VendorFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendor to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Vendors.
     */
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor findMany
   */
  export type VendorFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter, which Vendors to fetch.
     */
    where?: VendorWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Vendors to fetch.
     */
    orderBy?: VendorOrderByWithRelationInput | VendorOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Vendors.
     */
    cursor?: VendorWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Vendors from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Vendors.
     */
    skip?: number
    distinct?: VendorScalarFieldEnum | VendorScalarFieldEnum[]
  }

  /**
   * Vendor create
   */
  export type VendorCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to create a Vendor.
     */
    data: XOR<VendorCreateInput, VendorUncheckedCreateInput>
  }

  /**
   * Vendor createMany
   */
  export type VendorCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Vendors.
     */
    data: VendorCreateManyInput | VendorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vendor createManyAndReturn
   */
  export type VendorCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * The data used to create many Vendors.
     */
    data: VendorCreateManyInput | VendorCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Vendor update
   */
  export type VendorUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The data needed to update a Vendor.
     */
    data: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
    /**
     * Choose, which Vendor to update.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor updateMany
   */
  export type VendorUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Vendors.
     */
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyInput>
    /**
     * Filter which Vendors to update
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to update.
     */
    limit?: number
  }

  /**
   * Vendor updateManyAndReturn
   */
  export type VendorUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * The data used to update Vendors.
     */
    data: XOR<VendorUpdateManyMutationInput, VendorUncheckedUpdateManyInput>
    /**
     * Filter which Vendors to update
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to update.
     */
    limit?: number
  }

  /**
   * Vendor upsert
   */
  export type VendorUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * The filter to search for the Vendor to update in case it exists.
     */
    where: VendorWhereUniqueInput
    /**
     * In case the Vendor found by the `where` argument doesn't exist, create a new Vendor with this data.
     */
    create: XOR<VendorCreateInput, VendorUncheckedCreateInput>
    /**
     * In case the Vendor was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorUpdateInput, VendorUncheckedUpdateInput>
  }

  /**
   * Vendor delete
   */
  export type VendorDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
    /**
     * Filter which Vendor to delete.
     */
    where: VendorWhereUniqueInput
  }

  /**
   * Vendor deleteMany
   */
  export type VendorDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Vendors to delete
     */
    where?: VendorWhereInput
    /**
     * Limit how many Vendors to delete.
     */
    limit?: number
  }

  /**
   * Vendor.purchase_orders
   */
  export type Vendor$purchase_ordersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    cursor?: PurchaseOrderWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * Vendor.vendor_bills
   */
  export type Vendor$vendor_billsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBill
     */
    select?: VendorBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBill
     */
    omit?: VendorBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillInclude<ExtArgs> | null
    where?: VendorBillWhereInput
    orderBy?: VendorBillOrderByWithRelationInput | VendorBillOrderByWithRelationInput[]
    cursor?: VendorBillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorBillScalarFieldEnum | VendorBillScalarFieldEnum[]
  }

  /**
   * Vendor without action
   */
  export type VendorDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vendor
     */
    select?: VendorSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Vendor
     */
    omit?: VendorOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorInclude<ExtArgs> | null
  }


  /**
   * Model PurchaseOrder
   */

  export type AggregatePurchaseOrder = {
    _count: PurchaseOrderCountAggregateOutputType | null
    _avg: PurchaseOrderAvgAggregateOutputType | null
    _sum: PurchaseOrderSumAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  export type PurchaseOrderAvgAggregateOutputType = {
    total_amount: Decimal | null
  }

  export type PurchaseOrderSumAggregateOutputType = {
    total_amount: Decimal | null
  }

  export type PurchaseOrderMinAggregateOutputType = {
    id: string | null
    po_number: string | null
    purchase_request_id: string | null
    vendor_id: string | null
    total_amount: Decimal | null
    status: $Enums.PurchaseStatus | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PurchaseOrderMaxAggregateOutputType = {
    id: string | null
    po_number: string | null
    purchase_request_id: string | null
    vendor_id: string | null
    total_amount: Decimal | null
    status: $Enums.PurchaseStatus | null
    created_by: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type PurchaseOrderCountAggregateOutputType = {
    id: number
    po_number: number
    purchase_request_id: number
    vendor_id: number
    total_amount: number
    status: number
    created_by: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type PurchaseOrderAvgAggregateInputType = {
    total_amount?: true
  }

  export type PurchaseOrderSumAggregateInputType = {
    total_amount?: true
  }

  export type PurchaseOrderMinAggregateInputType = {
    id?: true
    po_number?: true
    purchase_request_id?: true
    vendor_id?: true
    total_amount?: true
    status?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type PurchaseOrderMaxAggregateInputType = {
    id?: true
    po_number?: true
    purchase_request_id?: true
    vendor_id?: true
    total_amount?: true
    status?: true
    created_by?: true
    created_at?: true
    updated_at?: true
  }

  export type PurchaseOrderCountAggregateInputType = {
    id?: true
    po_number?: true
    purchase_request_id?: true
    vendor_id?: true
    total_amount?: true
    status?: true
    created_by?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type PurchaseOrderAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrder to aggregate.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PurchaseOrders
    **/
    _count?: true | PurchaseOrderCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PurchaseOrderAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PurchaseOrderSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PurchaseOrderMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type GetPurchaseOrderAggregateType<T extends PurchaseOrderAggregateArgs> = {
        [P in keyof T & keyof AggregatePurchaseOrder]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePurchaseOrder[P]>
      : GetScalarType<T[P], AggregatePurchaseOrder[P]>
  }




  export type PurchaseOrderGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PurchaseOrderWhereInput
    orderBy?: PurchaseOrderOrderByWithAggregationInput | PurchaseOrderOrderByWithAggregationInput[]
    by: PurchaseOrderScalarFieldEnum[] | PurchaseOrderScalarFieldEnum
    having?: PurchaseOrderScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PurchaseOrderCountAggregateInputType | true
    _avg?: PurchaseOrderAvgAggregateInputType
    _sum?: PurchaseOrderSumAggregateInputType
    _min?: PurchaseOrderMinAggregateInputType
    _max?: PurchaseOrderMaxAggregateInputType
  }

  export type PurchaseOrderGroupByOutputType = {
    id: string
    po_number: string
    purchase_request_id: string | null
    vendor_id: string
    total_amount: Decimal
    status: $Enums.PurchaseStatus
    created_by: string
    created_at: Date
    updated_at: Date
    _count: PurchaseOrderCountAggregateOutputType | null
    _avg: PurchaseOrderAvgAggregateOutputType | null
    _sum: PurchaseOrderSumAggregateOutputType | null
    _min: PurchaseOrderMinAggregateOutputType | null
    _max: PurchaseOrderMaxAggregateOutputType | null
  }

  type GetPurchaseOrderGroupByPayload<T extends PurchaseOrderGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PurchaseOrderGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PurchaseOrderGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
            : GetScalarType<T[P], PurchaseOrderGroupByOutputType[P]>
        }
      >
    >


  export type PurchaseOrderSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    po_number?: boolean
    purchase_request_id?: boolean
    vendor_id?: boolean
    total_amount?: boolean
    status?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    purchase_request?: boolean | PurchaseOrder$purchase_requestArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    grns?: boolean | PurchaseOrder$grnsArgs<ExtArgs>
    vendor_bills?: boolean | PurchaseOrder$vendor_billsArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    po_number?: boolean
    purchase_request_id?: boolean
    vendor_id?: boolean
    total_amount?: boolean
    status?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    purchase_request?: boolean | PurchaseOrder$purchase_requestArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    po_number?: boolean
    purchase_request_id?: boolean
    vendor_id?: boolean
    total_amount?: boolean
    status?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
    purchase_request?: boolean | PurchaseOrder$purchase_requestArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["purchaseOrder"]>

  export type PurchaseOrderSelectScalar = {
    id?: boolean
    po_number?: boolean
    purchase_request_id?: boolean
    vendor_id?: boolean
    total_amount?: boolean
    status?: boolean
    created_by?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type PurchaseOrderOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "po_number" | "purchase_request_id" | "vendor_id" | "total_amount" | "status" | "created_by" | "created_at" | "updated_at", ExtArgs["result"]["purchaseOrder"]>
  export type PurchaseOrderInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase_request?: boolean | PurchaseOrder$purchase_requestArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
    grns?: boolean | PurchaseOrder$grnsArgs<ExtArgs>
    vendor_bills?: boolean | PurchaseOrder$vendor_billsArgs<ExtArgs>
    _count?: boolean | PurchaseOrderCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase_request?: boolean | PurchaseOrder$purchase_requestArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type PurchaseOrderIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase_request?: boolean | PurchaseOrder$purchase_requestArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    creator?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $PurchaseOrderPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PurchaseOrder"
    objects: {
      purchase_request: Prisma.$PurchaseRequestPayload<ExtArgs> | null
      vendor: Prisma.$VendorPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs>
      grns: Prisma.$GRNPayload<ExtArgs>[]
      vendor_bills: Prisma.$VendorBillPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      po_number: string
      purchase_request_id: string | null
      vendor_id: string
      total_amount: Prisma.Decimal
      status: $Enums.PurchaseStatus
      created_by: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["purchaseOrder"]>
    composites: {}
  }

  type PurchaseOrderGetPayload<S extends boolean | null | undefined | PurchaseOrderDefaultArgs> = $Result.GetResult<Prisma.$PurchaseOrderPayload, S>

  type PurchaseOrderCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PurchaseOrderFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PurchaseOrderCountAggregateInputType | true
    }

  export interface PurchaseOrderDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PurchaseOrder'], meta: { name: 'PurchaseOrder' } }
    /**
     * Find zero or one PurchaseOrder that matches the filter.
     * @param {PurchaseOrderFindUniqueArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PurchaseOrderFindUniqueArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PurchaseOrder that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PurchaseOrderFindUniqueOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PurchaseOrderFindUniqueOrThrowArgs>(args: SelectSubset<T, PurchaseOrderFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrder that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PurchaseOrderFindFirstArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PurchaseOrder that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindFirstOrThrowArgs} args - Arguments to find a PurchaseOrder
     * @example
     * // Get one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PurchaseOrderFindFirstOrThrowArgs>(args?: SelectSubset<T, PurchaseOrderFindFirstOrThrowArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PurchaseOrders that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany()
     * 
     * // Get first 10 PurchaseOrders
     * const purchaseOrders = await prisma.purchaseOrder.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PurchaseOrderFindManyArgs>(args?: SelectSubset<T, PurchaseOrderFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PurchaseOrder.
     * @param {PurchaseOrderCreateArgs} args - Arguments to create a PurchaseOrder.
     * @example
     * // Create one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.create({
     *   data: {
     *     // ... data to create a PurchaseOrder
     *   }
     * })
     * 
     */
    create<T extends PurchaseOrderCreateArgs>(args: SelectSubset<T, PurchaseOrderCreateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PurchaseOrders.
     * @param {PurchaseOrderCreateManyArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PurchaseOrderCreateManyArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PurchaseOrders and returns the data saved in the database.
     * @param {PurchaseOrderCreateManyAndReturnArgs} args - Arguments to create many PurchaseOrders.
     * @example
     * // Create many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PurchaseOrders and only return the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PurchaseOrderCreateManyAndReturnArgs>(args?: SelectSubset<T, PurchaseOrderCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PurchaseOrder.
     * @param {PurchaseOrderDeleteArgs} args - Arguments to delete one PurchaseOrder.
     * @example
     * // Delete one PurchaseOrder
     * const PurchaseOrder = await prisma.purchaseOrder.delete({
     *   where: {
     *     // ... filter to delete one PurchaseOrder
     *   }
     * })
     * 
     */
    delete<T extends PurchaseOrderDeleteArgs>(args: SelectSubset<T, PurchaseOrderDeleteArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PurchaseOrder.
     * @param {PurchaseOrderUpdateArgs} args - Arguments to update one PurchaseOrder.
     * @example
     * // Update one PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PurchaseOrderUpdateArgs>(args: SelectSubset<T, PurchaseOrderUpdateArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PurchaseOrders.
     * @param {PurchaseOrderDeleteManyArgs} args - Arguments to filter PurchaseOrders to delete.
     * @example
     * // Delete a few PurchaseOrders
     * const { count } = await prisma.purchaseOrder.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PurchaseOrderDeleteManyArgs>(args?: SelectSubset<T, PurchaseOrderDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PurchaseOrderUpdateManyArgs>(args: SelectSubset<T, PurchaseOrderUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PurchaseOrders and returns the data updated in the database.
     * @param {PurchaseOrderUpdateManyAndReturnArgs} args - Arguments to update many PurchaseOrders.
     * @example
     * // Update many PurchaseOrders
     * const purchaseOrder = await prisma.purchaseOrder.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PurchaseOrders and only return the `id`
     * const purchaseOrderWithIdOnly = await prisma.purchaseOrder.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PurchaseOrderUpdateManyAndReturnArgs>(args: SelectSubset<T, PurchaseOrderUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PurchaseOrder.
     * @param {PurchaseOrderUpsertArgs} args - Arguments to update or create a PurchaseOrder.
     * @example
     * // Update or create a PurchaseOrder
     * const purchaseOrder = await prisma.purchaseOrder.upsert({
     *   create: {
     *     // ... data to create a PurchaseOrder
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PurchaseOrder we want to update
     *   }
     * })
     */
    upsert<T extends PurchaseOrderUpsertArgs>(args: SelectSubset<T, PurchaseOrderUpsertArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PurchaseOrders.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderCountArgs} args - Arguments to filter PurchaseOrders to count.
     * @example
     * // Count the number of PurchaseOrders
     * const count = await prisma.purchaseOrder.count({
     *   where: {
     *     // ... the filter for the PurchaseOrders we want to count
     *   }
     * })
    **/
    count<T extends PurchaseOrderCountArgs>(
      args?: Subset<T, PurchaseOrderCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PurchaseOrderCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PurchaseOrderAggregateArgs>(args: Subset<T, PurchaseOrderAggregateArgs>): Prisma.PrismaPromise<GetPurchaseOrderAggregateType<T>>

    /**
     * Group by PurchaseOrder.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PurchaseOrderGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PurchaseOrderGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PurchaseOrderGroupByArgs['orderBy'] }
        : { orderBy?: PurchaseOrderGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PurchaseOrderGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPurchaseOrderGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PurchaseOrder model
   */
  readonly fields: PurchaseOrderFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PurchaseOrder.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PurchaseOrderClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchase_request<T extends PurchaseOrder$purchase_requestArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$purchase_requestArgs<ExtArgs>>): Prisma__PurchaseRequestClient<$Result.GetResult<Prisma.$PurchaseRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    creator<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    grns<T extends PurchaseOrder$grnsArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$grnsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GRNPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vendor_bills<T extends PurchaseOrder$vendor_billsArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrder$vendor_billsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorBillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PurchaseOrder model
   */
  interface PurchaseOrderFieldRefs {
    readonly id: FieldRef<"PurchaseOrder", 'String'>
    readonly po_number: FieldRef<"PurchaseOrder", 'String'>
    readonly purchase_request_id: FieldRef<"PurchaseOrder", 'String'>
    readonly vendor_id: FieldRef<"PurchaseOrder", 'String'>
    readonly total_amount: FieldRef<"PurchaseOrder", 'Decimal'>
    readonly status: FieldRef<"PurchaseOrder", 'PurchaseStatus'>
    readonly created_by: FieldRef<"PurchaseOrder", 'String'>
    readonly created_at: FieldRef<"PurchaseOrder", 'DateTime'>
    readonly updated_at: FieldRef<"PurchaseOrder", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PurchaseOrder findUnique
   */
  export type PurchaseOrderFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findUniqueOrThrow
   */
  export type PurchaseOrderFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder findFirst
   */
  export type PurchaseOrderFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findFirstOrThrow
   */
  export type PurchaseOrderFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrder to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PurchaseOrders.
     */
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder findMany
   */
  export type PurchaseOrderFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter, which PurchaseOrders to fetch.
     */
    where?: PurchaseOrderWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PurchaseOrders to fetch.
     */
    orderBy?: PurchaseOrderOrderByWithRelationInput | PurchaseOrderOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PurchaseOrders.
     */
    cursor?: PurchaseOrderWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PurchaseOrders from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PurchaseOrders.
     */
    skip?: number
    distinct?: PurchaseOrderScalarFieldEnum | PurchaseOrderScalarFieldEnum[]
  }

  /**
   * PurchaseOrder create
   */
  export type PurchaseOrderCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to create a PurchaseOrder.
     */
    data: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
  }

  /**
   * PurchaseOrder createMany
   */
  export type PurchaseOrderCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PurchaseOrder createManyAndReturn
   */
  export type PurchaseOrderCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * The data used to create many PurchaseOrders.
     */
    data: PurchaseOrderCreateManyInput | PurchaseOrderCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrder update
   */
  export type PurchaseOrderUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The data needed to update a PurchaseOrder.
     */
    data: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
    /**
     * Choose, which PurchaseOrder to update.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder updateMany
   */
  export type PurchaseOrderUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PurchaseOrders.
     */
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrders to update
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to update.
     */
    limit?: number
  }

  /**
   * PurchaseOrder updateManyAndReturn
   */
  export type PurchaseOrderUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * The data used to update PurchaseOrders.
     */
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyInput>
    /**
     * Filter which PurchaseOrders to update
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * PurchaseOrder upsert
   */
  export type PurchaseOrderUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * The filter to search for the PurchaseOrder to update in case it exists.
     */
    where: PurchaseOrderWhereUniqueInput
    /**
     * In case the PurchaseOrder found by the `where` argument doesn't exist, create a new PurchaseOrder with this data.
     */
    create: XOR<PurchaseOrderCreateInput, PurchaseOrderUncheckedCreateInput>
    /**
     * In case the PurchaseOrder was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PurchaseOrderUpdateInput, PurchaseOrderUncheckedUpdateInput>
  }

  /**
   * PurchaseOrder delete
   */
  export type PurchaseOrderDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
    /**
     * Filter which PurchaseOrder to delete.
     */
    where: PurchaseOrderWhereUniqueInput
  }

  /**
   * PurchaseOrder deleteMany
   */
  export type PurchaseOrderDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PurchaseOrders to delete
     */
    where?: PurchaseOrderWhereInput
    /**
     * Limit how many PurchaseOrders to delete.
     */
    limit?: number
  }

  /**
   * PurchaseOrder.purchase_request
   */
  export type PurchaseOrder$purchase_requestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseRequest
     */
    select?: PurchaseRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseRequest
     */
    omit?: PurchaseRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseRequestInclude<ExtArgs> | null
    where?: PurchaseRequestWhereInput
  }

  /**
   * PurchaseOrder.grns
   */
  export type PurchaseOrder$grnsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRN
     */
    select?: GRNSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRN
     */
    omit?: GRNOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNInclude<ExtArgs> | null
    where?: GRNWhereInput
    orderBy?: GRNOrderByWithRelationInput | GRNOrderByWithRelationInput[]
    cursor?: GRNWhereUniqueInput
    take?: number
    skip?: number
    distinct?: GRNScalarFieldEnum | GRNScalarFieldEnum[]
  }

  /**
   * PurchaseOrder.vendor_bills
   */
  export type PurchaseOrder$vendor_billsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBill
     */
    select?: VendorBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBill
     */
    omit?: VendorBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillInclude<ExtArgs> | null
    where?: VendorBillWhereInput
    orderBy?: VendorBillOrderByWithRelationInput | VendorBillOrderByWithRelationInput[]
    cursor?: VendorBillWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorBillScalarFieldEnum | VendorBillScalarFieldEnum[]
  }

  /**
   * PurchaseOrder without action
   */
  export type PurchaseOrderDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PurchaseOrder
     */
    select?: PurchaseOrderSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PurchaseOrder
     */
    omit?: PurchaseOrderOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PurchaseOrderInclude<ExtArgs> | null
  }


  /**
   * Model GRN
   */

  export type AggregateGRN = {
    _count: GRNCountAggregateOutputType | null
    _min: GRNMinAggregateOutputType | null
    _max: GRNMaxAggregateOutputType | null
  }

  export type GRNMinAggregateOutputType = {
    id: string | null
    grn_number: string | null
    purchase_order_id: string | null
    received_date: Date | null
    received_by: string | null
    notes: string | null
    created_at: Date | null
  }

  export type GRNMaxAggregateOutputType = {
    id: string | null
    grn_number: string | null
    purchase_order_id: string | null
    received_date: Date | null
    received_by: string | null
    notes: string | null
    created_at: Date | null
  }

  export type GRNCountAggregateOutputType = {
    id: number
    grn_number: number
    purchase_order_id: number
    received_date: number
    received_by: number
    notes: number
    created_at: number
    _all: number
  }


  export type GRNMinAggregateInputType = {
    id?: true
    grn_number?: true
    purchase_order_id?: true
    received_date?: true
    received_by?: true
    notes?: true
    created_at?: true
  }

  export type GRNMaxAggregateInputType = {
    id?: true
    grn_number?: true
    purchase_order_id?: true
    received_date?: true
    received_by?: true
    notes?: true
    created_at?: true
  }

  export type GRNCountAggregateInputType = {
    id?: true
    grn_number?: true
    purchase_order_id?: true
    received_date?: true
    received_by?: true
    notes?: true
    created_at?: true
    _all?: true
  }

  export type GRNAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GRN to aggregate.
     */
    where?: GRNWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GRNS to fetch.
     */
    orderBy?: GRNOrderByWithRelationInput | GRNOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: GRNWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GRNS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GRNS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned GRNS
    **/
    _count?: true | GRNCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: GRNMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: GRNMaxAggregateInputType
  }

  export type GetGRNAggregateType<T extends GRNAggregateArgs> = {
        [P in keyof T & keyof AggregateGRN]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateGRN[P]>
      : GetScalarType<T[P], AggregateGRN[P]>
  }




  export type GRNGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: GRNWhereInput
    orderBy?: GRNOrderByWithAggregationInput | GRNOrderByWithAggregationInput[]
    by: GRNScalarFieldEnum[] | GRNScalarFieldEnum
    having?: GRNScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: GRNCountAggregateInputType | true
    _min?: GRNMinAggregateInputType
    _max?: GRNMaxAggregateInputType
  }

  export type GRNGroupByOutputType = {
    id: string
    grn_number: string
    purchase_order_id: string
    received_date: Date
    received_by: string
    notes: string | null
    created_at: Date
    _count: GRNCountAggregateOutputType | null
    _min: GRNMinAggregateOutputType | null
    _max: GRNMaxAggregateOutputType | null
  }

  type GetGRNGroupByPayload<T extends GRNGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<GRNGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof GRNGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], GRNGroupByOutputType[P]>
            : GetScalarType<T[P], GRNGroupByOutputType[P]>
        }
      >
    >


  export type GRNSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    grn_number?: boolean
    purchase_order_id?: boolean
    received_date?: boolean
    received_by?: boolean
    notes?: boolean
    created_at?: boolean
    purchase_order?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gRN"]>

  export type GRNSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    grn_number?: boolean
    purchase_order_id?: boolean
    received_date?: boolean
    received_by?: boolean
    notes?: boolean
    created_at?: boolean
    purchase_order?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gRN"]>

  export type GRNSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    grn_number?: boolean
    purchase_order_id?: boolean
    received_date?: boolean
    received_by?: boolean
    notes?: boolean
    created_at?: boolean
    purchase_order?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["gRN"]>

  export type GRNSelectScalar = {
    id?: boolean
    grn_number?: boolean
    purchase_order_id?: boolean
    received_date?: boolean
    received_by?: boolean
    notes?: boolean
    created_at?: boolean
  }

  export type GRNOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "grn_number" | "purchase_order_id" | "received_date" | "received_by" | "notes" | "created_at", ExtArgs["result"]["gRN"]>
  export type GRNInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase_order?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GRNIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase_order?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type GRNIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase_order?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $GRNPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "GRN"
    objects: {
      purchase_order: Prisma.$PurchaseOrderPayload<ExtArgs>
      receiver: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      grn_number: string
      purchase_order_id: string
      received_date: Date
      received_by: string
      notes: string | null
      created_at: Date
    }, ExtArgs["result"]["gRN"]>
    composites: {}
  }

  type GRNGetPayload<S extends boolean | null | undefined | GRNDefaultArgs> = $Result.GetResult<Prisma.$GRNPayload, S>

  type GRNCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<GRNFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: GRNCountAggregateInputType | true
    }

  export interface GRNDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['GRN'], meta: { name: 'GRN' } }
    /**
     * Find zero or one GRN that matches the filter.
     * @param {GRNFindUniqueArgs} args - Arguments to find a GRN
     * @example
     * // Get one GRN
     * const gRN = await prisma.gRN.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends GRNFindUniqueArgs>(args: SelectSubset<T, GRNFindUniqueArgs<ExtArgs>>): Prisma__GRNClient<$Result.GetResult<Prisma.$GRNPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one GRN that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {GRNFindUniqueOrThrowArgs} args - Arguments to find a GRN
     * @example
     * // Get one GRN
     * const gRN = await prisma.gRN.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends GRNFindUniqueOrThrowArgs>(args: SelectSubset<T, GRNFindUniqueOrThrowArgs<ExtArgs>>): Prisma__GRNClient<$Result.GetResult<Prisma.$GRNPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GRN that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GRNFindFirstArgs} args - Arguments to find a GRN
     * @example
     * // Get one GRN
     * const gRN = await prisma.gRN.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends GRNFindFirstArgs>(args?: SelectSubset<T, GRNFindFirstArgs<ExtArgs>>): Prisma__GRNClient<$Result.GetResult<Prisma.$GRNPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first GRN that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GRNFindFirstOrThrowArgs} args - Arguments to find a GRN
     * @example
     * // Get one GRN
     * const gRN = await prisma.gRN.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends GRNFindFirstOrThrowArgs>(args?: SelectSubset<T, GRNFindFirstOrThrowArgs<ExtArgs>>): Prisma__GRNClient<$Result.GetResult<Prisma.$GRNPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more GRNS that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GRNFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all GRNS
     * const gRNS = await prisma.gRN.findMany()
     * 
     * // Get first 10 GRNS
     * const gRNS = await prisma.gRN.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const gRNWithIdOnly = await prisma.gRN.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends GRNFindManyArgs>(args?: SelectSubset<T, GRNFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GRNPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a GRN.
     * @param {GRNCreateArgs} args - Arguments to create a GRN.
     * @example
     * // Create one GRN
     * const GRN = await prisma.gRN.create({
     *   data: {
     *     // ... data to create a GRN
     *   }
     * })
     * 
     */
    create<T extends GRNCreateArgs>(args: SelectSubset<T, GRNCreateArgs<ExtArgs>>): Prisma__GRNClient<$Result.GetResult<Prisma.$GRNPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many GRNS.
     * @param {GRNCreateManyArgs} args - Arguments to create many GRNS.
     * @example
     * // Create many GRNS
     * const gRN = await prisma.gRN.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends GRNCreateManyArgs>(args?: SelectSubset<T, GRNCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many GRNS and returns the data saved in the database.
     * @param {GRNCreateManyAndReturnArgs} args - Arguments to create many GRNS.
     * @example
     * // Create many GRNS
     * const gRN = await prisma.gRN.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many GRNS and only return the `id`
     * const gRNWithIdOnly = await prisma.gRN.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends GRNCreateManyAndReturnArgs>(args?: SelectSubset<T, GRNCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GRNPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a GRN.
     * @param {GRNDeleteArgs} args - Arguments to delete one GRN.
     * @example
     * // Delete one GRN
     * const GRN = await prisma.gRN.delete({
     *   where: {
     *     // ... filter to delete one GRN
     *   }
     * })
     * 
     */
    delete<T extends GRNDeleteArgs>(args: SelectSubset<T, GRNDeleteArgs<ExtArgs>>): Prisma__GRNClient<$Result.GetResult<Prisma.$GRNPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one GRN.
     * @param {GRNUpdateArgs} args - Arguments to update one GRN.
     * @example
     * // Update one GRN
     * const gRN = await prisma.gRN.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends GRNUpdateArgs>(args: SelectSubset<T, GRNUpdateArgs<ExtArgs>>): Prisma__GRNClient<$Result.GetResult<Prisma.$GRNPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more GRNS.
     * @param {GRNDeleteManyArgs} args - Arguments to filter GRNS to delete.
     * @example
     * // Delete a few GRNS
     * const { count } = await prisma.gRN.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends GRNDeleteManyArgs>(args?: SelectSubset<T, GRNDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GRNS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GRNUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many GRNS
     * const gRN = await prisma.gRN.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends GRNUpdateManyArgs>(args: SelectSubset<T, GRNUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more GRNS and returns the data updated in the database.
     * @param {GRNUpdateManyAndReturnArgs} args - Arguments to update many GRNS.
     * @example
     * // Update many GRNS
     * const gRN = await prisma.gRN.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more GRNS and only return the `id`
     * const gRNWithIdOnly = await prisma.gRN.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends GRNUpdateManyAndReturnArgs>(args: SelectSubset<T, GRNUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$GRNPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one GRN.
     * @param {GRNUpsertArgs} args - Arguments to update or create a GRN.
     * @example
     * // Update or create a GRN
     * const gRN = await prisma.gRN.upsert({
     *   create: {
     *     // ... data to create a GRN
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the GRN we want to update
     *   }
     * })
     */
    upsert<T extends GRNUpsertArgs>(args: SelectSubset<T, GRNUpsertArgs<ExtArgs>>): Prisma__GRNClient<$Result.GetResult<Prisma.$GRNPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of GRNS.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GRNCountArgs} args - Arguments to filter GRNS to count.
     * @example
     * // Count the number of GRNS
     * const count = await prisma.gRN.count({
     *   where: {
     *     // ... the filter for the GRNS we want to count
     *   }
     * })
    **/
    count<T extends GRNCountArgs>(
      args?: Subset<T, GRNCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], GRNCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a GRN.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GRNAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends GRNAggregateArgs>(args: Subset<T, GRNAggregateArgs>): Prisma.PrismaPromise<GetGRNAggregateType<T>>

    /**
     * Group by GRN.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {GRNGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends GRNGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: GRNGroupByArgs['orderBy'] }
        : { orderBy?: GRNGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, GRNGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetGRNGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the GRN model
   */
  readonly fields: GRNFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for GRN.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__GRNClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchase_order<T extends PurchaseOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderDefaultArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    receiver<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the GRN model
   */
  interface GRNFieldRefs {
    readonly id: FieldRef<"GRN", 'String'>
    readonly grn_number: FieldRef<"GRN", 'String'>
    readonly purchase_order_id: FieldRef<"GRN", 'String'>
    readonly received_date: FieldRef<"GRN", 'DateTime'>
    readonly received_by: FieldRef<"GRN", 'String'>
    readonly notes: FieldRef<"GRN", 'String'>
    readonly created_at: FieldRef<"GRN", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * GRN findUnique
   */
  export type GRNFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRN
     */
    select?: GRNSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRN
     */
    omit?: GRNOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNInclude<ExtArgs> | null
    /**
     * Filter, which GRN to fetch.
     */
    where: GRNWhereUniqueInput
  }

  /**
   * GRN findUniqueOrThrow
   */
  export type GRNFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRN
     */
    select?: GRNSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRN
     */
    omit?: GRNOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNInclude<ExtArgs> | null
    /**
     * Filter, which GRN to fetch.
     */
    where: GRNWhereUniqueInput
  }

  /**
   * GRN findFirst
   */
  export type GRNFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRN
     */
    select?: GRNSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRN
     */
    omit?: GRNOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNInclude<ExtArgs> | null
    /**
     * Filter, which GRN to fetch.
     */
    where?: GRNWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GRNS to fetch.
     */
    orderBy?: GRNOrderByWithRelationInput | GRNOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GRNS.
     */
    cursor?: GRNWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GRNS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GRNS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GRNS.
     */
    distinct?: GRNScalarFieldEnum | GRNScalarFieldEnum[]
  }

  /**
   * GRN findFirstOrThrow
   */
  export type GRNFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRN
     */
    select?: GRNSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRN
     */
    omit?: GRNOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNInclude<ExtArgs> | null
    /**
     * Filter, which GRN to fetch.
     */
    where?: GRNWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GRNS to fetch.
     */
    orderBy?: GRNOrderByWithRelationInput | GRNOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for GRNS.
     */
    cursor?: GRNWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GRNS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GRNS.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of GRNS.
     */
    distinct?: GRNScalarFieldEnum | GRNScalarFieldEnum[]
  }

  /**
   * GRN findMany
   */
  export type GRNFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRN
     */
    select?: GRNSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRN
     */
    omit?: GRNOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNInclude<ExtArgs> | null
    /**
     * Filter, which GRNS to fetch.
     */
    where?: GRNWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of GRNS to fetch.
     */
    orderBy?: GRNOrderByWithRelationInput | GRNOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing GRNS.
     */
    cursor?: GRNWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` GRNS from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` GRNS.
     */
    skip?: number
    distinct?: GRNScalarFieldEnum | GRNScalarFieldEnum[]
  }

  /**
   * GRN create
   */
  export type GRNCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRN
     */
    select?: GRNSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRN
     */
    omit?: GRNOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNInclude<ExtArgs> | null
    /**
     * The data needed to create a GRN.
     */
    data: XOR<GRNCreateInput, GRNUncheckedCreateInput>
  }

  /**
   * GRN createMany
   */
  export type GRNCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many GRNS.
     */
    data: GRNCreateManyInput | GRNCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * GRN createManyAndReturn
   */
  export type GRNCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRN
     */
    select?: GRNSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GRN
     */
    omit?: GRNOmit<ExtArgs> | null
    /**
     * The data used to create many GRNS.
     */
    data: GRNCreateManyInput | GRNCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * GRN update
   */
  export type GRNUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRN
     */
    select?: GRNSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRN
     */
    omit?: GRNOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNInclude<ExtArgs> | null
    /**
     * The data needed to update a GRN.
     */
    data: XOR<GRNUpdateInput, GRNUncheckedUpdateInput>
    /**
     * Choose, which GRN to update.
     */
    where: GRNWhereUniqueInput
  }

  /**
   * GRN updateMany
   */
  export type GRNUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update GRNS.
     */
    data: XOR<GRNUpdateManyMutationInput, GRNUncheckedUpdateManyInput>
    /**
     * Filter which GRNS to update
     */
    where?: GRNWhereInput
    /**
     * Limit how many GRNS to update.
     */
    limit?: number
  }

  /**
   * GRN updateManyAndReturn
   */
  export type GRNUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRN
     */
    select?: GRNSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the GRN
     */
    omit?: GRNOmit<ExtArgs> | null
    /**
     * The data used to update GRNS.
     */
    data: XOR<GRNUpdateManyMutationInput, GRNUncheckedUpdateManyInput>
    /**
     * Filter which GRNS to update
     */
    where?: GRNWhereInput
    /**
     * Limit how many GRNS to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * GRN upsert
   */
  export type GRNUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRN
     */
    select?: GRNSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRN
     */
    omit?: GRNOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNInclude<ExtArgs> | null
    /**
     * The filter to search for the GRN to update in case it exists.
     */
    where: GRNWhereUniqueInput
    /**
     * In case the GRN found by the `where` argument doesn't exist, create a new GRN with this data.
     */
    create: XOR<GRNCreateInput, GRNUncheckedCreateInput>
    /**
     * In case the GRN was found with the provided `where` argument, update it with this data.
     */
    update: XOR<GRNUpdateInput, GRNUncheckedUpdateInput>
  }

  /**
   * GRN delete
   */
  export type GRNDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRN
     */
    select?: GRNSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRN
     */
    omit?: GRNOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNInclude<ExtArgs> | null
    /**
     * Filter which GRN to delete.
     */
    where: GRNWhereUniqueInput
  }

  /**
   * GRN deleteMany
   */
  export type GRNDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which GRNS to delete
     */
    where?: GRNWhereInput
    /**
     * Limit how many GRNS to delete.
     */
    limit?: number
  }

  /**
   * GRN without action
   */
  export type GRNDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the GRN
     */
    select?: GRNSelect<ExtArgs> | null
    /**
     * Omit specific fields from the GRN
     */
    omit?: GRNOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: GRNInclude<ExtArgs> | null
  }


  /**
   * Model VendorBill
   */

  export type AggregateVendorBill = {
    _count: VendorBillCountAggregateOutputType | null
    _avg: VendorBillAvgAggregateOutputType | null
    _sum: VendorBillSumAggregateOutputType | null
    _min: VendorBillMinAggregateOutputType | null
    _max: VendorBillMaxAggregateOutputType | null
  }

  export type VendorBillAvgAggregateOutputType = {
    amount: Decimal | null
    tax_amount: Decimal | null
  }

  export type VendorBillSumAggregateOutputType = {
    amount: Decimal | null
    tax_amount: Decimal | null
  }

  export type VendorBillMinAggregateOutputType = {
    id: string | null
    bill_number: string | null
    purchase_order_id: string | null
    vendor_id: string | null
    amount: Decimal | null
    tax_amount: Decimal | null
    due_date: Date | null
    status: $Enums.InvoiceStatus | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VendorBillMaxAggregateOutputType = {
    id: string | null
    bill_number: string | null
    purchase_order_id: string | null
    vendor_id: string | null
    amount: Decimal | null
    tax_amount: Decimal | null
    due_date: Date | null
    status: $Enums.InvoiceStatus | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type VendorBillCountAggregateOutputType = {
    id: number
    bill_number: number
    purchase_order_id: number
    vendor_id: number
    amount: number
    tax_amount: number
    due_date: number
    status: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type VendorBillAvgAggregateInputType = {
    amount?: true
    tax_amount?: true
  }

  export type VendorBillSumAggregateInputType = {
    amount?: true
    tax_amount?: true
  }

  export type VendorBillMinAggregateInputType = {
    id?: true
    bill_number?: true
    purchase_order_id?: true
    vendor_id?: true
    amount?: true
    tax_amount?: true
    due_date?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type VendorBillMaxAggregateInputType = {
    id?: true
    bill_number?: true
    purchase_order_id?: true
    vendor_id?: true
    amount?: true
    tax_amount?: true
    due_date?: true
    status?: true
    created_at?: true
    updated_at?: true
  }

  export type VendorBillCountAggregateInputType = {
    id?: true
    bill_number?: true
    purchase_order_id?: true
    vendor_id?: true
    amount?: true
    tax_amount?: true
    due_date?: true
    status?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type VendorBillAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorBill to aggregate.
     */
    where?: VendorBillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorBills to fetch.
     */
    orderBy?: VendorBillOrderByWithRelationInput | VendorBillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorBillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorBills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorBills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VendorBills
    **/
    _count?: true | VendorBillCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorBillAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorBillSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorBillMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorBillMaxAggregateInputType
  }

  export type GetVendorBillAggregateType<T extends VendorBillAggregateArgs> = {
        [P in keyof T & keyof AggregateVendorBill]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendorBill[P]>
      : GetScalarType<T[P], AggregateVendorBill[P]>
  }




  export type VendorBillGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorBillWhereInput
    orderBy?: VendorBillOrderByWithAggregationInput | VendorBillOrderByWithAggregationInput[]
    by: VendorBillScalarFieldEnum[] | VendorBillScalarFieldEnum
    having?: VendorBillScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorBillCountAggregateInputType | true
    _avg?: VendorBillAvgAggregateInputType
    _sum?: VendorBillSumAggregateInputType
    _min?: VendorBillMinAggregateInputType
    _max?: VendorBillMaxAggregateInputType
  }

  export type VendorBillGroupByOutputType = {
    id: string
    bill_number: string
    purchase_order_id: string
    vendor_id: string
    amount: Decimal
    tax_amount: Decimal | null
    due_date: Date
    status: $Enums.InvoiceStatus
    created_at: Date
    updated_at: Date
    _count: VendorBillCountAggregateOutputType | null
    _avg: VendorBillAvgAggregateOutputType | null
    _sum: VendorBillSumAggregateOutputType | null
    _min: VendorBillMinAggregateOutputType | null
    _max: VendorBillMaxAggregateOutputType | null
  }

  type GetVendorBillGroupByPayload<T extends VendorBillGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorBillGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorBillGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorBillGroupByOutputType[P]>
            : GetScalarType<T[P], VendorBillGroupByOutputType[P]>
        }
      >
    >


  export type VendorBillSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bill_number?: boolean
    purchase_order_id?: boolean
    vendor_id?: boolean
    amount?: boolean
    tax_amount?: boolean
    due_date?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    purchase_order?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    vendor_payments?: boolean | VendorBill$vendor_paymentsArgs<ExtArgs>
    _count?: boolean | VendorBillCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorBill"]>

  export type VendorBillSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bill_number?: boolean
    purchase_order_id?: boolean
    vendor_id?: boolean
    amount?: boolean
    tax_amount?: boolean
    due_date?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    purchase_order?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorBill"]>

  export type VendorBillSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bill_number?: boolean
    purchase_order_id?: boolean
    vendor_id?: boolean
    amount?: boolean
    tax_amount?: boolean
    due_date?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
    purchase_order?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorBill"]>

  export type VendorBillSelectScalar = {
    id?: boolean
    bill_number?: boolean
    purchase_order_id?: boolean
    vendor_id?: boolean
    amount?: boolean
    tax_amount?: boolean
    due_date?: boolean
    status?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type VendorBillOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bill_number" | "purchase_order_id" | "vendor_id" | "amount" | "tax_amount" | "due_date" | "status" | "created_at" | "updated_at", ExtArgs["result"]["vendorBill"]>
  export type VendorBillInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase_order?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
    vendor_payments?: boolean | VendorBill$vendor_paymentsArgs<ExtArgs>
    _count?: boolean | VendorBillCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type VendorBillIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase_order?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }
  export type VendorBillIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    purchase_order?: boolean | PurchaseOrderDefaultArgs<ExtArgs>
    vendor?: boolean | VendorDefaultArgs<ExtArgs>
  }

  export type $VendorBillPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VendorBill"
    objects: {
      purchase_order: Prisma.$PurchaseOrderPayload<ExtArgs>
      vendor: Prisma.$VendorPayload<ExtArgs>
      vendor_payments: Prisma.$VendorPaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bill_number: string
      purchase_order_id: string
      vendor_id: string
      amount: Prisma.Decimal
      tax_amount: Prisma.Decimal | null
      due_date: Date
      status: $Enums.InvoiceStatus
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["vendorBill"]>
    composites: {}
  }

  type VendorBillGetPayload<S extends boolean | null | undefined | VendorBillDefaultArgs> = $Result.GetResult<Prisma.$VendorBillPayload, S>

  type VendorBillCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorBillFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorBillCountAggregateInputType | true
    }

  export interface VendorBillDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VendorBill'], meta: { name: 'VendorBill' } }
    /**
     * Find zero or one VendorBill that matches the filter.
     * @param {VendorBillFindUniqueArgs} args - Arguments to find a VendorBill
     * @example
     * // Get one VendorBill
     * const vendorBill = await prisma.vendorBill.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorBillFindUniqueArgs>(args: SelectSubset<T, VendorBillFindUniqueArgs<ExtArgs>>): Prisma__VendorBillClient<$Result.GetResult<Prisma.$VendorBillPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VendorBill that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorBillFindUniqueOrThrowArgs} args - Arguments to find a VendorBill
     * @example
     * // Get one VendorBill
     * const vendorBill = await prisma.vendorBill.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorBillFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorBillFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorBillClient<$Result.GetResult<Prisma.$VendorBillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorBill that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorBillFindFirstArgs} args - Arguments to find a VendorBill
     * @example
     * // Get one VendorBill
     * const vendorBill = await prisma.vendorBill.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorBillFindFirstArgs>(args?: SelectSubset<T, VendorBillFindFirstArgs<ExtArgs>>): Prisma__VendorBillClient<$Result.GetResult<Prisma.$VendorBillPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorBill that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorBillFindFirstOrThrowArgs} args - Arguments to find a VendorBill
     * @example
     * // Get one VendorBill
     * const vendorBill = await prisma.vendorBill.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorBillFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorBillFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorBillClient<$Result.GetResult<Prisma.$VendorBillPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VendorBills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorBillFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VendorBills
     * const vendorBills = await prisma.vendorBill.findMany()
     * 
     * // Get first 10 VendorBills
     * const vendorBills = await prisma.vendorBill.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorBillWithIdOnly = await prisma.vendorBill.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorBillFindManyArgs>(args?: SelectSubset<T, VendorBillFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorBillPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VendorBill.
     * @param {VendorBillCreateArgs} args - Arguments to create a VendorBill.
     * @example
     * // Create one VendorBill
     * const VendorBill = await prisma.vendorBill.create({
     *   data: {
     *     // ... data to create a VendorBill
     *   }
     * })
     * 
     */
    create<T extends VendorBillCreateArgs>(args: SelectSubset<T, VendorBillCreateArgs<ExtArgs>>): Prisma__VendorBillClient<$Result.GetResult<Prisma.$VendorBillPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VendorBills.
     * @param {VendorBillCreateManyArgs} args - Arguments to create many VendorBills.
     * @example
     * // Create many VendorBills
     * const vendorBill = await prisma.vendorBill.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorBillCreateManyArgs>(args?: SelectSubset<T, VendorBillCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VendorBills and returns the data saved in the database.
     * @param {VendorBillCreateManyAndReturnArgs} args - Arguments to create many VendorBills.
     * @example
     * // Create many VendorBills
     * const vendorBill = await prisma.vendorBill.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VendorBills and only return the `id`
     * const vendorBillWithIdOnly = await prisma.vendorBill.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorBillCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorBillCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorBillPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VendorBill.
     * @param {VendorBillDeleteArgs} args - Arguments to delete one VendorBill.
     * @example
     * // Delete one VendorBill
     * const VendorBill = await prisma.vendorBill.delete({
     *   where: {
     *     // ... filter to delete one VendorBill
     *   }
     * })
     * 
     */
    delete<T extends VendorBillDeleteArgs>(args: SelectSubset<T, VendorBillDeleteArgs<ExtArgs>>): Prisma__VendorBillClient<$Result.GetResult<Prisma.$VendorBillPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VendorBill.
     * @param {VendorBillUpdateArgs} args - Arguments to update one VendorBill.
     * @example
     * // Update one VendorBill
     * const vendorBill = await prisma.vendorBill.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorBillUpdateArgs>(args: SelectSubset<T, VendorBillUpdateArgs<ExtArgs>>): Prisma__VendorBillClient<$Result.GetResult<Prisma.$VendorBillPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VendorBills.
     * @param {VendorBillDeleteManyArgs} args - Arguments to filter VendorBills to delete.
     * @example
     * // Delete a few VendorBills
     * const { count } = await prisma.vendorBill.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorBillDeleteManyArgs>(args?: SelectSubset<T, VendorBillDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorBills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorBillUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VendorBills
     * const vendorBill = await prisma.vendorBill.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorBillUpdateManyArgs>(args: SelectSubset<T, VendorBillUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorBills and returns the data updated in the database.
     * @param {VendorBillUpdateManyAndReturnArgs} args - Arguments to update many VendorBills.
     * @example
     * // Update many VendorBills
     * const vendorBill = await prisma.vendorBill.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VendorBills and only return the `id`
     * const vendorBillWithIdOnly = await prisma.vendorBill.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VendorBillUpdateManyAndReturnArgs>(args: SelectSubset<T, VendorBillUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorBillPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VendorBill.
     * @param {VendorBillUpsertArgs} args - Arguments to update or create a VendorBill.
     * @example
     * // Update or create a VendorBill
     * const vendorBill = await prisma.vendorBill.upsert({
     *   create: {
     *     // ... data to create a VendorBill
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VendorBill we want to update
     *   }
     * })
     */
    upsert<T extends VendorBillUpsertArgs>(args: SelectSubset<T, VendorBillUpsertArgs<ExtArgs>>): Prisma__VendorBillClient<$Result.GetResult<Prisma.$VendorBillPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VendorBills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorBillCountArgs} args - Arguments to filter VendorBills to count.
     * @example
     * // Count the number of VendorBills
     * const count = await prisma.vendorBill.count({
     *   where: {
     *     // ... the filter for the VendorBills we want to count
     *   }
     * })
    **/
    count<T extends VendorBillCountArgs>(
      args?: Subset<T, VendorBillCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorBillCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VendorBill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorBillAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorBillAggregateArgs>(args: Subset<T, VendorBillAggregateArgs>): Prisma.PrismaPromise<GetVendorBillAggregateType<T>>

    /**
     * Group by VendorBill.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorBillGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorBillGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorBillGroupByArgs['orderBy'] }
        : { orderBy?: VendorBillGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorBillGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorBillGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VendorBill model
   */
  readonly fields: VendorBillFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VendorBill.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorBillClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    purchase_order<T extends PurchaseOrderDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PurchaseOrderDefaultArgs<ExtArgs>>): Prisma__PurchaseOrderClient<$Result.GetResult<Prisma.$PurchaseOrderPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vendor<T extends VendorDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorDefaultArgs<ExtArgs>>): Prisma__VendorClient<$Result.GetResult<Prisma.$VendorPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vendor_payments<T extends VendorBill$vendor_paymentsArgs<ExtArgs> = {}>(args?: Subset<T, VendorBill$vendor_paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VendorBill model
   */
  interface VendorBillFieldRefs {
    readonly id: FieldRef<"VendorBill", 'String'>
    readonly bill_number: FieldRef<"VendorBill", 'String'>
    readonly purchase_order_id: FieldRef<"VendorBill", 'String'>
    readonly vendor_id: FieldRef<"VendorBill", 'String'>
    readonly amount: FieldRef<"VendorBill", 'Decimal'>
    readonly tax_amount: FieldRef<"VendorBill", 'Decimal'>
    readonly due_date: FieldRef<"VendorBill", 'DateTime'>
    readonly status: FieldRef<"VendorBill", 'InvoiceStatus'>
    readonly created_at: FieldRef<"VendorBill", 'DateTime'>
    readonly updated_at: FieldRef<"VendorBill", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VendorBill findUnique
   */
  export type VendorBillFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBill
     */
    select?: VendorBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBill
     */
    omit?: VendorBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillInclude<ExtArgs> | null
    /**
     * Filter, which VendorBill to fetch.
     */
    where: VendorBillWhereUniqueInput
  }

  /**
   * VendorBill findUniqueOrThrow
   */
  export type VendorBillFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBill
     */
    select?: VendorBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBill
     */
    omit?: VendorBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillInclude<ExtArgs> | null
    /**
     * Filter, which VendorBill to fetch.
     */
    where: VendorBillWhereUniqueInput
  }

  /**
   * VendorBill findFirst
   */
  export type VendorBillFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBill
     */
    select?: VendorBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBill
     */
    omit?: VendorBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillInclude<ExtArgs> | null
    /**
     * Filter, which VendorBill to fetch.
     */
    where?: VendorBillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorBills to fetch.
     */
    orderBy?: VendorBillOrderByWithRelationInput | VendorBillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorBills.
     */
    cursor?: VendorBillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorBills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorBills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorBills.
     */
    distinct?: VendorBillScalarFieldEnum | VendorBillScalarFieldEnum[]
  }

  /**
   * VendorBill findFirstOrThrow
   */
  export type VendorBillFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBill
     */
    select?: VendorBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBill
     */
    omit?: VendorBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillInclude<ExtArgs> | null
    /**
     * Filter, which VendorBill to fetch.
     */
    where?: VendorBillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorBills to fetch.
     */
    orderBy?: VendorBillOrderByWithRelationInput | VendorBillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorBills.
     */
    cursor?: VendorBillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorBills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorBills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorBills.
     */
    distinct?: VendorBillScalarFieldEnum | VendorBillScalarFieldEnum[]
  }

  /**
   * VendorBill findMany
   */
  export type VendorBillFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBill
     */
    select?: VendorBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBill
     */
    omit?: VendorBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillInclude<ExtArgs> | null
    /**
     * Filter, which VendorBills to fetch.
     */
    where?: VendorBillWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorBills to fetch.
     */
    orderBy?: VendorBillOrderByWithRelationInput | VendorBillOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VendorBills.
     */
    cursor?: VendorBillWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorBills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorBills.
     */
    skip?: number
    distinct?: VendorBillScalarFieldEnum | VendorBillScalarFieldEnum[]
  }

  /**
   * VendorBill create
   */
  export type VendorBillCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBill
     */
    select?: VendorBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBill
     */
    omit?: VendorBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillInclude<ExtArgs> | null
    /**
     * The data needed to create a VendorBill.
     */
    data: XOR<VendorBillCreateInput, VendorBillUncheckedCreateInput>
  }

  /**
   * VendorBill createMany
   */
  export type VendorBillCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VendorBills.
     */
    data: VendorBillCreateManyInput | VendorBillCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VendorBill createManyAndReturn
   */
  export type VendorBillCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBill
     */
    select?: VendorBillSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBill
     */
    omit?: VendorBillOmit<ExtArgs> | null
    /**
     * The data used to create many VendorBills.
     */
    data: VendorBillCreateManyInput | VendorBillCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorBill update
   */
  export type VendorBillUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBill
     */
    select?: VendorBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBill
     */
    omit?: VendorBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillInclude<ExtArgs> | null
    /**
     * The data needed to update a VendorBill.
     */
    data: XOR<VendorBillUpdateInput, VendorBillUncheckedUpdateInput>
    /**
     * Choose, which VendorBill to update.
     */
    where: VendorBillWhereUniqueInput
  }

  /**
   * VendorBill updateMany
   */
  export type VendorBillUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VendorBills.
     */
    data: XOR<VendorBillUpdateManyMutationInput, VendorBillUncheckedUpdateManyInput>
    /**
     * Filter which VendorBills to update
     */
    where?: VendorBillWhereInput
    /**
     * Limit how many VendorBills to update.
     */
    limit?: number
  }

  /**
   * VendorBill updateManyAndReturn
   */
  export type VendorBillUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBill
     */
    select?: VendorBillSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBill
     */
    omit?: VendorBillOmit<ExtArgs> | null
    /**
     * The data used to update VendorBills.
     */
    data: XOR<VendorBillUpdateManyMutationInput, VendorBillUncheckedUpdateManyInput>
    /**
     * Filter which VendorBills to update
     */
    where?: VendorBillWhereInput
    /**
     * Limit how many VendorBills to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorBill upsert
   */
  export type VendorBillUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBill
     */
    select?: VendorBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBill
     */
    omit?: VendorBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillInclude<ExtArgs> | null
    /**
     * The filter to search for the VendorBill to update in case it exists.
     */
    where: VendorBillWhereUniqueInput
    /**
     * In case the VendorBill found by the `where` argument doesn't exist, create a new VendorBill with this data.
     */
    create: XOR<VendorBillCreateInput, VendorBillUncheckedCreateInput>
    /**
     * In case the VendorBill was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorBillUpdateInput, VendorBillUncheckedUpdateInput>
  }

  /**
   * VendorBill delete
   */
  export type VendorBillDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBill
     */
    select?: VendorBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBill
     */
    omit?: VendorBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillInclude<ExtArgs> | null
    /**
     * Filter which VendorBill to delete.
     */
    where: VendorBillWhereUniqueInput
  }

  /**
   * VendorBill deleteMany
   */
  export type VendorBillDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorBills to delete
     */
    where?: VendorBillWhereInput
    /**
     * Limit how many VendorBills to delete.
     */
    limit?: number
  }

  /**
   * VendorBill.vendor_payments
   */
  export type VendorBill$vendor_paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayment
     */
    select?: VendorPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayment
     */
    omit?: VendorPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPaymentInclude<ExtArgs> | null
    where?: VendorPaymentWhereInput
    orderBy?: VendorPaymentOrderByWithRelationInput | VendorPaymentOrderByWithRelationInput[]
    cursor?: VendorPaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VendorPaymentScalarFieldEnum | VendorPaymentScalarFieldEnum[]
  }

  /**
   * VendorBill without action
   */
  export type VendorBillDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorBill
     */
    select?: VendorBillSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorBill
     */
    omit?: VendorBillOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorBillInclude<ExtArgs> | null
  }


  /**
   * Model VendorPayment
   */

  export type AggregateVendorPayment = {
    _count: VendorPaymentCountAggregateOutputType | null
    _avg: VendorPaymentAvgAggregateOutputType | null
    _sum: VendorPaymentSumAggregateOutputType | null
    _min: VendorPaymentMinAggregateOutputType | null
    _max: VendorPaymentMaxAggregateOutputType | null
  }

  export type VendorPaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type VendorPaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type VendorPaymentMinAggregateOutputType = {
    id: string | null
    vendor_bill_id: string | null
    amount: Decimal | null
    payment_date: Date | null
    payment_method: string | null
    reference_no: string | null
    notes: string | null
    created_at: Date | null
  }

  export type VendorPaymentMaxAggregateOutputType = {
    id: string | null
    vendor_bill_id: string | null
    amount: Decimal | null
    payment_date: Date | null
    payment_method: string | null
    reference_no: string | null
    notes: string | null
    created_at: Date | null
  }

  export type VendorPaymentCountAggregateOutputType = {
    id: number
    vendor_bill_id: number
    amount: number
    payment_date: number
    payment_method: number
    reference_no: number
    notes: number
    created_at: number
    _all: number
  }


  export type VendorPaymentAvgAggregateInputType = {
    amount?: true
  }

  export type VendorPaymentSumAggregateInputType = {
    amount?: true
  }

  export type VendorPaymentMinAggregateInputType = {
    id?: true
    vendor_bill_id?: true
    amount?: true
    payment_date?: true
    payment_method?: true
    reference_no?: true
    notes?: true
    created_at?: true
  }

  export type VendorPaymentMaxAggregateInputType = {
    id?: true
    vendor_bill_id?: true
    amount?: true
    payment_date?: true
    payment_method?: true
    reference_no?: true
    notes?: true
    created_at?: true
  }

  export type VendorPaymentCountAggregateInputType = {
    id?: true
    vendor_bill_id?: true
    amount?: true
    payment_date?: true
    payment_method?: true
    reference_no?: true
    notes?: true
    created_at?: true
    _all?: true
  }

  export type VendorPaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorPayment to aggregate.
     */
    where?: VendorPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorPayments to fetch.
     */
    orderBy?: VendorPaymentOrderByWithRelationInput | VendorPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VendorPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VendorPayments
    **/
    _count?: true | VendorPaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VendorPaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VendorPaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VendorPaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VendorPaymentMaxAggregateInputType
  }

  export type GetVendorPaymentAggregateType<T extends VendorPaymentAggregateArgs> = {
        [P in keyof T & keyof AggregateVendorPayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVendorPayment[P]>
      : GetScalarType<T[P], AggregateVendorPayment[P]>
  }




  export type VendorPaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VendorPaymentWhereInput
    orderBy?: VendorPaymentOrderByWithAggregationInput | VendorPaymentOrderByWithAggregationInput[]
    by: VendorPaymentScalarFieldEnum[] | VendorPaymentScalarFieldEnum
    having?: VendorPaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VendorPaymentCountAggregateInputType | true
    _avg?: VendorPaymentAvgAggregateInputType
    _sum?: VendorPaymentSumAggregateInputType
    _min?: VendorPaymentMinAggregateInputType
    _max?: VendorPaymentMaxAggregateInputType
  }

  export type VendorPaymentGroupByOutputType = {
    id: string
    vendor_bill_id: string
    amount: Decimal
    payment_date: Date
    payment_method: string
    reference_no: string | null
    notes: string | null
    created_at: Date
    _count: VendorPaymentCountAggregateOutputType | null
    _avg: VendorPaymentAvgAggregateOutputType | null
    _sum: VendorPaymentSumAggregateOutputType | null
    _min: VendorPaymentMinAggregateOutputType | null
    _max: VendorPaymentMaxAggregateOutputType | null
  }

  type GetVendorPaymentGroupByPayload<T extends VendorPaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VendorPaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VendorPaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VendorPaymentGroupByOutputType[P]>
            : GetScalarType<T[P], VendorPaymentGroupByOutputType[P]>
        }
      >
    >


  export type VendorPaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendor_bill_id?: boolean
    amount?: boolean
    payment_date?: boolean
    payment_method?: boolean
    reference_no?: boolean
    notes?: boolean
    created_at?: boolean
    vendor_bill?: boolean | VendorBillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorPayment"]>

  export type VendorPaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendor_bill_id?: boolean
    amount?: boolean
    payment_date?: boolean
    payment_method?: boolean
    reference_no?: boolean
    notes?: boolean
    created_at?: boolean
    vendor_bill?: boolean | VendorBillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorPayment"]>

  export type VendorPaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vendor_bill_id?: boolean
    amount?: boolean
    payment_date?: boolean
    payment_method?: boolean
    reference_no?: boolean
    notes?: boolean
    created_at?: boolean
    vendor_bill?: boolean | VendorBillDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vendorPayment"]>

  export type VendorPaymentSelectScalar = {
    id?: boolean
    vendor_bill_id?: boolean
    amount?: boolean
    payment_date?: boolean
    payment_method?: boolean
    reference_no?: boolean
    notes?: boolean
    created_at?: boolean
  }

  export type VendorPaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vendor_bill_id" | "amount" | "payment_date" | "payment_method" | "reference_no" | "notes" | "created_at", ExtArgs["result"]["vendorPayment"]>
  export type VendorPaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor_bill?: boolean | VendorBillDefaultArgs<ExtArgs>
  }
  export type VendorPaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor_bill?: boolean | VendorBillDefaultArgs<ExtArgs>
  }
  export type VendorPaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vendor_bill?: boolean | VendorBillDefaultArgs<ExtArgs>
  }

  export type $VendorPaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VendorPayment"
    objects: {
      vendor_bill: Prisma.$VendorBillPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vendor_bill_id: string
      amount: Prisma.Decimal
      payment_date: Date
      payment_method: string
      reference_no: string | null
      notes: string | null
      created_at: Date
    }, ExtArgs["result"]["vendorPayment"]>
    composites: {}
  }

  type VendorPaymentGetPayload<S extends boolean | null | undefined | VendorPaymentDefaultArgs> = $Result.GetResult<Prisma.$VendorPaymentPayload, S>

  type VendorPaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VendorPaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VendorPaymentCountAggregateInputType | true
    }

  export interface VendorPaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VendorPayment'], meta: { name: 'VendorPayment' } }
    /**
     * Find zero or one VendorPayment that matches the filter.
     * @param {VendorPaymentFindUniqueArgs} args - Arguments to find a VendorPayment
     * @example
     * // Get one VendorPayment
     * const vendorPayment = await prisma.vendorPayment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VendorPaymentFindUniqueArgs>(args: SelectSubset<T, VendorPaymentFindUniqueArgs<ExtArgs>>): Prisma__VendorPaymentClient<$Result.GetResult<Prisma.$VendorPaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VendorPayment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VendorPaymentFindUniqueOrThrowArgs} args - Arguments to find a VendorPayment
     * @example
     * // Get one VendorPayment
     * const vendorPayment = await prisma.vendorPayment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VendorPaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, VendorPaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VendorPaymentClient<$Result.GetResult<Prisma.$VendorPaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorPayment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorPaymentFindFirstArgs} args - Arguments to find a VendorPayment
     * @example
     * // Get one VendorPayment
     * const vendorPayment = await prisma.vendorPayment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VendorPaymentFindFirstArgs>(args?: SelectSubset<T, VendorPaymentFindFirstArgs<ExtArgs>>): Prisma__VendorPaymentClient<$Result.GetResult<Prisma.$VendorPaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VendorPayment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorPaymentFindFirstOrThrowArgs} args - Arguments to find a VendorPayment
     * @example
     * // Get one VendorPayment
     * const vendorPayment = await prisma.vendorPayment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VendorPaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, VendorPaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__VendorPaymentClient<$Result.GetResult<Prisma.$VendorPaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VendorPayments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorPaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VendorPayments
     * const vendorPayments = await prisma.vendorPayment.findMany()
     * 
     * // Get first 10 VendorPayments
     * const vendorPayments = await prisma.vendorPayment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vendorPaymentWithIdOnly = await prisma.vendorPayment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends VendorPaymentFindManyArgs>(args?: SelectSubset<T, VendorPaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VendorPayment.
     * @param {VendorPaymentCreateArgs} args - Arguments to create a VendorPayment.
     * @example
     * // Create one VendorPayment
     * const VendorPayment = await prisma.vendorPayment.create({
     *   data: {
     *     // ... data to create a VendorPayment
     *   }
     * })
     * 
     */
    create<T extends VendorPaymentCreateArgs>(args: SelectSubset<T, VendorPaymentCreateArgs<ExtArgs>>): Prisma__VendorPaymentClient<$Result.GetResult<Prisma.$VendorPaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VendorPayments.
     * @param {VendorPaymentCreateManyArgs} args - Arguments to create many VendorPayments.
     * @example
     * // Create many VendorPayments
     * const vendorPayment = await prisma.vendorPayment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VendorPaymentCreateManyArgs>(args?: SelectSubset<T, VendorPaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VendorPayments and returns the data saved in the database.
     * @param {VendorPaymentCreateManyAndReturnArgs} args - Arguments to create many VendorPayments.
     * @example
     * // Create many VendorPayments
     * const vendorPayment = await prisma.vendorPayment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VendorPayments and only return the `id`
     * const vendorPaymentWithIdOnly = await prisma.vendorPayment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VendorPaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, VendorPaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VendorPayment.
     * @param {VendorPaymentDeleteArgs} args - Arguments to delete one VendorPayment.
     * @example
     * // Delete one VendorPayment
     * const VendorPayment = await prisma.vendorPayment.delete({
     *   where: {
     *     // ... filter to delete one VendorPayment
     *   }
     * })
     * 
     */
    delete<T extends VendorPaymentDeleteArgs>(args: SelectSubset<T, VendorPaymentDeleteArgs<ExtArgs>>): Prisma__VendorPaymentClient<$Result.GetResult<Prisma.$VendorPaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VendorPayment.
     * @param {VendorPaymentUpdateArgs} args - Arguments to update one VendorPayment.
     * @example
     * // Update one VendorPayment
     * const vendorPayment = await prisma.vendorPayment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VendorPaymentUpdateArgs>(args: SelectSubset<T, VendorPaymentUpdateArgs<ExtArgs>>): Prisma__VendorPaymentClient<$Result.GetResult<Prisma.$VendorPaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VendorPayments.
     * @param {VendorPaymentDeleteManyArgs} args - Arguments to filter VendorPayments to delete.
     * @example
     * // Delete a few VendorPayments
     * const { count } = await prisma.vendorPayment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VendorPaymentDeleteManyArgs>(args?: SelectSubset<T, VendorPaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorPaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VendorPayments
     * const vendorPayment = await prisma.vendorPayment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VendorPaymentUpdateManyArgs>(args: SelectSubset<T, VendorPaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VendorPayments and returns the data updated in the database.
     * @param {VendorPaymentUpdateManyAndReturnArgs} args - Arguments to update many VendorPayments.
     * @example
     * // Update many VendorPayments
     * const vendorPayment = await prisma.vendorPayment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VendorPayments and only return the `id`
     * const vendorPaymentWithIdOnly = await prisma.vendorPayment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VendorPaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, VendorPaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VendorPaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VendorPayment.
     * @param {VendorPaymentUpsertArgs} args - Arguments to update or create a VendorPayment.
     * @example
     * // Update or create a VendorPayment
     * const vendorPayment = await prisma.vendorPayment.upsert({
     *   create: {
     *     // ... data to create a VendorPayment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VendorPayment we want to update
     *   }
     * })
     */
    upsert<T extends VendorPaymentUpsertArgs>(args: SelectSubset<T, VendorPaymentUpsertArgs<ExtArgs>>): Prisma__VendorPaymentClient<$Result.GetResult<Prisma.$VendorPaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VendorPayments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorPaymentCountArgs} args - Arguments to filter VendorPayments to count.
     * @example
     * // Count the number of VendorPayments
     * const count = await prisma.vendorPayment.count({
     *   where: {
     *     // ... the filter for the VendorPayments we want to count
     *   }
     * })
    **/
    count<T extends VendorPaymentCountArgs>(
      args?: Subset<T, VendorPaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VendorPaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VendorPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorPaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VendorPaymentAggregateArgs>(args: Subset<T, VendorPaymentAggregateArgs>): Prisma.PrismaPromise<GetVendorPaymentAggregateType<T>>

    /**
     * Group by VendorPayment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VendorPaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VendorPaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VendorPaymentGroupByArgs['orderBy'] }
        : { orderBy?: VendorPaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VendorPaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVendorPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VendorPayment model
   */
  readonly fields: VendorPaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VendorPayment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VendorPaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vendor_bill<T extends VendorBillDefaultArgs<ExtArgs> = {}>(args?: Subset<T, VendorBillDefaultArgs<ExtArgs>>): Prisma__VendorBillClient<$Result.GetResult<Prisma.$VendorBillPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VendorPayment model
   */
  interface VendorPaymentFieldRefs {
    readonly id: FieldRef<"VendorPayment", 'String'>
    readonly vendor_bill_id: FieldRef<"VendorPayment", 'String'>
    readonly amount: FieldRef<"VendorPayment", 'Decimal'>
    readonly payment_date: FieldRef<"VendorPayment", 'DateTime'>
    readonly payment_method: FieldRef<"VendorPayment", 'String'>
    readonly reference_no: FieldRef<"VendorPayment", 'String'>
    readonly notes: FieldRef<"VendorPayment", 'String'>
    readonly created_at: FieldRef<"VendorPayment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VendorPayment findUnique
   */
  export type VendorPaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayment
     */
    select?: VendorPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayment
     */
    omit?: VendorPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPaymentInclude<ExtArgs> | null
    /**
     * Filter, which VendorPayment to fetch.
     */
    where: VendorPaymentWhereUniqueInput
  }

  /**
   * VendorPayment findUniqueOrThrow
   */
  export type VendorPaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayment
     */
    select?: VendorPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayment
     */
    omit?: VendorPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPaymentInclude<ExtArgs> | null
    /**
     * Filter, which VendorPayment to fetch.
     */
    where: VendorPaymentWhereUniqueInput
  }

  /**
   * VendorPayment findFirst
   */
  export type VendorPaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayment
     */
    select?: VendorPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayment
     */
    omit?: VendorPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPaymentInclude<ExtArgs> | null
    /**
     * Filter, which VendorPayment to fetch.
     */
    where?: VendorPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorPayments to fetch.
     */
    orderBy?: VendorPaymentOrderByWithRelationInput | VendorPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorPayments.
     */
    cursor?: VendorPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorPayments.
     */
    distinct?: VendorPaymentScalarFieldEnum | VendorPaymentScalarFieldEnum[]
  }

  /**
   * VendorPayment findFirstOrThrow
   */
  export type VendorPaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayment
     */
    select?: VendorPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayment
     */
    omit?: VendorPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPaymentInclude<ExtArgs> | null
    /**
     * Filter, which VendorPayment to fetch.
     */
    where?: VendorPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorPayments to fetch.
     */
    orderBy?: VendorPaymentOrderByWithRelationInput | VendorPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VendorPayments.
     */
    cursor?: VendorPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorPayments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VendorPayments.
     */
    distinct?: VendorPaymentScalarFieldEnum | VendorPaymentScalarFieldEnum[]
  }

  /**
   * VendorPayment findMany
   */
  export type VendorPaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayment
     */
    select?: VendorPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayment
     */
    omit?: VendorPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPaymentInclude<ExtArgs> | null
    /**
     * Filter, which VendorPayments to fetch.
     */
    where?: VendorPaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VendorPayments to fetch.
     */
    orderBy?: VendorPaymentOrderByWithRelationInput | VendorPaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VendorPayments.
     */
    cursor?: VendorPaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` VendorPayments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VendorPayments.
     */
    skip?: number
    distinct?: VendorPaymentScalarFieldEnum | VendorPaymentScalarFieldEnum[]
  }

  /**
   * VendorPayment create
   */
  export type VendorPaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayment
     */
    select?: VendorPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayment
     */
    omit?: VendorPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a VendorPayment.
     */
    data: XOR<VendorPaymentCreateInput, VendorPaymentUncheckedCreateInput>
  }

  /**
   * VendorPayment createMany
   */
  export type VendorPaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VendorPayments.
     */
    data: VendorPaymentCreateManyInput | VendorPaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VendorPayment createManyAndReturn
   */
  export type VendorPaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayment
     */
    select?: VendorPaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayment
     */
    omit?: VendorPaymentOmit<ExtArgs> | null
    /**
     * The data used to create many VendorPayments.
     */
    data: VendorPaymentCreateManyInput | VendorPaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorPayment update
   */
  export type VendorPaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayment
     */
    select?: VendorPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayment
     */
    omit?: VendorPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a VendorPayment.
     */
    data: XOR<VendorPaymentUpdateInput, VendorPaymentUncheckedUpdateInput>
    /**
     * Choose, which VendorPayment to update.
     */
    where: VendorPaymentWhereUniqueInput
  }

  /**
   * VendorPayment updateMany
   */
  export type VendorPaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VendorPayments.
     */
    data: XOR<VendorPaymentUpdateManyMutationInput, VendorPaymentUncheckedUpdateManyInput>
    /**
     * Filter which VendorPayments to update
     */
    where?: VendorPaymentWhereInput
    /**
     * Limit how many VendorPayments to update.
     */
    limit?: number
  }

  /**
   * VendorPayment updateManyAndReturn
   */
  export type VendorPaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayment
     */
    select?: VendorPaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayment
     */
    omit?: VendorPaymentOmit<ExtArgs> | null
    /**
     * The data used to update VendorPayments.
     */
    data: XOR<VendorPaymentUpdateManyMutationInput, VendorPaymentUncheckedUpdateManyInput>
    /**
     * Filter which VendorPayments to update
     */
    where?: VendorPaymentWhereInput
    /**
     * Limit how many VendorPayments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * VendorPayment upsert
   */
  export type VendorPaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayment
     */
    select?: VendorPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayment
     */
    omit?: VendorPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the VendorPayment to update in case it exists.
     */
    where: VendorPaymentWhereUniqueInput
    /**
     * In case the VendorPayment found by the `where` argument doesn't exist, create a new VendorPayment with this data.
     */
    create: XOR<VendorPaymentCreateInput, VendorPaymentUncheckedCreateInput>
    /**
     * In case the VendorPayment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VendorPaymentUpdateInput, VendorPaymentUncheckedUpdateInput>
  }

  /**
   * VendorPayment delete
   */
  export type VendorPaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayment
     */
    select?: VendorPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayment
     */
    omit?: VendorPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPaymentInclude<ExtArgs> | null
    /**
     * Filter which VendorPayment to delete.
     */
    where: VendorPaymentWhereUniqueInput
  }

  /**
   * VendorPayment deleteMany
   */
  export type VendorPaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VendorPayments to delete
     */
    where?: VendorPaymentWhereInput
    /**
     * Limit how many VendorPayments to delete.
     */
    limit?: number
  }

  /**
   * VendorPayment without action
   */
  export type VendorPaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VendorPayment
     */
    select?: VendorPaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VendorPayment
     */
    omit?: VendorPaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: VendorPaymentInclude<ExtArgs> | null
  }


  /**
   * Model BankAccount
   */

  export type AggregateBankAccount = {
    _count: BankAccountCountAggregateOutputType | null
    _avg: BankAccountAvgAggregateOutputType | null
    _sum: BankAccountSumAggregateOutputType | null
    _min: BankAccountMinAggregateOutputType | null
    _max: BankAccountMaxAggregateOutputType | null
  }

  export type BankAccountAvgAggregateOutputType = {
    current_balance: Decimal | null
  }

  export type BankAccountSumAggregateOutputType = {
    current_balance: Decimal | null
  }

  export type BankAccountMinAggregateOutputType = {
    id: string | null
    name: string | null
    account_number: string | null
    bank_name: string | null
    currency: string | null
    current_balance: Decimal | null
    type: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BankAccountMaxAggregateOutputType = {
    id: string | null
    name: string | null
    account_number: string | null
    bank_name: string | null
    currency: string | null
    current_balance: Decimal | null
    type: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BankAccountCountAggregateOutputType = {
    id: number
    name: number
    account_number: number
    bank_name: number
    currency: number
    current_balance: number
    type: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type BankAccountAvgAggregateInputType = {
    current_balance?: true
  }

  export type BankAccountSumAggregateInputType = {
    current_balance?: true
  }

  export type BankAccountMinAggregateInputType = {
    id?: true
    name?: true
    account_number?: true
    bank_name?: true
    currency?: true
    current_balance?: true
    type?: true
    created_at?: true
    updated_at?: true
  }

  export type BankAccountMaxAggregateInputType = {
    id?: true
    name?: true
    account_number?: true
    bank_name?: true
    currency?: true
    current_balance?: true
    type?: true
    created_at?: true
    updated_at?: true
  }

  export type BankAccountCountAggregateInputType = {
    id?: true
    name?: true
    account_number?: true
    bank_name?: true
    currency?: true
    current_balance?: true
    type?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type BankAccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankAccount to aggregate.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BankAccounts
    **/
    _count?: true | BankAccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BankAccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BankAccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankAccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankAccountMaxAggregateInputType
  }

  export type GetBankAccountAggregateType<T extends BankAccountAggregateArgs> = {
        [P in keyof T & keyof AggregateBankAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBankAccount[P]>
      : GetScalarType<T[P], AggregateBankAccount[P]>
  }




  export type BankAccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankAccountWhereInput
    orderBy?: BankAccountOrderByWithAggregationInput | BankAccountOrderByWithAggregationInput[]
    by: BankAccountScalarFieldEnum[] | BankAccountScalarFieldEnum
    having?: BankAccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankAccountCountAggregateInputType | true
    _avg?: BankAccountAvgAggregateInputType
    _sum?: BankAccountSumAggregateInputType
    _min?: BankAccountMinAggregateInputType
    _max?: BankAccountMaxAggregateInputType
  }

  export type BankAccountGroupByOutputType = {
    id: string
    name: string
    account_number: string | null
    bank_name: string | null
    currency: string
    current_balance: Decimal
    type: string
    created_at: Date
    updated_at: Date
    _count: BankAccountCountAggregateOutputType | null
    _avg: BankAccountAvgAggregateOutputType | null
    _sum: BankAccountSumAggregateOutputType | null
    _min: BankAccountMinAggregateOutputType | null
    _max: BankAccountMaxAggregateOutputType | null
  }

  type GetBankAccountGroupByPayload<T extends BankAccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BankAccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankAccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankAccountGroupByOutputType[P]>
            : GetScalarType<T[P], BankAccountGroupByOutputType[P]>
        }
      >
    >


  export type BankAccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    account_number?: boolean
    bank_name?: boolean
    currency?: boolean
    current_balance?: boolean
    type?: boolean
    created_at?: boolean
    updated_at?: boolean
    transactions?: boolean | BankAccount$transactionsArgs<ExtArgs>
    _count?: boolean | BankAccountCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankAccount"]>

  export type BankAccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    account_number?: boolean
    bank_name?: boolean
    currency?: boolean
    current_balance?: boolean
    type?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["bankAccount"]>

  export type BankAccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    account_number?: boolean
    bank_name?: boolean
    currency?: boolean
    current_balance?: boolean
    type?: boolean
    created_at?: boolean
    updated_at?: boolean
  }, ExtArgs["result"]["bankAccount"]>

  export type BankAccountSelectScalar = {
    id?: boolean
    name?: boolean
    account_number?: boolean
    bank_name?: boolean
    currency?: boolean
    current_balance?: boolean
    type?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type BankAccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "account_number" | "bank_name" | "currency" | "current_balance" | "type" | "created_at" | "updated_at", ExtArgs["result"]["bankAccount"]>
  export type BankAccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    transactions?: boolean | BankAccount$transactionsArgs<ExtArgs>
    _count?: boolean | BankAccountCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type BankAccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type BankAccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $BankAccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BankAccount"
    objects: {
      transactions: Prisma.$BankTransactionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      account_number: string | null
      bank_name: string | null
      currency: string
      current_balance: Prisma.Decimal
      type: string
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["bankAccount"]>
    composites: {}
  }

  type BankAccountGetPayload<S extends boolean | null | undefined | BankAccountDefaultArgs> = $Result.GetResult<Prisma.$BankAccountPayload, S>

  type BankAccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BankAccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BankAccountCountAggregateInputType | true
    }

  export interface BankAccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BankAccount'], meta: { name: 'BankAccount' } }
    /**
     * Find zero or one BankAccount that matches the filter.
     * @param {BankAccountFindUniqueArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BankAccountFindUniqueArgs>(args: SelectSubset<T, BankAccountFindUniqueArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BankAccount that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BankAccountFindUniqueOrThrowArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BankAccountFindUniqueOrThrowArgs>(args: SelectSubset<T, BankAccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankAccount that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindFirstArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BankAccountFindFirstArgs>(args?: SelectSubset<T, BankAccountFindFirstArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankAccount that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindFirstOrThrowArgs} args - Arguments to find a BankAccount
     * @example
     * // Get one BankAccount
     * const bankAccount = await prisma.bankAccount.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BankAccountFindFirstOrThrowArgs>(args?: SelectSubset<T, BankAccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BankAccounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BankAccounts
     * const bankAccounts = await prisma.bankAccount.findMany()
     * 
     * // Get first 10 BankAccounts
     * const bankAccounts = await prisma.bankAccount.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankAccountWithIdOnly = await prisma.bankAccount.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BankAccountFindManyArgs>(args?: SelectSubset<T, BankAccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BankAccount.
     * @param {BankAccountCreateArgs} args - Arguments to create a BankAccount.
     * @example
     * // Create one BankAccount
     * const BankAccount = await prisma.bankAccount.create({
     *   data: {
     *     // ... data to create a BankAccount
     *   }
     * })
     * 
     */
    create<T extends BankAccountCreateArgs>(args: SelectSubset<T, BankAccountCreateArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BankAccounts.
     * @param {BankAccountCreateManyArgs} args - Arguments to create many BankAccounts.
     * @example
     * // Create many BankAccounts
     * const bankAccount = await prisma.bankAccount.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BankAccountCreateManyArgs>(args?: SelectSubset<T, BankAccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BankAccounts and returns the data saved in the database.
     * @param {BankAccountCreateManyAndReturnArgs} args - Arguments to create many BankAccounts.
     * @example
     * // Create many BankAccounts
     * const bankAccount = await prisma.bankAccount.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BankAccounts and only return the `id`
     * const bankAccountWithIdOnly = await prisma.bankAccount.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BankAccountCreateManyAndReturnArgs>(args?: SelectSubset<T, BankAccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BankAccount.
     * @param {BankAccountDeleteArgs} args - Arguments to delete one BankAccount.
     * @example
     * // Delete one BankAccount
     * const BankAccount = await prisma.bankAccount.delete({
     *   where: {
     *     // ... filter to delete one BankAccount
     *   }
     * })
     * 
     */
    delete<T extends BankAccountDeleteArgs>(args: SelectSubset<T, BankAccountDeleteArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BankAccount.
     * @param {BankAccountUpdateArgs} args - Arguments to update one BankAccount.
     * @example
     * // Update one BankAccount
     * const bankAccount = await prisma.bankAccount.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BankAccountUpdateArgs>(args: SelectSubset<T, BankAccountUpdateArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BankAccounts.
     * @param {BankAccountDeleteManyArgs} args - Arguments to filter BankAccounts to delete.
     * @example
     * // Delete a few BankAccounts
     * const { count } = await prisma.bankAccount.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BankAccountDeleteManyArgs>(args?: SelectSubset<T, BankAccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BankAccounts
     * const bankAccount = await prisma.bankAccount.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BankAccountUpdateManyArgs>(args: SelectSubset<T, BankAccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankAccounts and returns the data updated in the database.
     * @param {BankAccountUpdateManyAndReturnArgs} args - Arguments to update many BankAccounts.
     * @example
     * // Update many BankAccounts
     * const bankAccount = await prisma.bankAccount.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BankAccounts and only return the `id`
     * const bankAccountWithIdOnly = await prisma.bankAccount.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BankAccountUpdateManyAndReturnArgs>(args: SelectSubset<T, BankAccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BankAccount.
     * @param {BankAccountUpsertArgs} args - Arguments to update or create a BankAccount.
     * @example
     * // Update or create a BankAccount
     * const bankAccount = await prisma.bankAccount.upsert({
     *   create: {
     *     // ... data to create a BankAccount
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BankAccount we want to update
     *   }
     * })
     */
    upsert<T extends BankAccountUpsertArgs>(args: SelectSubset<T, BankAccountUpsertArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BankAccounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountCountArgs} args - Arguments to filter BankAccounts to count.
     * @example
     * // Count the number of BankAccounts
     * const count = await prisma.bankAccount.count({
     *   where: {
     *     // ... the filter for the BankAccounts we want to count
     *   }
     * })
    **/
    count<T extends BankAccountCountArgs>(
      args?: Subset<T, BankAccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankAccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BankAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankAccountAggregateArgs>(args: Subset<T, BankAccountAggregateArgs>): Prisma.PrismaPromise<GetBankAccountAggregateType<T>>

    /**
     * Group by BankAccount.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankAccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankAccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankAccountGroupByArgs['orderBy'] }
        : { orderBy?: BankAccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankAccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BankAccount model
   */
  readonly fields: BankAccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BankAccount.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BankAccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    transactions<T extends BankAccount$transactionsArgs<ExtArgs> = {}>(args?: Subset<T, BankAccount$transactionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BankAccount model
   */
  interface BankAccountFieldRefs {
    readonly id: FieldRef<"BankAccount", 'String'>
    readonly name: FieldRef<"BankAccount", 'String'>
    readonly account_number: FieldRef<"BankAccount", 'String'>
    readonly bank_name: FieldRef<"BankAccount", 'String'>
    readonly currency: FieldRef<"BankAccount", 'String'>
    readonly current_balance: FieldRef<"BankAccount", 'Decimal'>
    readonly type: FieldRef<"BankAccount", 'String'>
    readonly created_at: FieldRef<"BankAccount", 'DateTime'>
    readonly updated_at: FieldRef<"BankAccount", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BankAccount findUnique
   */
  export type BankAccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount findUniqueOrThrow
   */
  export type BankAccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount findFirst
   */
  export type BankAccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankAccounts.
     */
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * BankAccount findFirstOrThrow
   */
  export type BankAccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccount to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankAccounts.
     */
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * BankAccount findMany
   */
  export type BankAccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter, which BankAccounts to fetch.
     */
    where?: BankAccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankAccounts to fetch.
     */
    orderBy?: BankAccountOrderByWithRelationInput | BankAccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BankAccounts.
     */
    cursor?: BankAccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankAccounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankAccounts.
     */
    skip?: number
    distinct?: BankAccountScalarFieldEnum | BankAccountScalarFieldEnum[]
  }

  /**
   * BankAccount create
   */
  export type BankAccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * The data needed to create a BankAccount.
     */
    data: XOR<BankAccountCreateInput, BankAccountUncheckedCreateInput>
  }

  /**
   * BankAccount createMany
   */
  export type BankAccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BankAccounts.
     */
    data: BankAccountCreateManyInput | BankAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BankAccount createManyAndReturn
   */
  export type BankAccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * The data used to create many BankAccounts.
     */
    data: BankAccountCreateManyInput | BankAccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BankAccount update
   */
  export type BankAccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * The data needed to update a BankAccount.
     */
    data: XOR<BankAccountUpdateInput, BankAccountUncheckedUpdateInput>
    /**
     * Choose, which BankAccount to update.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount updateMany
   */
  export type BankAccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BankAccounts.
     */
    data: XOR<BankAccountUpdateManyMutationInput, BankAccountUncheckedUpdateManyInput>
    /**
     * Filter which BankAccounts to update
     */
    where?: BankAccountWhereInput
    /**
     * Limit how many BankAccounts to update.
     */
    limit?: number
  }

  /**
   * BankAccount updateManyAndReturn
   */
  export type BankAccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * The data used to update BankAccounts.
     */
    data: XOR<BankAccountUpdateManyMutationInput, BankAccountUncheckedUpdateManyInput>
    /**
     * Filter which BankAccounts to update
     */
    where?: BankAccountWhereInput
    /**
     * Limit how many BankAccounts to update.
     */
    limit?: number
  }

  /**
   * BankAccount upsert
   */
  export type BankAccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * The filter to search for the BankAccount to update in case it exists.
     */
    where: BankAccountWhereUniqueInput
    /**
     * In case the BankAccount found by the `where` argument doesn't exist, create a new BankAccount with this data.
     */
    create: XOR<BankAccountCreateInput, BankAccountUncheckedCreateInput>
    /**
     * In case the BankAccount was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BankAccountUpdateInput, BankAccountUncheckedUpdateInput>
  }

  /**
   * BankAccount delete
   */
  export type BankAccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
    /**
     * Filter which BankAccount to delete.
     */
    where: BankAccountWhereUniqueInput
  }

  /**
   * BankAccount deleteMany
   */
  export type BankAccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankAccounts to delete
     */
    where?: BankAccountWhereInput
    /**
     * Limit how many BankAccounts to delete.
     */
    limit?: number
  }

  /**
   * BankAccount.transactions
   */
  export type BankAccount$transactionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    where?: BankTransactionWhereInput
    orderBy?: BankTransactionOrderByWithRelationInput | BankTransactionOrderByWithRelationInput[]
    cursor?: BankTransactionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BankTransactionScalarFieldEnum | BankTransactionScalarFieldEnum[]
  }

  /**
   * BankAccount without action
   */
  export type BankAccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankAccount
     */
    select?: BankAccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankAccount
     */
    omit?: BankAccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankAccountInclude<ExtArgs> | null
  }


  /**
   * Model BankTransaction
   */

  export type AggregateBankTransaction = {
    _count: BankTransactionCountAggregateOutputType | null
    _avg: BankTransactionAvgAggregateOutputType | null
    _sum: BankTransactionSumAggregateOutputType | null
    _min: BankTransactionMinAggregateOutputType | null
    _max: BankTransactionMaxAggregateOutputType | null
  }

  export type BankTransactionAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type BankTransactionSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type BankTransactionMinAggregateOutputType = {
    id: string | null
    bank_account_id: string | null
    date: Date | null
    description: string | null
    amount: Decimal | null
    reference: string | null
    status: string | null
    type: string | null
    system_transaction_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BankTransactionMaxAggregateOutputType = {
    id: string | null
    bank_account_id: string | null
    date: Date | null
    description: string | null
    amount: Decimal | null
    reference: string | null
    status: string | null
    type: string | null
    system_transaction_id: string | null
    created_at: Date | null
    updated_at: Date | null
  }

  export type BankTransactionCountAggregateOutputType = {
    id: number
    bank_account_id: number
    date: number
    description: number
    amount: number
    reference: number
    status: number
    type: number
    system_transaction_id: number
    created_at: number
    updated_at: number
    _all: number
  }


  export type BankTransactionAvgAggregateInputType = {
    amount?: true
  }

  export type BankTransactionSumAggregateInputType = {
    amount?: true
  }

  export type BankTransactionMinAggregateInputType = {
    id?: true
    bank_account_id?: true
    date?: true
    description?: true
    amount?: true
    reference?: true
    status?: true
    type?: true
    system_transaction_id?: true
    created_at?: true
    updated_at?: true
  }

  export type BankTransactionMaxAggregateInputType = {
    id?: true
    bank_account_id?: true
    date?: true
    description?: true
    amount?: true
    reference?: true
    status?: true
    type?: true
    system_transaction_id?: true
    created_at?: true
    updated_at?: true
  }

  export type BankTransactionCountAggregateInputType = {
    id?: true
    bank_account_id?: true
    date?: true
    description?: true
    amount?: true
    reference?: true
    status?: true
    type?: true
    system_transaction_id?: true
    created_at?: true
    updated_at?: true
    _all?: true
  }

  export type BankTransactionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankTransaction to aggregate.
     */
    where?: BankTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankTransactions to fetch.
     */
    orderBy?: BankTransactionOrderByWithRelationInput | BankTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BankTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BankTransactions
    **/
    _count?: true | BankTransactionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BankTransactionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BankTransactionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BankTransactionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BankTransactionMaxAggregateInputType
  }

  export type GetBankTransactionAggregateType<T extends BankTransactionAggregateArgs> = {
        [P in keyof T & keyof AggregateBankTransaction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBankTransaction[P]>
      : GetScalarType<T[P], AggregateBankTransaction[P]>
  }




  export type BankTransactionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BankTransactionWhereInput
    orderBy?: BankTransactionOrderByWithAggregationInput | BankTransactionOrderByWithAggregationInput[]
    by: BankTransactionScalarFieldEnum[] | BankTransactionScalarFieldEnum
    having?: BankTransactionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BankTransactionCountAggregateInputType | true
    _avg?: BankTransactionAvgAggregateInputType
    _sum?: BankTransactionSumAggregateInputType
    _min?: BankTransactionMinAggregateInputType
    _max?: BankTransactionMaxAggregateInputType
  }

  export type BankTransactionGroupByOutputType = {
    id: string
    bank_account_id: string
    date: Date
    description: string
    amount: Decimal
    reference: string | null
    status: string
    type: string
    system_transaction_id: string | null
    created_at: Date
    updated_at: Date
    _count: BankTransactionCountAggregateOutputType | null
    _avg: BankTransactionAvgAggregateOutputType | null
    _sum: BankTransactionSumAggregateOutputType | null
    _min: BankTransactionMinAggregateOutputType | null
    _max: BankTransactionMaxAggregateOutputType | null
  }

  type GetBankTransactionGroupByPayload<T extends BankTransactionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BankTransactionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BankTransactionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BankTransactionGroupByOutputType[P]>
            : GetScalarType<T[P], BankTransactionGroupByOutputType[P]>
        }
      >
    >


  export type BankTransactionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bank_account_id?: boolean
    date?: boolean
    description?: boolean
    amount?: boolean
    reference?: boolean
    status?: boolean
    type?: boolean
    system_transaction_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    bank_account?: boolean | BankAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankTransaction"]>

  export type BankTransactionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bank_account_id?: boolean
    date?: boolean
    description?: boolean
    amount?: boolean
    reference?: boolean
    status?: boolean
    type?: boolean
    system_transaction_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    bank_account?: boolean | BankAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankTransaction"]>

  export type BankTransactionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bank_account_id?: boolean
    date?: boolean
    description?: boolean
    amount?: boolean
    reference?: boolean
    status?: boolean
    type?: boolean
    system_transaction_id?: boolean
    created_at?: boolean
    updated_at?: boolean
    bank_account?: boolean | BankAccountDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bankTransaction"]>

  export type BankTransactionSelectScalar = {
    id?: boolean
    bank_account_id?: boolean
    date?: boolean
    description?: boolean
    amount?: boolean
    reference?: boolean
    status?: boolean
    type?: boolean
    system_transaction_id?: boolean
    created_at?: boolean
    updated_at?: boolean
  }

  export type BankTransactionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bank_account_id" | "date" | "description" | "amount" | "reference" | "status" | "type" | "system_transaction_id" | "created_at" | "updated_at", ExtArgs["result"]["bankTransaction"]>
  export type BankTransactionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bank_account?: boolean | BankAccountDefaultArgs<ExtArgs>
  }
  export type BankTransactionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bank_account?: boolean | BankAccountDefaultArgs<ExtArgs>
  }
  export type BankTransactionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bank_account?: boolean | BankAccountDefaultArgs<ExtArgs>
  }

  export type $BankTransactionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BankTransaction"
    objects: {
      bank_account: Prisma.$BankAccountPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bank_account_id: string
      date: Date
      description: string
      amount: Prisma.Decimal
      reference: string | null
      status: string
      type: string
      system_transaction_id: string | null
      created_at: Date
      updated_at: Date
    }, ExtArgs["result"]["bankTransaction"]>
    composites: {}
  }

  type BankTransactionGetPayload<S extends boolean | null | undefined | BankTransactionDefaultArgs> = $Result.GetResult<Prisma.$BankTransactionPayload, S>

  type BankTransactionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<BankTransactionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BankTransactionCountAggregateInputType | true
    }

  export interface BankTransactionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BankTransaction'], meta: { name: 'BankTransaction' } }
    /**
     * Find zero or one BankTransaction that matches the filter.
     * @param {BankTransactionFindUniqueArgs} args - Arguments to find a BankTransaction
     * @example
     * // Get one BankTransaction
     * const bankTransaction = await prisma.bankTransaction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BankTransactionFindUniqueArgs>(args: SelectSubset<T, BankTransactionFindUniqueArgs<ExtArgs>>): Prisma__BankTransactionClient<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one BankTransaction that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {BankTransactionFindUniqueOrThrowArgs} args - Arguments to find a BankTransaction
     * @example
     * // Get one BankTransaction
     * const bankTransaction = await prisma.bankTransaction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BankTransactionFindUniqueOrThrowArgs>(args: SelectSubset<T, BankTransactionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BankTransactionClient<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankTransaction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankTransactionFindFirstArgs} args - Arguments to find a BankTransaction
     * @example
     * // Get one BankTransaction
     * const bankTransaction = await prisma.bankTransaction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BankTransactionFindFirstArgs>(args?: SelectSubset<T, BankTransactionFindFirstArgs<ExtArgs>>): Prisma__BankTransactionClient<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first BankTransaction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankTransactionFindFirstOrThrowArgs} args - Arguments to find a BankTransaction
     * @example
     * // Get one BankTransaction
     * const bankTransaction = await prisma.bankTransaction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BankTransactionFindFirstOrThrowArgs>(args?: SelectSubset<T, BankTransactionFindFirstOrThrowArgs<ExtArgs>>): Prisma__BankTransactionClient<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more BankTransactions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankTransactionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BankTransactions
     * const bankTransactions = await prisma.bankTransaction.findMany()
     * 
     * // Get first 10 BankTransactions
     * const bankTransactions = await prisma.bankTransaction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bankTransactionWithIdOnly = await prisma.bankTransaction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BankTransactionFindManyArgs>(args?: SelectSubset<T, BankTransactionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a BankTransaction.
     * @param {BankTransactionCreateArgs} args - Arguments to create a BankTransaction.
     * @example
     * // Create one BankTransaction
     * const BankTransaction = await prisma.bankTransaction.create({
     *   data: {
     *     // ... data to create a BankTransaction
     *   }
     * })
     * 
     */
    create<T extends BankTransactionCreateArgs>(args: SelectSubset<T, BankTransactionCreateArgs<ExtArgs>>): Prisma__BankTransactionClient<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many BankTransactions.
     * @param {BankTransactionCreateManyArgs} args - Arguments to create many BankTransactions.
     * @example
     * // Create many BankTransactions
     * const bankTransaction = await prisma.bankTransaction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BankTransactionCreateManyArgs>(args?: SelectSubset<T, BankTransactionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BankTransactions and returns the data saved in the database.
     * @param {BankTransactionCreateManyAndReturnArgs} args - Arguments to create many BankTransactions.
     * @example
     * // Create many BankTransactions
     * const bankTransaction = await prisma.bankTransaction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BankTransactions and only return the `id`
     * const bankTransactionWithIdOnly = await prisma.bankTransaction.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BankTransactionCreateManyAndReturnArgs>(args?: SelectSubset<T, BankTransactionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a BankTransaction.
     * @param {BankTransactionDeleteArgs} args - Arguments to delete one BankTransaction.
     * @example
     * // Delete one BankTransaction
     * const BankTransaction = await prisma.bankTransaction.delete({
     *   where: {
     *     // ... filter to delete one BankTransaction
     *   }
     * })
     * 
     */
    delete<T extends BankTransactionDeleteArgs>(args: SelectSubset<T, BankTransactionDeleteArgs<ExtArgs>>): Prisma__BankTransactionClient<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one BankTransaction.
     * @param {BankTransactionUpdateArgs} args - Arguments to update one BankTransaction.
     * @example
     * // Update one BankTransaction
     * const bankTransaction = await prisma.bankTransaction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BankTransactionUpdateArgs>(args: SelectSubset<T, BankTransactionUpdateArgs<ExtArgs>>): Prisma__BankTransactionClient<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more BankTransactions.
     * @param {BankTransactionDeleteManyArgs} args - Arguments to filter BankTransactions to delete.
     * @example
     * // Delete a few BankTransactions
     * const { count } = await prisma.bankTransaction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BankTransactionDeleteManyArgs>(args?: SelectSubset<T, BankTransactionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankTransactionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BankTransactions
     * const bankTransaction = await prisma.bankTransaction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BankTransactionUpdateManyArgs>(args: SelectSubset<T, BankTransactionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BankTransactions and returns the data updated in the database.
     * @param {BankTransactionUpdateManyAndReturnArgs} args - Arguments to update many BankTransactions.
     * @example
     * // Update many BankTransactions
     * const bankTransaction = await prisma.bankTransaction.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more BankTransactions and only return the `id`
     * const bankTransactionWithIdOnly = await prisma.bankTransaction.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends BankTransactionUpdateManyAndReturnArgs>(args: SelectSubset<T, BankTransactionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one BankTransaction.
     * @param {BankTransactionUpsertArgs} args - Arguments to update or create a BankTransaction.
     * @example
     * // Update or create a BankTransaction
     * const bankTransaction = await prisma.bankTransaction.upsert({
     *   create: {
     *     // ... data to create a BankTransaction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BankTransaction we want to update
     *   }
     * })
     */
    upsert<T extends BankTransactionUpsertArgs>(args: SelectSubset<T, BankTransactionUpsertArgs<ExtArgs>>): Prisma__BankTransactionClient<$Result.GetResult<Prisma.$BankTransactionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of BankTransactions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankTransactionCountArgs} args - Arguments to filter BankTransactions to count.
     * @example
     * // Count the number of BankTransactions
     * const count = await prisma.bankTransaction.count({
     *   where: {
     *     // ... the filter for the BankTransactions we want to count
     *   }
     * })
    **/
    count<T extends BankTransactionCountArgs>(
      args?: Subset<T, BankTransactionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BankTransactionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BankTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankTransactionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BankTransactionAggregateArgs>(args: Subset<T, BankTransactionAggregateArgs>): Prisma.PrismaPromise<GetBankTransactionAggregateType<T>>

    /**
     * Group by BankTransaction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BankTransactionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BankTransactionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BankTransactionGroupByArgs['orderBy'] }
        : { orderBy?: BankTransactionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BankTransactionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBankTransactionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BankTransaction model
   */
  readonly fields: BankTransactionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BankTransaction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BankTransactionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bank_account<T extends BankAccountDefaultArgs<ExtArgs> = {}>(args?: Subset<T, BankAccountDefaultArgs<ExtArgs>>): Prisma__BankAccountClient<$Result.GetResult<Prisma.$BankAccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BankTransaction model
   */
  interface BankTransactionFieldRefs {
    readonly id: FieldRef<"BankTransaction", 'String'>
    readonly bank_account_id: FieldRef<"BankTransaction", 'String'>
    readonly date: FieldRef<"BankTransaction", 'DateTime'>
    readonly description: FieldRef<"BankTransaction", 'String'>
    readonly amount: FieldRef<"BankTransaction", 'Decimal'>
    readonly reference: FieldRef<"BankTransaction", 'String'>
    readonly status: FieldRef<"BankTransaction", 'String'>
    readonly type: FieldRef<"BankTransaction", 'String'>
    readonly system_transaction_id: FieldRef<"BankTransaction", 'String'>
    readonly created_at: FieldRef<"BankTransaction", 'DateTime'>
    readonly updated_at: FieldRef<"BankTransaction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BankTransaction findUnique
   */
  export type BankTransactionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BankTransaction to fetch.
     */
    where: BankTransactionWhereUniqueInput
  }

  /**
   * BankTransaction findUniqueOrThrow
   */
  export type BankTransactionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BankTransaction to fetch.
     */
    where: BankTransactionWhereUniqueInput
  }

  /**
   * BankTransaction findFirst
   */
  export type BankTransactionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BankTransaction to fetch.
     */
    where?: BankTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankTransactions to fetch.
     */
    orderBy?: BankTransactionOrderByWithRelationInput | BankTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankTransactions.
     */
    cursor?: BankTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankTransactions.
     */
    distinct?: BankTransactionScalarFieldEnum | BankTransactionScalarFieldEnum[]
  }

  /**
   * BankTransaction findFirstOrThrow
   */
  export type BankTransactionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BankTransaction to fetch.
     */
    where?: BankTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankTransactions to fetch.
     */
    orderBy?: BankTransactionOrderByWithRelationInput | BankTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BankTransactions.
     */
    cursor?: BankTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankTransactions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BankTransactions.
     */
    distinct?: BankTransactionScalarFieldEnum | BankTransactionScalarFieldEnum[]
  }

  /**
   * BankTransaction findMany
   */
  export type BankTransactionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * Filter, which BankTransactions to fetch.
     */
    where?: BankTransactionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BankTransactions to fetch.
     */
    orderBy?: BankTransactionOrderByWithRelationInput | BankTransactionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BankTransactions.
     */
    cursor?: BankTransactionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BankTransactions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BankTransactions.
     */
    skip?: number
    distinct?: BankTransactionScalarFieldEnum | BankTransactionScalarFieldEnum[]
  }

  /**
   * BankTransaction create
   */
  export type BankTransactionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * The data needed to create a BankTransaction.
     */
    data: XOR<BankTransactionCreateInput, BankTransactionUncheckedCreateInput>
  }

  /**
   * BankTransaction createMany
   */
  export type BankTransactionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BankTransactions.
     */
    data: BankTransactionCreateManyInput | BankTransactionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BankTransaction createManyAndReturn
   */
  export type BankTransactionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * The data used to create many BankTransactions.
     */
    data: BankTransactionCreateManyInput | BankTransactionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BankTransaction update
   */
  export type BankTransactionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * The data needed to update a BankTransaction.
     */
    data: XOR<BankTransactionUpdateInput, BankTransactionUncheckedUpdateInput>
    /**
     * Choose, which BankTransaction to update.
     */
    where: BankTransactionWhereUniqueInput
  }

  /**
   * BankTransaction updateMany
   */
  export type BankTransactionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BankTransactions.
     */
    data: XOR<BankTransactionUpdateManyMutationInput, BankTransactionUncheckedUpdateManyInput>
    /**
     * Filter which BankTransactions to update
     */
    where?: BankTransactionWhereInput
    /**
     * Limit how many BankTransactions to update.
     */
    limit?: number
  }

  /**
   * BankTransaction updateManyAndReturn
   */
  export type BankTransactionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * The data used to update BankTransactions.
     */
    data: XOR<BankTransactionUpdateManyMutationInput, BankTransactionUncheckedUpdateManyInput>
    /**
     * Filter which BankTransactions to update
     */
    where?: BankTransactionWhereInput
    /**
     * Limit how many BankTransactions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * BankTransaction upsert
   */
  export type BankTransactionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * The filter to search for the BankTransaction to update in case it exists.
     */
    where: BankTransactionWhereUniqueInput
    /**
     * In case the BankTransaction found by the `where` argument doesn't exist, create a new BankTransaction with this data.
     */
    create: XOR<BankTransactionCreateInput, BankTransactionUncheckedCreateInput>
    /**
     * In case the BankTransaction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BankTransactionUpdateInput, BankTransactionUncheckedUpdateInput>
  }

  /**
   * BankTransaction delete
   */
  export type BankTransactionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
    /**
     * Filter which BankTransaction to delete.
     */
    where: BankTransactionWhereUniqueInput
  }

  /**
   * BankTransaction deleteMany
   */
  export type BankTransactionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BankTransactions to delete
     */
    where?: BankTransactionWhereInput
    /**
     * Limit how many BankTransactions to delete.
     */
    limit?: number
  }

  /**
   * BankTransaction without action
   */
  export type BankTransactionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BankTransaction
     */
    select?: BankTransactionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the BankTransaction
     */
    omit?: BankTransactionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BankTransactionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    full_name: 'full_name',
    role: 'role',
    avatar_url: 'avatar_url',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const ProjectScalarFieldEnum: {
    id: 'id',
    client_id: 'client_id',
    title: 'title',
    description: 'description',
    status: 'status',
    github_link: 'github_link',
    estimated_cost: 'estimated_cost',
    actual_cost: 'actual_cost',
    deadline: 'deadline',
    test_asset_url: 'test_asset_url',
    deployment_url: 'deployment_url',
    live_preview_type: 'live_preview_type',
    live_preview_url: 'live_preview_url',
    technical_config: 'technical_config',
    tickets: 'tickets',
    notes: 'notes',
    labour_data: 'labour_data',
    inventory_data: 'inventory_data',
    resources_data: 'resources_data',
    design_data: 'design_data',
    expenses_data: 'expenses_data',
    timeline_data: 'timeline_data',
    is_featured: 'is_featured',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type ProjectScalarFieldEnum = (typeof ProjectScalarFieldEnum)[keyof typeof ProjectScalarFieldEnum]


  export const ProjectFileScalarFieldEnum: {
    id: 'id',
    project_id: 'project_id',
    file_name: 'file_name',
    file_url: 'file_url',
    file_type: 'file_type',
    file_size: 'file_size',
    uploaded_by: 'uploaded_by',
    created_at: 'created_at'
  };

  export type ProjectFileScalarFieldEnum = (typeof ProjectFileScalarFieldEnum)[keyof typeof ProjectFileScalarFieldEnum]


  export const ProjectUpdateScalarFieldEnum: {
    id: 'id',
    project_id: 'project_id',
    update_text: 'update_text',
    created_by: 'created_by',
    created_at: 'created_at'
  };

  export type ProjectUpdateScalarFieldEnum = (typeof ProjectUpdateScalarFieldEnum)[keyof typeof ProjectUpdateScalarFieldEnum]


  export const SupportRequestScalarFieldEnum: {
    id: 'id',
    project_id: 'project_id',
    client_id: 'client_id',
    subject: 'subject',
    description: 'description',
    status: 'status',
    priority: 'priority',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type SupportRequestScalarFieldEnum = (typeof SupportRequestScalarFieldEnum)[keyof typeof SupportRequestScalarFieldEnum]


  export const SupportMessageScalarFieldEnum: {
    id: 'id',
    support_request_id: 'support_request_id',
    user_id: 'user_id',
    message: 'message',
    created_at: 'created_at'
  };

  export type SupportMessageScalarFieldEnum = (typeof SupportMessageScalarFieldEnum)[keyof typeof SupportMessageScalarFieldEnum]


  export const MeetingRequestScalarFieldEnum: {
    id: 'id',
    project_id: 'project_id',
    client_id: 'client_id',
    requested_date: 'requested_date',
    duration_minutes: 'duration_minutes',
    purpose: 'purpose',
    status: 'status',
    meeting_link: 'meeting_link',
    admin_notes: 'admin_notes',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type MeetingRequestScalarFieldEnum = (typeof MeetingRequestScalarFieldEnum)[keyof typeof MeetingRequestScalarFieldEnum]


  export const InvoiceScalarFieldEnum: {
    id: 'id',
    project_id: 'project_id',
    client_id: 'client_id',
    invoice_number: 'invoice_number',
    amount: 'amount',
    due_date: 'due_date',
    status: 'status',
    payment_qr_url: 'payment_qr_url',
    bank_details: 'bank_details',
    paid_at: 'paid_at',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type InvoiceScalarFieldEnum = (typeof InvoiceScalarFieldEnum)[keyof typeof InvoiceScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    invoice_id: 'invoice_id',
    amount: 'amount',
    payment_method: 'payment_method',
    transaction_id: 'transaction_id',
    payment_date: 'payment_date',
    notes: 'notes',
    created_at: 'created_at'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    employee_id: 'employee_id',
    name: 'name',
    role: 'role',
    skill_type: 'skill_type',
    employment_type: 'employment_type',
    department: 'department',
    joining_date: 'joining_date',
    basic_salary: 'basic_salary',
    overtime_rate: 'overtime_rate',
    bank_details: 'bank_details',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const AttendanceScalarFieldEnum: {
    id: 'id',
    employee_id: 'employee_id',
    date: 'date',
    status: 'status',
    overtime_hours: 'overtime_hours',
    project_id: 'project_id',
    check_in: 'check_in',
    check_out: 'check_out',
    created_at: 'created_at'
  };

  export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


  export const LabourAllocationScalarFieldEnum: {
    id: 'id',
    employee_id: 'employee_id',
    project_id: 'project_id',
    start_date: 'start_date',
    end_date: 'end_date',
    status: 'status',
    created_at: 'created_at'
  };

  export type LabourAllocationScalarFieldEnum = (typeof LabourAllocationScalarFieldEnum)[keyof typeof LabourAllocationScalarFieldEnum]


  export const PayrollScalarFieldEnum: {
    id: 'id',
    month: 'month',
    status: 'status',
    total_amount: 'total_amount',
    approved_by: 'approved_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PayrollScalarFieldEnum = (typeof PayrollScalarFieldEnum)[keyof typeof PayrollScalarFieldEnum]


  export const PayrollLineScalarFieldEnum: {
    id: 'id',
    payroll_id: 'payroll_id',
    employee_id: 'employee_id',
    basic_pay: 'basic_pay',
    overtime_pay: 'overtime_pay',
    deductions: 'deductions',
    total_pay: 'total_pay',
    status: 'status'
  };

  export type PayrollLineScalarFieldEnum = (typeof PayrollLineScalarFieldEnum)[keyof typeof PayrollLineScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    user_id: 'user_id',
    title: 'title',
    message: 'message',
    type: 'type',
    link: 'link',
    read: 'read',
    created_at: 'created_at'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SystemSettingsScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    updated_at: 'updated_at'
  };

  export type SystemSettingsScalarFieldEnum = (typeof SystemSettingsScalarFieldEnum)[keyof typeof SystemSettingsScalarFieldEnum]


  export const TransactionScalarFieldEnum: {
    id: 'id',
    type: 'type',
    category: 'category',
    amount: 'amount',
    currency: 'currency',
    exchange_rate: 'exchange_rate',
    date: 'date',
    description: 'description',
    notes: 'notes',
    payment_method: 'payment_method',
    reference_number: 'reference_number',
    attachment_url: 'attachment_url',
    tax_rate_id: 'tax_rate_id',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type TransactionScalarFieldEnum = (typeof TransactionScalarFieldEnum)[keyof typeof TransactionScalarFieldEnum]


  export const InventoryItemScalarFieldEnum: {
    id: 'id',
    code: 'code',
    name: 'name',
    category: 'category',
    unit: 'unit',
    current_stock: 'current_stock',
    min_stock: 'min_stock',
    cost_price: 'cost_price',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type InventoryItemScalarFieldEnum = (typeof InventoryItemScalarFieldEnum)[keyof typeof InventoryItemScalarFieldEnum]


  export const InventoryTransactionScalarFieldEnum: {
    id: 'id',
    item_id: 'item_id',
    project_id: 'project_id',
    type: 'type',
    quantity: 'quantity',
    date: 'date',
    reference_no: 'reference_no',
    notes: 'notes',
    created_by: 'created_by',
    created_at: 'created_at'
  };

  export type InventoryTransactionScalarFieldEnum = (typeof InventoryTransactionScalarFieldEnum)[keyof typeof InventoryTransactionScalarFieldEnum]


  export const PurchaseRequestScalarFieldEnum: {
    id: 'id',
    project_id: 'project_id',
    item_name: 'item_name',
    quantity: 'quantity',
    unit: 'unit',
    estimated_cost: 'estimated_cost',
    priority: 'priority',
    status: 'status',
    requested_by: 'requested_by',
    needed_by: 'needed_by',
    notes: 'notes',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PurchaseRequestScalarFieldEnum = (typeof PurchaseRequestScalarFieldEnum)[keyof typeof PurchaseRequestScalarFieldEnum]


  export const VendorScalarFieldEnum: {
    id: 'id',
    name: 'name',
    contact_person: 'contact_person',
    email: 'email',
    phone: 'phone',
    address: 'address',
    vat_no: 'vat_no',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type VendorScalarFieldEnum = (typeof VendorScalarFieldEnum)[keyof typeof VendorScalarFieldEnum]


  export const PurchaseOrderScalarFieldEnum: {
    id: 'id',
    po_number: 'po_number',
    purchase_request_id: 'purchase_request_id',
    vendor_id: 'vendor_id',
    total_amount: 'total_amount',
    status: 'status',
    created_by: 'created_by',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type PurchaseOrderScalarFieldEnum = (typeof PurchaseOrderScalarFieldEnum)[keyof typeof PurchaseOrderScalarFieldEnum]


  export const GRNScalarFieldEnum: {
    id: 'id',
    grn_number: 'grn_number',
    purchase_order_id: 'purchase_order_id',
    received_date: 'received_date',
    received_by: 'received_by',
    notes: 'notes',
    created_at: 'created_at'
  };

  export type GRNScalarFieldEnum = (typeof GRNScalarFieldEnum)[keyof typeof GRNScalarFieldEnum]


  export const VendorBillScalarFieldEnum: {
    id: 'id',
    bill_number: 'bill_number',
    purchase_order_id: 'purchase_order_id',
    vendor_id: 'vendor_id',
    amount: 'amount',
    tax_amount: 'tax_amount',
    due_date: 'due_date',
    status: 'status',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type VendorBillScalarFieldEnum = (typeof VendorBillScalarFieldEnum)[keyof typeof VendorBillScalarFieldEnum]


  export const VendorPaymentScalarFieldEnum: {
    id: 'id',
    vendor_bill_id: 'vendor_bill_id',
    amount: 'amount',
    payment_date: 'payment_date',
    payment_method: 'payment_method',
    reference_no: 'reference_no',
    notes: 'notes',
    created_at: 'created_at'
  };

  export type VendorPaymentScalarFieldEnum = (typeof VendorPaymentScalarFieldEnum)[keyof typeof VendorPaymentScalarFieldEnum]


  export const BankAccountScalarFieldEnum: {
    id: 'id',
    name: 'name',
    account_number: 'account_number',
    bank_name: 'bank_name',
    currency: 'currency',
    current_balance: 'current_balance',
    type: 'type',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type BankAccountScalarFieldEnum = (typeof BankAccountScalarFieldEnum)[keyof typeof BankAccountScalarFieldEnum]


  export const BankTransactionScalarFieldEnum: {
    id: 'id',
    bank_account_id: 'bank_account_id',
    date: 'date',
    description: 'description',
    amount: 'amount',
    reference: 'reference',
    status: 'status',
    type: 'type',
    system_transaction_id: 'system_transaction_id',
    created_at: 'created_at',
    updated_at: 'updated_at'
  };

  export type BankTransactionScalarFieldEnum = (typeof BankTransactionScalarFieldEnum)[keyof typeof BankTransactionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueInput: {
    JsonNull: typeof JsonNull
  };

  export type JsonNullValueInput = (typeof JsonNullValueInput)[keyof typeof JsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'UserRole'
   */
  export type EnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole'>
    


  /**
   * Reference to a field of type 'UserRole[]'
   */
  export type ListEnumUserRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'UserRole[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'ProjectStatus'
   */
  export type EnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus'>
    


  /**
   * Reference to a field of type 'ProjectStatus[]'
   */
  export type ListEnumProjectStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ProjectStatus[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'QueryMode'
   */
  export type EnumQueryModeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'QueryMode'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'FileType'
   */
  export type EnumFileTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileType'>
    


  /**
   * Reference to a field of type 'FileType[]'
   */
  export type ListEnumFileTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileType[]'>
    


  /**
   * Reference to a field of type 'BigInt'
   */
  export type BigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt'>
    


  /**
   * Reference to a field of type 'BigInt[]'
   */
  export type ListBigIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'BigInt[]'>
    


  /**
   * Reference to a field of type 'SupportStatus'
   */
  export type EnumSupportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SupportStatus'>
    


  /**
   * Reference to a field of type 'SupportStatus[]'
   */
  export type ListEnumSupportStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'SupportStatus[]'>
    


  /**
   * Reference to a field of type 'PriorityLevel'
   */
  export type EnumPriorityLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PriorityLevel'>
    


  /**
   * Reference to a field of type 'PriorityLevel[]'
   */
  export type ListEnumPriorityLevelFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PriorityLevel[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'MeetingStatus'
   */
  export type EnumMeetingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MeetingStatus'>
    


  /**
   * Reference to a field of type 'MeetingStatus[]'
   */
  export type ListEnumMeetingStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MeetingStatus[]'>
    


  /**
   * Reference to a field of type 'InvoiceStatus'
   */
  export type EnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus'>
    


  /**
   * Reference to a field of type 'InvoiceStatus[]'
   */
  export type ListEnumInvoiceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InvoiceStatus[]'>
    


  /**
   * Reference to a field of type 'MemberStatus'
   */
  export type EnumMemberStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberStatus'>
    


  /**
   * Reference to a field of type 'MemberStatus[]'
   */
  export type ListEnumMemberStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'MemberStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    


  /**
   * Reference to a field of type 'TransactionType'
   */
  export type EnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType'>
    


  /**
   * Reference to a field of type 'TransactionType[]'
   */
  export type ListEnumTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TransactionType[]'>
    


  /**
   * Reference to a field of type 'InventoryTransactionType'
   */
  export type EnumInventoryTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InventoryTransactionType'>
    


  /**
   * Reference to a field of type 'InventoryTransactionType[]'
   */
  export type ListEnumInventoryTransactionTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'InventoryTransactionType[]'>
    


  /**
   * Reference to a field of type 'PurchaseStatus'
   */
  export type EnumPurchaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PurchaseStatus'>
    


  /**
   * Reference to a field of type 'PurchaseStatus[]'
   */
  export type ListEnumPurchaseStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PurchaseStatus[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringNullableFilter<"User"> | string | null
    full_name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    avatar_url?: StringNullableFilter<"User"> | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    projects?: ProjectListRelationFilter
    project_files?: ProjectFileListRelationFilter
    project_updates?: ProjectUpdateListRelationFilter
    support_requests?: SupportRequestListRelationFilter
    support_messages?: SupportMessageListRelationFilter
    meeting_requests?: MeetingRequestListRelationFilter
    invoices?: InvoiceListRelationFilter
    notifications?: NotificationListRelationFilter
    transactions?: TransactionListRelationFilter
    inventory_logs?: InventoryTransactionListRelationFilter
    purchase_requests?: PurchaseRequestListRelationFilter
    purchase_orders?: PurchaseOrderListRelationFilter
    grns?: GRNListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    full_name?: SortOrder
    role?: SortOrder
    avatar_url?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    projects?: ProjectOrderByRelationAggregateInput
    project_files?: ProjectFileOrderByRelationAggregateInput
    project_updates?: ProjectUpdateOrderByRelationAggregateInput
    support_requests?: SupportRequestOrderByRelationAggregateInput
    support_messages?: SupportMessageOrderByRelationAggregateInput
    meeting_requests?: MeetingRequestOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    transactions?: TransactionOrderByRelationAggregateInput
    inventory_logs?: InventoryTransactionOrderByRelationAggregateInput
    purchase_requests?: PurchaseRequestOrderByRelationAggregateInput
    purchase_orders?: PurchaseOrderOrderByRelationAggregateInput
    grns?: GRNOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringNullableFilter<"User"> | string | null
    full_name?: StringFilter<"User"> | string
    role?: EnumUserRoleFilter<"User"> | $Enums.UserRole
    avatar_url?: StringNullableFilter<"User"> | string | null
    created_at?: DateTimeFilter<"User"> | Date | string
    updated_at?: DateTimeFilter<"User"> | Date | string
    projects?: ProjectListRelationFilter
    project_files?: ProjectFileListRelationFilter
    project_updates?: ProjectUpdateListRelationFilter
    support_requests?: SupportRequestListRelationFilter
    support_messages?: SupportMessageListRelationFilter
    meeting_requests?: MeetingRequestListRelationFilter
    invoices?: InvoiceListRelationFilter
    notifications?: NotificationListRelationFilter
    transactions?: TransactionListRelationFilter
    inventory_logs?: InventoryTransactionListRelationFilter
    purchase_requests?: PurchaseRequestListRelationFilter
    purchase_orders?: PurchaseOrderListRelationFilter
    grns?: GRNListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrderInput | SortOrder
    full_name?: SortOrder
    role?: SortOrder
    avatar_url?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    full_name?: StringWithAggregatesFilter<"User"> | string
    role?: EnumUserRoleWithAggregatesFilter<"User"> | $Enums.UserRole
    avatar_url?: StringNullableWithAggregatesFilter<"User"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type ProjectWhereInput = {
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    id?: StringFilter<"Project"> | string
    client_id?: StringFilter<"Project"> | string
    title?: StringFilter<"Project"> | string
    description?: StringFilter<"Project"> | string
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    github_link?: StringNullableFilter<"Project"> | string | null
    estimated_cost?: DecimalNullableFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
    actual_cost?: DecimalNullableFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
    deadline?: DateTimeNullableFilter<"Project"> | Date | string | null
    test_asset_url?: StringNullableFilter<"Project"> | string | null
    deployment_url?: StringNullableFilter<"Project"> | string | null
    live_preview_type?: StringNullableFilter<"Project"> | string | null
    live_preview_url?: StringNullableFilter<"Project"> | string | null
    technical_config?: JsonNullableFilter<"Project">
    tickets?: JsonNullableFilter<"Project">
    notes?: StringNullableListFilter<"Project">
    labour_data?: JsonNullableFilter<"Project">
    inventory_data?: JsonNullableFilter<"Project">
    resources_data?: JsonNullableFilter<"Project">
    design_data?: JsonNullableFilter<"Project">
    expenses_data?: JsonNullableFilter<"Project">
    timeline_data?: JsonNullableFilter<"Project">
    is_featured?: BoolFilter<"Project"> | boolean
    created_at?: DateTimeFilter<"Project"> | Date | string
    updated_at?: DateTimeFilter<"Project"> | Date | string
    client?: XOR<UserScalarRelationFilter, UserWhereInput>
    files?: ProjectFileListRelationFilter
    updates?: ProjectUpdateListRelationFilter
    support_requests?: SupportRequestListRelationFilter
    meeting_requests?: MeetingRequestListRelationFilter
    invoices?: InvoiceListRelationFilter
    inventory_logs?: InventoryTransactionListRelationFilter
    purchase_requests?: PurchaseRequestListRelationFilter
    attendance?: AttendanceListRelationFilter
    labour_allocations?: LabourAllocationListRelationFilter
  }

  export type ProjectOrderByWithRelationInput = {
    id?: SortOrder
    client_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    github_link?: SortOrderInput | SortOrder
    estimated_cost?: SortOrderInput | SortOrder
    actual_cost?: SortOrderInput | SortOrder
    deadline?: SortOrderInput | SortOrder
    test_asset_url?: SortOrderInput | SortOrder
    deployment_url?: SortOrderInput | SortOrder
    live_preview_type?: SortOrderInput | SortOrder
    live_preview_url?: SortOrderInput | SortOrder
    technical_config?: SortOrderInput | SortOrder
    tickets?: SortOrderInput | SortOrder
    notes?: SortOrder
    labour_data?: SortOrderInput | SortOrder
    inventory_data?: SortOrderInput | SortOrder
    resources_data?: SortOrderInput | SortOrder
    design_data?: SortOrderInput | SortOrder
    expenses_data?: SortOrderInput | SortOrder
    timeline_data?: SortOrderInput | SortOrder
    is_featured?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    client?: UserOrderByWithRelationInput
    files?: ProjectFileOrderByRelationAggregateInput
    updates?: ProjectUpdateOrderByRelationAggregateInput
    support_requests?: SupportRequestOrderByRelationAggregateInput
    meeting_requests?: MeetingRequestOrderByRelationAggregateInput
    invoices?: InvoiceOrderByRelationAggregateInput
    inventory_logs?: InventoryTransactionOrderByRelationAggregateInput
    purchase_requests?: PurchaseRequestOrderByRelationAggregateInput
    attendance?: AttendanceOrderByRelationAggregateInput
    labour_allocations?: LabourAllocationOrderByRelationAggregateInput
  }

  export type ProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectWhereInput | ProjectWhereInput[]
    OR?: ProjectWhereInput[]
    NOT?: ProjectWhereInput | ProjectWhereInput[]
    client_id?: StringFilter<"Project"> | string
    title?: StringFilter<"Project"> | string
    description?: StringFilter<"Project"> | string
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    github_link?: StringNullableFilter<"Project"> | string | null
    estimated_cost?: DecimalNullableFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
    actual_cost?: DecimalNullableFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
    deadline?: DateTimeNullableFilter<"Project"> | Date | string | null
    test_asset_url?: StringNullableFilter<"Project"> | string | null
    deployment_url?: StringNullableFilter<"Project"> | string | null
    live_preview_type?: StringNullableFilter<"Project"> | string | null
    live_preview_url?: StringNullableFilter<"Project"> | string | null
    technical_config?: JsonNullableFilter<"Project">
    tickets?: JsonNullableFilter<"Project">
    notes?: StringNullableListFilter<"Project">
    labour_data?: JsonNullableFilter<"Project">
    inventory_data?: JsonNullableFilter<"Project">
    resources_data?: JsonNullableFilter<"Project">
    design_data?: JsonNullableFilter<"Project">
    expenses_data?: JsonNullableFilter<"Project">
    timeline_data?: JsonNullableFilter<"Project">
    is_featured?: BoolFilter<"Project"> | boolean
    created_at?: DateTimeFilter<"Project"> | Date | string
    updated_at?: DateTimeFilter<"Project"> | Date | string
    client?: XOR<UserScalarRelationFilter, UserWhereInput>
    files?: ProjectFileListRelationFilter
    updates?: ProjectUpdateListRelationFilter
    support_requests?: SupportRequestListRelationFilter
    meeting_requests?: MeetingRequestListRelationFilter
    invoices?: InvoiceListRelationFilter
    inventory_logs?: InventoryTransactionListRelationFilter
    purchase_requests?: PurchaseRequestListRelationFilter
    attendance?: AttendanceListRelationFilter
    labour_allocations?: LabourAllocationListRelationFilter
  }, "id">

  export type ProjectOrderByWithAggregationInput = {
    id?: SortOrder
    client_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    github_link?: SortOrderInput | SortOrder
    estimated_cost?: SortOrderInput | SortOrder
    actual_cost?: SortOrderInput | SortOrder
    deadline?: SortOrderInput | SortOrder
    test_asset_url?: SortOrderInput | SortOrder
    deployment_url?: SortOrderInput | SortOrder
    live_preview_type?: SortOrderInput | SortOrder
    live_preview_url?: SortOrderInput | SortOrder
    technical_config?: SortOrderInput | SortOrder
    tickets?: SortOrderInput | SortOrder
    notes?: SortOrder
    labour_data?: SortOrderInput | SortOrder
    inventory_data?: SortOrderInput | SortOrder
    resources_data?: SortOrderInput | SortOrder
    design_data?: SortOrderInput | SortOrder
    expenses_data?: SortOrderInput | SortOrder
    timeline_data?: SortOrderInput | SortOrder
    is_featured?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: ProjectCountOrderByAggregateInput
    _avg?: ProjectAvgOrderByAggregateInput
    _max?: ProjectMaxOrderByAggregateInput
    _min?: ProjectMinOrderByAggregateInput
    _sum?: ProjectSumOrderByAggregateInput
  }

  export type ProjectScalarWhereWithAggregatesInput = {
    AND?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    OR?: ProjectScalarWhereWithAggregatesInput[]
    NOT?: ProjectScalarWhereWithAggregatesInput | ProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Project"> | string
    client_id?: StringWithAggregatesFilter<"Project"> | string
    title?: StringWithAggregatesFilter<"Project"> | string
    description?: StringWithAggregatesFilter<"Project"> | string
    status?: EnumProjectStatusWithAggregatesFilter<"Project"> | $Enums.ProjectStatus
    github_link?: StringNullableWithAggregatesFilter<"Project"> | string | null
    estimated_cost?: DecimalNullableWithAggregatesFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
    actual_cost?: DecimalNullableWithAggregatesFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
    deadline?: DateTimeNullableWithAggregatesFilter<"Project"> | Date | string | null
    test_asset_url?: StringNullableWithAggregatesFilter<"Project"> | string | null
    deployment_url?: StringNullableWithAggregatesFilter<"Project"> | string | null
    live_preview_type?: StringNullableWithAggregatesFilter<"Project"> | string | null
    live_preview_url?: StringNullableWithAggregatesFilter<"Project"> | string | null
    technical_config?: JsonNullableWithAggregatesFilter<"Project">
    tickets?: JsonNullableWithAggregatesFilter<"Project">
    notes?: StringNullableListFilter<"Project">
    labour_data?: JsonNullableWithAggregatesFilter<"Project">
    inventory_data?: JsonNullableWithAggregatesFilter<"Project">
    resources_data?: JsonNullableWithAggregatesFilter<"Project">
    design_data?: JsonNullableWithAggregatesFilter<"Project">
    expenses_data?: JsonNullableWithAggregatesFilter<"Project">
    timeline_data?: JsonNullableWithAggregatesFilter<"Project">
    is_featured?: BoolWithAggregatesFilter<"Project"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Project"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Project"> | Date | string
  }

  export type ProjectFileWhereInput = {
    AND?: ProjectFileWhereInput | ProjectFileWhereInput[]
    OR?: ProjectFileWhereInput[]
    NOT?: ProjectFileWhereInput | ProjectFileWhereInput[]
    id?: StringFilter<"ProjectFile"> | string
    project_id?: StringFilter<"ProjectFile"> | string
    file_name?: StringFilter<"ProjectFile"> | string
    file_url?: StringFilter<"ProjectFile"> | string
    file_type?: EnumFileTypeFilter<"ProjectFile"> | $Enums.FileType
    file_size?: BigIntFilter<"ProjectFile"> | bigint | number
    uploaded_by?: StringFilter<"ProjectFile"> | string
    created_at?: DateTimeFilter<"ProjectFile"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    uploader?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ProjectFileOrderByWithRelationInput = {
    id?: SortOrder
    project_id?: SortOrder
    file_name?: SortOrder
    file_url?: SortOrder
    file_type?: SortOrder
    file_size?: SortOrder
    uploaded_by?: SortOrder
    created_at?: SortOrder
    project?: ProjectOrderByWithRelationInput
    uploader?: UserOrderByWithRelationInput
  }

  export type ProjectFileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectFileWhereInput | ProjectFileWhereInput[]
    OR?: ProjectFileWhereInput[]
    NOT?: ProjectFileWhereInput | ProjectFileWhereInput[]
    project_id?: StringFilter<"ProjectFile"> | string
    file_name?: StringFilter<"ProjectFile"> | string
    file_url?: StringFilter<"ProjectFile"> | string
    file_type?: EnumFileTypeFilter<"ProjectFile"> | $Enums.FileType
    file_size?: BigIntFilter<"ProjectFile"> | bigint | number
    uploaded_by?: StringFilter<"ProjectFile"> | string
    created_at?: DateTimeFilter<"ProjectFile"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    uploader?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ProjectFileOrderByWithAggregationInput = {
    id?: SortOrder
    project_id?: SortOrder
    file_name?: SortOrder
    file_url?: SortOrder
    file_type?: SortOrder
    file_size?: SortOrder
    uploaded_by?: SortOrder
    created_at?: SortOrder
    _count?: ProjectFileCountOrderByAggregateInput
    _avg?: ProjectFileAvgOrderByAggregateInput
    _max?: ProjectFileMaxOrderByAggregateInput
    _min?: ProjectFileMinOrderByAggregateInput
    _sum?: ProjectFileSumOrderByAggregateInput
  }

  export type ProjectFileScalarWhereWithAggregatesInput = {
    AND?: ProjectFileScalarWhereWithAggregatesInput | ProjectFileScalarWhereWithAggregatesInput[]
    OR?: ProjectFileScalarWhereWithAggregatesInput[]
    NOT?: ProjectFileScalarWhereWithAggregatesInput | ProjectFileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectFile"> | string
    project_id?: StringWithAggregatesFilter<"ProjectFile"> | string
    file_name?: StringWithAggregatesFilter<"ProjectFile"> | string
    file_url?: StringWithAggregatesFilter<"ProjectFile"> | string
    file_type?: EnumFileTypeWithAggregatesFilter<"ProjectFile"> | $Enums.FileType
    file_size?: BigIntWithAggregatesFilter<"ProjectFile"> | bigint | number
    uploaded_by?: StringWithAggregatesFilter<"ProjectFile"> | string
    created_at?: DateTimeWithAggregatesFilter<"ProjectFile"> | Date | string
  }

  export type ProjectUpdateWhereInput = {
    AND?: ProjectUpdateWhereInput | ProjectUpdateWhereInput[]
    OR?: ProjectUpdateWhereInput[]
    NOT?: ProjectUpdateWhereInput | ProjectUpdateWhereInput[]
    id?: StringFilter<"ProjectUpdate"> | string
    project_id?: StringFilter<"ProjectUpdate"> | string
    update_text?: StringFilter<"ProjectUpdate"> | string
    created_by?: StringFilter<"ProjectUpdate"> | string
    created_at?: DateTimeFilter<"ProjectUpdate"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type ProjectUpdateOrderByWithRelationInput = {
    id?: SortOrder
    project_id?: SortOrder
    update_text?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    project?: ProjectOrderByWithRelationInput
    author?: UserOrderByWithRelationInput
  }

  export type ProjectUpdateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ProjectUpdateWhereInput | ProjectUpdateWhereInput[]
    OR?: ProjectUpdateWhereInput[]
    NOT?: ProjectUpdateWhereInput | ProjectUpdateWhereInput[]
    project_id?: StringFilter<"ProjectUpdate"> | string
    update_text?: StringFilter<"ProjectUpdate"> | string
    created_by?: StringFilter<"ProjectUpdate"> | string
    created_at?: DateTimeFilter<"ProjectUpdate"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    author?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type ProjectUpdateOrderByWithAggregationInput = {
    id?: SortOrder
    project_id?: SortOrder
    update_text?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    _count?: ProjectUpdateCountOrderByAggregateInput
    _max?: ProjectUpdateMaxOrderByAggregateInput
    _min?: ProjectUpdateMinOrderByAggregateInput
  }

  export type ProjectUpdateScalarWhereWithAggregatesInput = {
    AND?: ProjectUpdateScalarWhereWithAggregatesInput | ProjectUpdateScalarWhereWithAggregatesInput[]
    OR?: ProjectUpdateScalarWhereWithAggregatesInput[]
    NOT?: ProjectUpdateScalarWhereWithAggregatesInput | ProjectUpdateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ProjectUpdate"> | string
    project_id?: StringWithAggregatesFilter<"ProjectUpdate"> | string
    update_text?: StringWithAggregatesFilter<"ProjectUpdate"> | string
    created_by?: StringWithAggregatesFilter<"ProjectUpdate"> | string
    created_at?: DateTimeWithAggregatesFilter<"ProjectUpdate"> | Date | string
  }

  export type SupportRequestWhereInput = {
    AND?: SupportRequestWhereInput | SupportRequestWhereInput[]
    OR?: SupportRequestWhereInput[]
    NOT?: SupportRequestWhereInput | SupportRequestWhereInput[]
    id?: StringFilter<"SupportRequest"> | string
    project_id?: StringNullableFilter<"SupportRequest"> | string | null
    client_id?: StringFilter<"SupportRequest"> | string
    subject?: StringFilter<"SupportRequest"> | string
    description?: StringFilter<"SupportRequest"> | string
    status?: EnumSupportStatusFilter<"SupportRequest"> | $Enums.SupportStatus
    priority?: EnumPriorityLevelFilter<"SupportRequest"> | $Enums.PriorityLevel
    created_at?: DateTimeFilter<"SupportRequest"> | Date | string
    updated_at?: DateTimeFilter<"SupportRequest"> | Date | string
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    client?: XOR<UserScalarRelationFilter, UserWhereInput>
    messages?: SupportMessageListRelationFilter
  }

  export type SupportRequestOrderByWithRelationInput = {
    id?: SortOrder
    project_id?: SortOrderInput | SortOrder
    client_id?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    project?: ProjectOrderByWithRelationInput
    client?: UserOrderByWithRelationInput
    messages?: SupportMessageOrderByRelationAggregateInput
  }

  export type SupportRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupportRequestWhereInput | SupportRequestWhereInput[]
    OR?: SupportRequestWhereInput[]
    NOT?: SupportRequestWhereInput | SupportRequestWhereInput[]
    project_id?: StringNullableFilter<"SupportRequest"> | string | null
    client_id?: StringFilter<"SupportRequest"> | string
    subject?: StringFilter<"SupportRequest"> | string
    description?: StringFilter<"SupportRequest"> | string
    status?: EnumSupportStatusFilter<"SupportRequest"> | $Enums.SupportStatus
    priority?: EnumPriorityLevelFilter<"SupportRequest"> | $Enums.PriorityLevel
    created_at?: DateTimeFilter<"SupportRequest"> | Date | string
    updated_at?: DateTimeFilter<"SupportRequest"> | Date | string
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    client?: XOR<UserScalarRelationFilter, UserWhereInput>
    messages?: SupportMessageListRelationFilter
  }, "id">

  export type SupportRequestOrderByWithAggregationInput = {
    id?: SortOrder
    project_id?: SortOrderInput | SortOrder
    client_id?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: SupportRequestCountOrderByAggregateInput
    _max?: SupportRequestMaxOrderByAggregateInput
    _min?: SupportRequestMinOrderByAggregateInput
  }

  export type SupportRequestScalarWhereWithAggregatesInput = {
    AND?: SupportRequestScalarWhereWithAggregatesInput | SupportRequestScalarWhereWithAggregatesInput[]
    OR?: SupportRequestScalarWhereWithAggregatesInput[]
    NOT?: SupportRequestScalarWhereWithAggregatesInput | SupportRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SupportRequest"> | string
    project_id?: StringNullableWithAggregatesFilter<"SupportRequest"> | string | null
    client_id?: StringWithAggregatesFilter<"SupportRequest"> | string
    subject?: StringWithAggregatesFilter<"SupportRequest"> | string
    description?: StringWithAggregatesFilter<"SupportRequest"> | string
    status?: EnumSupportStatusWithAggregatesFilter<"SupportRequest"> | $Enums.SupportStatus
    priority?: EnumPriorityLevelWithAggregatesFilter<"SupportRequest"> | $Enums.PriorityLevel
    created_at?: DateTimeWithAggregatesFilter<"SupportRequest"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"SupportRequest"> | Date | string
  }

  export type SupportMessageWhereInput = {
    AND?: SupportMessageWhereInput | SupportMessageWhereInput[]
    OR?: SupportMessageWhereInput[]
    NOT?: SupportMessageWhereInput | SupportMessageWhereInput[]
    id?: StringFilter<"SupportMessage"> | string
    support_request_id?: StringFilter<"SupportMessage"> | string
    user_id?: StringFilter<"SupportMessage"> | string
    message?: StringFilter<"SupportMessage"> | string
    created_at?: DateTimeFilter<"SupportMessage"> | Date | string
    request?: XOR<SupportRequestScalarRelationFilter, SupportRequestWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SupportMessageOrderByWithRelationInput = {
    id?: SortOrder
    support_request_id?: SortOrder
    user_id?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
    request?: SupportRequestOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type SupportMessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SupportMessageWhereInput | SupportMessageWhereInput[]
    OR?: SupportMessageWhereInput[]
    NOT?: SupportMessageWhereInput | SupportMessageWhereInput[]
    support_request_id?: StringFilter<"SupportMessage"> | string
    user_id?: StringFilter<"SupportMessage"> | string
    message?: StringFilter<"SupportMessage"> | string
    created_at?: DateTimeFilter<"SupportMessage"> | Date | string
    request?: XOR<SupportRequestScalarRelationFilter, SupportRequestWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type SupportMessageOrderByWithAggregationInput = {
    id?: SortOrder
    support_request_id?: SortOrder
    user_id?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
    _count?: SupportMessageCountOrderByAggregateInput
    _max?: SupportMessageMaxOrderByAggregateInput
    _min?: SupportMessageMinOrderByAggregateInput
  }

  export type SupportMessageScalarWhereWithAggregatesInput = {
    AND?: SupportMessageScalarWhereWithAggregatesInput | SupportMessageScalarWhereWithAggregatesInput[]
    OR?: SupportMessageScalarWhereWithAggregatesInput[]
    NOT?: SupportMessageScalarWhereWithAggregatesInput | SupportMessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SupportMessage"> | string
    support_request_id?: StringWithAggregatesFilter<"SupportMessage"> | string
    user_id?: StringWithAggregatesFilter<"SupportMessage"> | string
    message?: StringWithAggregatesFilter<"SupportMessage"> | string
    created_at?: DateTimeWithAggregatesFilter<"SupportMessage"> | Date | string
  }

  export type MeetingRequestWhereInput = {
    AND?: MeetingRequestWhereInput | MeetingRequestWhereInput[]
    OR?: MeetingRequestWhereInput[]
    NOT?: MeetingRequestWhereInput | MeetingRequestWhereInput[]
    id?: StringFilter<"MeetingRequest"> | string
    project_id?: StringNullableFilter<"MeetingRequest"> | string | null
    client_id?: StringFilter<"MeetingRequest"> | string
    requested_date?: DateTimeFilter<"MeetingRequest"> | Date | string
    duration_minutes?: IntFilter<"MeetingRequest"> | number
    purpose?: StringFilter<"MeetingRequest"> | string
    status?: EnumMeetingStatusFilter<"MeetingRequest"> | $Enums.MeetingStatus
    meeting_link?: StringNullableFilter<"MeetingRequest"> | string | null
    admin_notes?: StringNullableFilter<"MeetingRequest"> | string | null
    created_at?: DateTimeFilter<"MeetingRequest"> | Date | string
    updated_at?: DateTimeFilter<"MeetingRequest"> | Date | string
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    client?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MeetingRequestOrderByWithRelationInput = {
    id?: SortOrder
    project_id?: SortOrderInput | SortOrder
    client_id?: SortOrder
    requested_date?: SortOrder
    duration_minutes?: SortOrder
    purpose?: SortOrder
    status?: SortOrder
    meeting_link?: SortOrderInput | SortOrder
    admin_notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    project?: ProjectOrderByWithRelationInput
    client?: UserOrderByWithRelationInput
  }

  export type MeetingRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MeetingRequestWhereInput | MeetingRequestWhereInput[]
    OR?: MeetingRequestWhereInput[]
    NOT?: MeetingRequestWhereInput | MeetingRequestWhereInput[]
    project_id?: StringNullableFilter<"MeetingRequest"> | string | null
    client_id?: StringFilter<"MeetingRequest"> | string
    requested_date?: DateTimeFilter<"MeetingRequest"> | Date | string
    duration_minutes?: IntFilter<"MeetingRequest"> | number
    purpose?: StringFilter<"MeetingRequest"> | string
    status?: EnumMeetingStatusFilter<"MeetingRequest"> | $Enums.MeetingStatus
    meeting_link?: StringNullableFilter<"MeetingRequest"> | string | null
    admin_notes?: StringNullableFilter<"MeetingRequest"> | string | null
    created_at?: DateTimeFilter<"MeetingRequest"> | Date | string
    updated_at?: DateTimeFilter<"MeetingRequest"> | Date | string
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    client?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MeetingRequestOrderByWithAggregationInput = {
    id?: SortOrder
    project_id?: SortOrderInput | SortOrder
    client_id?: SortOrder
    requested_date?: SortOrder
    duration_minutes?: SortOrder
    purpose?: SortOrder
    status?: SortOrder
    meeting_link?: SortOrderInput | SortOrder
    admin_notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: MeetingRequestCountOrderByAggregateInput
    _avg?: MeetingRequestAvgOrderByAggregateInput
    _max?: MeetingRequestMaxOrderByAggregateInput
    _min?: MeetingRequestMinOrderByAggregateInput
    _sum?: MeetingRequestSumOrderByAggregateInput
  }

  export type MeetingRequestScalarWhereWithAggregatesInput = {
    AND?: MeetingRequestScalarWhereWithAggregatesInput | MeetingRequestScalarWhereWithAggregatesInput[]
    OR?: MeetingRequestScalarWhereWithAggregatesInput[]
    NOT?: MeetingRequestScalarWhereWithAggregatesInput | MeetingRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"MeetingRequest"> | string
    project_id?: StringNullableWithAggregatesFilter<"MeetingRequest"> | string | null
    client_id?: StringWithAggregatesFilter<"MeetingRequest"> | string
    requested_date?: DateTimeWithAggregatesFilter<"MeetingRequest"> | Date | string
    duration_minutes?: IntWithAggregatesFilter<"MeetingRequest"> | number
    purpose?: StringWithAggregatesFilter<"MeetingRequest"> | string
    status?: EnumMeetingStatusWithAggregatesFilter<"MeetingRequest"> | $Enums.MeetingStatus
    meeting_link?: StringNullableWithAggregatesFilter<"MeetingRequest"> | string | null
    admin_notes?: StringNullableWithAggregatesFilter<"MeetingRequest"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"MeetingRequest"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"MeetingRequest"> | Date | string
  }

  export type InvoiceWhereInput = {
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    id?: StringFilter<"Invoice"> | string
    project_id?: StringFilter<"Invoice"> | string
    client_id?: StringFilter<"Invoice"> | string
    invoice_number?: StringFilter<"Invoice"> | string
    amount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    due_date?: DateTimeFilter<"Invoice"> | Date | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    payment_qr_url?: StringNullableFilter<"Invoice"> | string | null
    bank_details?: JsonNullableFilter<"Invoice">
    paid_at?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    created_at?: DateTimeFilter<"Invoice"> | Date | string
    updated_at?: DateTimeFilter<"Invoice"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    client?: XOR<UserScalarRelationFilter, UserWhereInput>
    payments?: PaymentListRelationFilter
  }

  export type InvoiceOrderByWithRelationInput = {
    id?: SortOrder
    project_id?: SortOrder
    client_id?: SortOrder
    invoice_number?: SortOrder
    amount?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    payment_qr_url?: SortOrderInput | SortOrder
    bank_details?: SortOrderInput | SortOrder
    paid_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    project?: ProjectOrderByWithRelationInput
    client?: UserOrderByWithRelationInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type InvoiceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    invoice_number?: string
    AND?: InvoiceWhereInput | InvoiceWhereInput[]
    OR?: InvoiceWhereInput[]
    NOT?: InvoiceWhereInput | InvoiceWhereInput[]
    project_id?: StringFilter<"Invoice"> | string
    client_id?: StringFilter<"Invoice"> | string
    amount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    due_date?: DateTimeFilter<"Invoice"> | Date | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    payment_qr_url?: StringNullableFilter<"Invoice"> | string | null
    bank_details?: JsonNullableFilter<"Invoice">
    paid_at?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    created_at?: DateTimeFilter<"Invoice"> | Date | string
    updated_at?: DateTimeFilter<"Invoice"> | Date | string
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
    client?: XOR<UserScalarRelationFilter, UserWhereInput>
    payments?: PaymentListRelationFilter
  }, "id" | "invoice_number">

  export type InvoiceOrderByWithAggregationInput = {
    id?: SortOrder
    project_id?: SortOrder
    client_id?: SortOrder
    invoice_number?: SortOrder
    amount?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    payment_qr_url?: SortOrderInput | SortOrder
    bank_details?: SortOrderInput | SortOrder
    paid_at?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: InvoiceCountOrderByAggregateInput
    _avg?: InvoiceAvgOrderByAggregateInput
    _max?: InvoiceMaxOrderByAggregateInput
    _min?: InvoiceMinOrderByAggregateInput
    _sum?: InvoiceSumOrderByAggregateInput
  }

  export type InvoiceScalarWhereWithAggregatesInput = {
    AND?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    OR?: InvoiceScalarWhereWithAggregatesInput[]
    NOT?: InvoiceScalarWhereWithAggregatesInput | InvoiceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Invoice"> | string
    project_id?: StringWithAggregatesFilter<"Invoice"> | string
    client_id?: StringWithAggregatesFilter<"Invoice"> | string
    invoice_number?: StringWithAggregatesFilter<"Invoice"> | string
    amount?: DecimalWithAggregatesFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    due_date?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    status?: EnumInvoiceStatusWithAggregatesFilter<"Invoice"> | $Enums.InvoiceStatus
    payment_qr_url?: StringNullableWithAggregatesFilter<"Invoice"> | string | null
    bank_details?: JsonNullableWithAggregatesFilter<"Invoice">
    paid_at?: DateTimeNullableWithAggregatesFilter<"Invoice"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Invoice"> | Date | string
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    invoice_id?: StringFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    payment_method?: StringFilter<"Payment"> | string
    transaction_id?: StringNullableFilter<"Payment"> | string | null
    payment_date?: DateTimeFilter<"Payment"> | Date | string
    notes?: StringNullableFilter<"Payment"> | string | null
    created_at?: DateTimeFilter<"Payment"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    amount?: SortOrder
    payment_method?: SortOrder
    transaction_id?: SortOrderInput | SortOrder
    payment_date?: SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    invoice?: InvoiceOrderByWithRelationInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    invoice_id?: StringFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    payment_method?: StringFilter<"Payment"> | string
    transaction_id?: StringNullableFilter<"Payment"> | string | null
    payment_date?: DateTimeFilter<"Payment"> | Date | string
    notes?: StringNullableFilter<"Payment"> | string | null
    created_at?: DateTimeFilter<"Payment"> | Date | string
    invoice?: XOR<InvoiceScalarRelationFilter, InvoiceWhereInput>
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    amount?: SortOrder
    payment_method?: SortOrder
    transaction_id?: SortOrderInput | SortOrder
    payment_date?: SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    invoice_id?: StringWithAggregatesFilter<"Payment"> | string
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    payment_method?: StringWithAggregatesFilter<"Payment"> | string
    transaction_id?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    payment_date?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    notes?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    id?: StringFilter<"Employee"> | string
    employee_id?: StringFilter<"Employee"> | string
    name?: StringFilter<"Employee"> | string
    role?: StringFilter<"Employee"> | string
    skill_type?: StringFilter<"Employee"> | string
    employment_type?: StringFilter<"Employee"> | string
    department?: StringNullableFilter<"Employee"> | string | null
    joining_date?: DateTimeFilter<"Employee"> | Date | string
    basic_salary?: DecimalFilter<"Employee"> | Decimal | DecimalJsLike | number | string
    overtime_rate?: DecimalFilter<"Employee"> | Decimal | DecimalJsLike | number | string
    bank_details?: JsonNullableFilter<"Employee">
    status?: EnumMemberStatusFilter<"Employee"> | $Enums.MemberStatus
    created_at?: DateTimeFilter<"Employee"> | Date | string
    updated_at?: DateTimeFilter<"Employee"> | Date | string
    attendance?: AttendanceListRelationFilter
    allocations?: LabourAllocationListRelationFilter
    payroll_items?: PayrollLineListRelationFilter
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    employee_id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    skill_type?: SortOrder
    employment_type?: SortOrder
    department?: SortOrderInput | SortOrder
    joining_date?: SortOrder
    basic_salary?: SortOrder
    overtime_rate?: SortOrder
    bank_details?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    attendance?: AttendanceOrderByRelationAggregateInput
    allocations?: LabourAllocationOrderByRelationAggregateInput
    payroll_items?: PayrollLineOrderByRelationAggregateInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    employee_id?: string
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    name?: StringFilter<"Employee"> | string
    role?: StringFilter<"Employee"> | string
    skill_type?: StringFilter<"Employee"> | string
    employment_type?: StringFilter<"Employee"> | string
    department?: StringNullableFilter<"Employee"> | string | null
    joining_date?: DateTimeFilter<"Employee"> | Date | string
    basic_salary?: DecimalFilter<"Employee"> | Decimal | DecimalJsLike | number | string
    overtime_rate?: DecimalFilter<"Employee"> | Decimal | DecimalJsLike | number | string
    bank_details?: JsonNullableFilter<"Employee">
    status?: EnumMemberStatusFilter<"Employee"> | $Enums.MemberStatus
    created_at?: DateTimeFilter<"Employee"> | Date | string
    updated_at?: DateTimeFilter<"Employee"> | Date | string
    attendance?: AttendanceListRelationFilter
    allocations?: LabourAllocationListRelationFilter
    payroll_items?: PayrollLineListRelationFilter
  }, "id" | "employee_id">

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    employee_id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    skill_type?: SortOrder
    employment_type?: SortOrder
    department?: SortOrderInput | SortOrder
    joining_date?: SortOrder
    basic_salary?: SortOrder
    overtime_rate?: SortOrder
    bank_details?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _avg?: EmployeeAvgOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
    _sum?: EmployeeSumOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Employee"> | string
    employee_id?: StringWithAggregatesFilter<"Employee"> | string
    name?: StringWithAggregatesFilter<"Employee"> | string
    role?: StringWithAggregatesFilter<"Employee"> | string
    skill_type?: StringWithAggregatesFilter<"Employee"> | string
    employment_type?: StringWithAggregatesFilter<"Employee"> | string
    department?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    joining_date?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    basic_salary?: DecimalWithAggregatesFilter<"Employee"> | Decimal | DecimalJsLike | number | string
    overtime_rate?: DecimalWithAggregatesFilter<"Employee"> | Decimal | DecimalJsLike | number | string
    bank_details?: JsonNullableWithAggregatesFilter<"Employee">
    status?: EnumMemberStatusWithAggregatesFilter<"Employee"> | $Enums.MemberStatus
    created_at?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
  }

  export type AttendanceWhereInput = {
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    id?: StringFilter<"Attendance"> | string
    employee_id?: StringFilter<"Attendance"> | string
    date?: DateTimeFilter<"Attendance"> | Date | string
    status?: StringFilter<"Attendance"> | string
    overtime_hours?: FloatFilter<"Attendance"> | number
    project_id?: StringNullableFilter<"Attendance"> | string | null
    check_in?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    check_out?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    created_at?: DateTimeFilter<"Attendance"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
  }

  export type AttendanceOrderByWithRelationInput = {
    id?: SortOrder
    employee_id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    overtime_hours?: SortOrder
    project_id?: SortOrderInput | SortOrder
    check_in?: SortOrderInput | SortOrder
    check_out?: SortOrderInput | SortOrder
    created_at?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
  }

  export type AttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    employee_id_date?: AttendanceEmployee_idDateCompoundUniqueInput
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    employee_id?: StringFilter<"Attendance"> | string
    date?: DateTimeFilter<"Attendance"> | Date | string
    status?: StringFilter<"Attendance"> | string
    overtime_hours?: FloatFilter<"Attendance"> | number
    project_id?: StringNullableFilter<"Attendance"> | string | null
    check_in?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    check_out?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    created_at?: DateTimeFilter<"Attendance"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
  }, "id" | "employee_id_date">

  export type AttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    employee_id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    overtime_hours?: SortOrder
    project_id?: SortOrderInput | SortOrder
    check_in?: SortOrderInput | SortOrder
    check_out?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: AttendanceCountOrderByAggregateInput
    _avg?: AttendanceAvgOrderByAggregateInput
    _max?: AttendanceMaxOrderByAggregateInput
    _min?: AttendanceMinOrderByAggregateInput
    _sum?: AttendanceSumOrderByAggregateInput
  }

  export type AttendanceScalarWhereWithAggregatesInput = {
    AND?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    OR?: AttendanceScalarWhereWithAggregatesInput[]
    NOT?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attendance"> | string
    employee_id?: StringWithAggregatesFilter<"Attendance"> | string
    date?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
    status?: StringWithAggregatesFilter<"Attendance"> | string
    overtime_hours?: FloatWithAggregatesFilter<"Attendance"> | number
    project_id?: StringNullableWithAggregatesFilter<"Attendance"> | string | null
    check_in?: DateTimeNullableWithAggregatesFilter<"Attendance"> | Date | string | null
    check_out?: DateTimeNullableWithAggregatesFilter<"Attendance"> | Date | string | null
    created_at?: DateTimeWithAggregatesFilter<"Attendance"> | Date | string
  }

  export type LabourAllocationWhereInput = {
    AND?: LabourAllocationWhereInput | LabourAllocationWhereInput[]
    OR?: LabourAllocationWhereInput[]
    NOT?: LabourAllocationWhereInput | LabourAllocationWhereInput[]
    id?: StringFilter<"LabourAllocation"> | string
    employee_id?: StringFilter<"LabourAllocation"> | string
    project_id?: StringFilter<"LabourAllocation"> | string
    start_date?: DateTimeFilter<"LabourAllocation"> | Date | string
    end_date?: DateTimeNullableFilter<"LabourAllocation"> | Date | string | null
    status?: StringFilter<"LabourAllocation"> | string
    created_at?: DateTimeFilter<"LabourAllocation"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }

  export type LabourAllocationOrderByWithRelationInput = {
    id?: SortOrder
    employee_id?: SortOrder
    project_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    employee?: EmployeeOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
  }

  export type LabourAllocationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LabourAllocationWhereInput | LabourAllocationWhereInput[]
    OR?: LabourAllocationWhereInput[]
    NOT?: LabourAllocationWhereInput | LabourAllocationWhereInput[]
    employee_id?: StringFilter<"LabourAllocation"> | string
    project_id?: StringFilter<"LabourAllocation"> | string
    start_date?: DateTimeFilter<"LabourAllocation"> | Date | string
    end_date?: DateTimeNullableFilter<"LabourAllocation"> | Date | string | null
    status?: StringFilter<"LabourAllocation"> | string
    created_at?: DateTimeFilter<"LabourAllocation"> | Date | string
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
    project?: XOR<ProjectScalarRelationFilter, ProjectWhereInput>
  }, "id">

  export type LabourAllocationOrderByWithAggregationInput = {
    id?: SortOrder
    employee_id?: SortOrder
    project_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrderInput | SortOrder
    status?: SortOrder
    created_at?: SortOrder
    _count?: LabourAllocationCountOrderByAggregateInput
    _max?: LabourAllocationMaxOrderByAggregateInput
    _min?: LabourAllocationMinOrderByAggregateInput
  }

  export type LabourAllocationScalarWhereWithAggregatesInput = {
    AND?: LabourAllocationScalarWhereWithAggregatesInput | LabourAllocationScalarWhereWithAggregatesInput[]
    OR?: LabourAllocationScalarWhereWithAggregatesInput[]
    NOT?: LabourAllocationScalarWhereWithAggregatesInput | LabourAllocationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LabourAllocation"> | string
    employee_id?: StringWithAggregatesFilter<"LabourAllocation"> | string
    project_id?: StringWithAggregatesFilter<"LabourAllocation"> | string
    start_date?: DateTimeWithAggregatesFilter<"LabourAllocation"> | Date | string
    end_date?: DateTimeNullableWithAggregatesFilter<"LabourAllocation"> | Date | string | null
    status?: StringWithAggregatesFilter<"LabourAllocation"> | string
    created_at?: DateTimeWithAggregatesFilter<"LabourAllocation"> | Date | string
  }

  export type PayrollWhereInput = {
    AND?: PayrollWhereInput | PayrollWhereInput[]
    OR?: PayrollWhereInput[]
    NOT?: PayrollWhereInput | PayrollWhereInput[]
    id?: StringFilter<"Payroll"> | string
    month?: StringFilter<"Payroll"> | string
    status?: StringFilter<"Payroll"> | string
    total_amount?: DecimalFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    approved_by?: StringNullableFilter<"Payroll"> | string | null
    created_at?: DateTimeFilter<"Payroll"> | Date | string
    updated_at?: DateTimeFilter<"Payroll"> | Date | string
    lines?: PayrollLineListRelationFilter
  }

  export type PayrollOrderByWithRelationInput = {
    id?: SortOrder
    month?: SortOrder
    status?: SortOrder
    total_amount?: SortOrder
    approved_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    lines?: PayrollLineOrderByRelationAggregateInput
  }

  export type PayrollWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    month?: string
    AND?: PayrollWhereInput | PayrollWhereInput[]
    OR?: PayrollWhereInput[]
    NOT?: PayrollWhereInput | PayrollWhereInput[]
    status?: StringFilter<"Payroll"> | string
    total_amount?: DecimalFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    approved_by?: StringNullableFilter<"Payroll"> | string | null
    created_at?: DateTimeFilter<"Payroll"> | Date | string
    updated_at?: DateTimeFilter<"Payroll"> | Date | string
    lines?: PayrollLineListRelationFilter
  }, "id" | "month">

  export type PayrollOrderByWithAggregationInput = {
    id?: SortOrder
    month?: SortOrder
    status?: SortOrder
    total_amount?: SortOrder
    approved_by?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: PayrollCountOrderByAggregateInput
    _avg?: PayrollAvgOrderByAggregateInput
    _max?: PayrollMaxOrderByAggregateInput
    _min?: PayrollMinOrderByAggregateInput
    _sum?: PayrollSumOrderByAggregateInput
  }

  export type PayrollScalarWhereWithAggregatesInput = {
    AND?: PayrollScalarWhereWithAggregatesInput | PayrollScalarWhereWithAggregatesInput[]
    OR?: PayrollScalarWhereWithAggregatesInput[]
    NOT?: PayrollScalarWhereWithAggregatesInput | PayrollScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payroll"> | string
    month?: StringWithAggregatesFilter<"Payroll"> | string
    status?: StringWithAggregatesFilter<"Payroll"> | string
    total_amount?: DecimalWithAggregatesFilter<"Payroll"> | Decimal | DecimalJsLike | number | string
    approved_by?: StringNullableWithAggregatesFilter<"Payroll"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Payroll"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Payroll"> | Date | string
  }

  export type PayrollLineWhereInput = {
    AND?: PayrollLineWhereInput | PayrollLineWhereInput[]
    OR?: PayrollLineWhereInput[]
    NOT?: PayrollLineWhereInput | PayrollLineWhereInput[]
    id?: StringFilter<"PayrollLine"> | string
    payroll_id?: StringFilter<"PayrollLine"> | string
    employee_id?: StringFilter<"PayrollLine"> | string
    basic_pay?: DecimalFilter<"PayrollLine"> | Decimal | DecimalJsLike | number | string
    overtime_pay?: DecimalFilter<"PayrollLine"> | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFilter<"PayrollLine"> | Decimal | DecimalJsLike | number | string
    total_pay?: DecimalFilter<"PayrollLine"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"PayrollLine"> | string
    payroll?: XOR<PayrollScalarRelationFilter, PayrollWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }

  export type PayrollLineOrderByWithRelationInput = {
    id?: SortOrder
    payroll_id?: SortOrder
    employee_id?: SortOrder
    basic_pay?: SortOrder
    overtime_pay?: SortOrder
    deductions?: SortOrder
    total_pay?: SortOrder
    status?: SortOrder
    payroll?: PayrollOrderByWithRelationInput
    employee?: EmployeeOrderByWithRelationInput
  }

  export type PayrollLineWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PayrollLineWhereInput | PayrollLineWhereInput[]
    OR?: PayrollLineWhereInput[]
    NOT?: PayrollLineWhereInput | PayrollLineWhereInput[]
    payroll_id?: StringFilter<"PayrollLine"> | string
    employee_id?: StringFilter<"PayrollLine"> | string
    basic_pay?: DecimalFilter<"PayrollLine"> | Decimal | DecimalJsLike | number | string
    overtime_pay?: DecimalFilter<"PayrollLine"> | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFilter<"PayrollLine"> | Decimal | DecimalJsLike | number | string
    total_pay?: DecimalFilter<"PayrollLine"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"PayrollLine"> | string
    payroll?: XOR<PayrollScalarRelationFilter, PayrollWhereInput>
    employee?: XOR<EmployeeScalarRelationFilter, EmployeeWhereInput>
  }, "id">

  export type PayrollLineOrderByWithAggregationInput = {
    id?: SortOrder
    payroll_id?: SortOrder
    employee_id?: SortOrder
    basic_pay?: SortOrder
    overtime_pay?: SortOrder
    deductions?: SortOrder
    total_pay?: SortOrder
    status?: SortOrder
    _count?: PayrollLineCountOrderByAggregateInput
    _avg?: PayrollLineAvgOrderByAggregateInput
    _max?: PayrollLineMaxOrderByAggregateInput
    _min?: PayrollLineMinOrderByAggregateInput
    _sum?: PayrollLineSumOrderByAggregateInput
  }

  export type PayrollLineScalarWhereWithAggregatesInput = {
    AND?: PayrollLineScalarWhereWithAggregatesInput | PayrollLineScalarWhereWithAggregatesInput[]
    OR?: PayrollLineScalarWhereWithAggregatesInput[]
    NOT?: PayrollLineScalarWhereWithAggregatesInput | PayrollLineScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PayrollLine"> | string
    payroll_id?: StringWithAggregatesFilter<"PayrollLine"> | string
    employee_id?: StringWithAggregatesFilter<"PayrollLine"> | string
    basic_pay?: DecimalWithAggregatesFilter<"PayrollLine"> | Decimal | DecimalJsLike | number | string
    overtime_pay?: DecimalWithAggregatesFilter<"PayrollLine"> | Decimal | DecimalJsLike | number | string
    deductions?: DecimalWithAggregatesFilter<"PayrollLine"> | Decimal | DecimalJsLike | number | string
    total_pay?: DecimalWithAggregatesFilter<"PayrollLine"> | Decimal | DecimalJsLike | number | string
    status?: StringWithAggregatesFilter<"PayrollLine"> | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    user_id?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    link?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    created_at?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    link?: SortOrderInput | SortOrder
    read?: SortOrder
    created_at?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    user_id?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    link?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    created_at?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    link?: SortOrderInput | SortOrder
    read?: SortOrder
    created_at?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    user_id?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    link?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    read?: BoolWithAggregatesFilter<"Notification"> | boolean
    created_at?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type SystemSettingsWhereInput = {
    AND?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    OR?: SystemSettingsWhereInput[]
    NOT?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    id?: StringFilter<"SystemSettings"> | string
    key?: StringFilter<"SystemSettings"> | string
    value?: JsonFilter<"SystemSettings">
    updated_at?: DateTimeFilter<"SystemSettings"> | Date | string
  }

  export type SystemSettingsOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    updated_at?: SortOrder
  }

  export type SystemSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    OR?: SystemSettingsWhereInput[]
    NOT?: SystemSettingsWhereInput | SystemSettingsWhereInput[]
    value?: JsonFilter<"SystemSettings">
    updated_at?: DateTimeFilter<"SystemSettings"> | Date | string
  }, "id" | "key">

  export type SystemSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    updated_at?: SortOrder
    _count?: SystemSettingsCountOrderByAggregateInput
    _max?: SystemSettingsMaxOrderByAggregateInput
    _min?: SystemSettingsMinOrderByAggregateInput
  }

  export type SystemSettingsScalarWhereWithAggregatesInput = {
    AND?: SystemSettingsScalarWhereWithAggregatesInput | SystemSettingsScalarWhereWithAggregatesInput[]
    OR?: SystemSettingsScalarWhereWithAggregatesInput[]
    NOT?: SystemSettingsScalarWhereWithAggregatesInput | SystemSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SystemSettings"> | string
    key?: StringWithAggregatesFilter<"SystemSettings"> | string
    value?: JsonWithAggregatesFilter<"SystemSettings">
    updated_at?: DateTimeWithAggregatesFilter<"SystemSettings"> | Date | string
  }

  export type TransactionWhereInput = {
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    id?: StringFilter<"Transaction"> | string
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    category?: StringFilter<"Transaction"> | string
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Transaction"> | string
    exchange_rate?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    date?: DateTimeFilter<"Transaction"> | Date | string
    description?: StringNullableFilter<"Transaction"> | string | null
    notes?: StringNullableFilter<"Transaction"> | string | null
    payment_method?: StringNullableFilter<"Transaction"> | string | null
    reference_number?: StringNullableFilter<"Transaction"> | string | null
    attachment_url?: StringNullableFilter<"Transaction"> | string | null
    tax_rate_id?: StringNullableFilter<"Transaction"> | string | null
    created_by?: StringFilter<"Transaction"> | string
    created_at?: DateTimeFilter<"Transaction"> | Date | string
    updated_at?: DateTimeFilter<"Transaction"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TransactionOrderByWithRelationInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    exchange_rate?: SortOrderInput | SortOrder
    date?: SortOrder
    description?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    payment_method?: SortOrderInput | SortOrder
    reference_number?: SortOrderInput | SortOrder
    attachment_url?: SortOrderInput | SortOrder
    tax_rate_id?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    creator?: UserOrderByWithRelationInput
  }

  export type TransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TransactionWhereInput | TransactionWhereInput[]
    OR?: TransactionWhereInput[]
    NOT?: TransactionWhereInput | TransactionWhereInput[]
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    category?: StringFilter<"Transaction"> | string
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Transaction"> | string
    exchange_rate?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    date?: DateTimeFilter<"Transaction"> | Date | string
    description?: StringNullableFilter<"Transaction"> | string | null
    notes?: StringNullableFilter<"Transaction"> | string | null
    payment_method?: StringNullableFilter<"Transaction"> | string | null
    reference_number?: StringNullableFilter<"Transaction"> | string | null
    attachment_url?: StringNullableFilter<"Transaction"> | string | null
    tax_rate_id?: StringNullableFilter<"Transaction"> | string | null
    created_by?: StringFilter<"Transaction"> | string
    created_at?: DateTimeFilter<"Transaction"> | Date | string
    updated_at?: DateTimeFilter<"Transaction"> | Date | string
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TransactionOrderByWithAggregationInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    exchange_rate?: SortOrderInput | SortOrder
    date?: SortOrder
    description?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    payment_method?: SortOrderInput | SortOrder
    reference_number?: SortOrderInput | SortOrder
    attachment_url?: SortOrderInput | SortOrder
    tax_rate_id?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: TransactionCountOrderByAggregateInput
    _avg?: TransactionAvgOrderByAggregateInput
    _max?: TransactionMaxOrderByAggregateInput
    _min?: TransactionMinOrderByAggregateInput
    _sum?: TransactionSumOrderByAggregateInput
  }

  export type TransactionScalarWhereWithAggregatesInput = {
    AND?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    OR?: TransactionScalarWhereWithAggregatesInput[]
    NOT?: TransactionScalarWhereWithAggregatesInput | TransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Transaction"> | string
    type?: EnumTransactionTypeWithAggregatesFilter<"Transaction"> | $Enums.TransactionType
    category?: StringWithAggregatesFilter<"Transaction"> | string
    amount?: DecimalWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringWithAggregatesFilter<"Transaction"> | string
    exchange_rate?: DecimalNullableWithAggregatesFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    date?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    description?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    notes?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    payment_method?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    reference_number?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    attachment_url?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    tax_rate_id?: StringNullableWithAggregatesFilter<"Transaction"> | string | null
    created_by?: StringWithAggregatesFilter<"Transaction"> | string
    created_at?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Transaction"> | Date | string
  }

  export type InventoryItemWhereInput = {
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    id?: StringFilter<"InventoryItem"> | string
    code?: StringFilter<"InventoryItem"> | string
    name?: StringFilter<"InventoryItem"> | string
    category?: StringFilter<"InventoryItem"> | string
    unit?: StringFilter<"InventoryItem"> | string
    current_stock?: FloatFilter<"InventoryItem"> | number
    min_stock?: FloatNullableFilter<"InventoryItem"> | number | null
    cost_price?: DecimalNullableFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFilter<"InventoryItem"> | Date | string
    updated_at?: DateTimeFilter<"InventoryItem"> | Date | string
    transactions?: InventoryTransactionListRelationFilter
  }

  export type InventoryItemOrderByWithRelationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unit?: SortOrder
    current_stock?: SortOrder
    min_stock?: SortOrderInput | SortOrder
    cost_price?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    transactions?: InventoryTransactionOrderByRelationAggregateInput
  }

  export type InventoryItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    code?: string
    AND?: InventoryItemWhereInput | InventoryItemWhereInput[]
    OR?: InventoryItemWhereInput[]
    NOT?: InventoryItemWhereInput | InventoryItemWhereInput[]
    name?: StringFilter<"InventoryItem"> | string
    category?: StringFilter<"InventoryItem"> | string
    unit?: StringFilter<"InventoryItem"> | string
    current_stock?: FloatFilter<"InventoryItem"> | number
    min_stock?: FloatNullableFilter<"InventoryItem"> | number | null
    cost_price?: DecimalNullableFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFilter<"InventoryItem"> | Date | string
    updated_at?: DateTimeFilter<"InventoryItem"> | Date | string
    transactions?: InventoryTransactionListRelationFilter
  }, "id" | "code">

  export type InventoryItemOrderByWithAggregationInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unit?: SortOrder
    current_stock?: SortOrder
    min_stock?: SortOrderInput | SortOrder
    cost_price?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: InventoryItemCountOrderByAggregateInput
    _avg?: InventoryItemAvgOrderByAggregateInput
    _max?: InventoryItemMaxOrderByAggregateInput
    _min?: InventoryItemMinOrderByAggregateInput
    _sum?: InventoryItemSumOrderByAggregateInput
  }

  export type InventoryItemScalarWhereWithAggregatesInput = {
    AND?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    OR?: InventoryItemScalarWhereWithAggregatesInput[]
    NOT?: InventoryItemScalarWhereWithAggregatesInput | InventoryItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryItem"> | string
    code?: StringWithAggregatesFilter<"InventoryItem"> | string
    name?: StringWithAggregatesFilter<"InventoryItem"> | string
    category?: StringWithAggregatesFilter<"InventoryItem"> | string
    unit?: StringWithAggregatesFilter<"InventoryItem"> | string
    current_stock?: FloatWithAggregatesFilter<"InventoryItem"> | number
    min_stock?: FloatNullableWithAggregatesFilter<"InventoryItem"> | number | null
    cost_price?: DecimalNullableWithAggregatesFilter<"InventoryItem"> | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeWithAggregatesFilter<"InventoryItem"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"InventoryItem"> | Date | string
  }

  export type InventoryTransactionWhereInput = {
    AND?: InventoryTransactionWhereInput | InventoryTransactionWhereInput[]
    OR?: InventoryTransactionWhereInput[]
    NOT?: InventoryTransactionWhereInput | InventoryTransactionWhereInput[]
    id?: StringFilter<"InventoryTransaction"> | string
    item_id?: StringFilter<"InventoryTransaction"> | string
    project_id?: StringNullableFilter<"InventoryTransaction"> | string | null
    type?: EnumInventoryTransactionTypeFilter<"InventoryTransaction"> | $Enums.InventoryTransactionType
    quantity?: FloatFilter<"InventoryTransaction"> | number
    date?: DateTimeFilter<"InventoryTransaction"> | Date | string
    reference_no?: StringNullableFilter<"InventoryTransaction"> | string | null
    notes?: StringNullableFilter<"InventoryTransaction"> | string | null
    created_by?: StringFilter<"InventoryTransaction"> | string
    created_at?: DateTimeFilter<"InventoryTransaction"> | Date | string
    item?: XOR<InventoryItemScalarRelationFilter, InventoryItemWhereInput>
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type InventoryTransactionOrderByWithRelationInput = {
    id?: SortOrder
    item_id?: SortOrder
    project_id?: SortOrderInput | SortOrder
    type?: SortOrder
    quantity?: SortOrder
    date?: SortOrder
    reference_no?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    item?: InventoryItemOrderByWithRelationInput
    project?: ProjectOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type InventoryTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InventoryTransactionWhereInput | InventoryTransactionWhereInput[]
    OR?: InventoryTransactionWhereInput[]
    NOT?: InventoryTransactionWhereInput | InventoryTransactionWhereInput[]
    item_id?: StringFilter<"InventoryTransaction"> | string
    project_id?: StringNullableFilter<"InventoryTransaction"> | string | null
    type?: EnumInventoryTransactionTypeFilter<"InventoryTransaction"> | $Enums.InventoryTransactionType
    quantity?: FloatFilter<"InventoryTransaction"> | number
    date?: DateTimeFilter<"InventoryTransaction"> | Date | string
    reference_no?: StringNullableFilter<"InventoryTransaction"> | string | null
    notes?: StringNullableFilter<"InventoryTransaction"> | string | null
    created_by?: StringFilter<"InventoryTransaction"> | string
    created_at?: DateTimeFilter<"InventoryTransaction"> | Date | string
    item?: XOR<InventoryItemScalarRelationFilter, InventoryItemWhereInput>
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type InventoryTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    item_id?: SortOrder
    project_id?: SortOrderInput | SortOrder
    type?: SortOrder
    quantity?: SortOrder
    date?: SortOrder
    reference_no?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    _count?: InventoryTransactionCountOrderByAggregateInput
    _avg?: InventoryTransactionAvgOrderByAggregateInput
    _max?: InventoryTransactionMaxOrderByAggregateInput
    _min?: InventoryTransactionMinOrderByAggregateInput
    _sum?: InventoryTransactionSumOrderByAggregateInput
  }

  export type InventoryTransactionScalarWhereWithAggregatesInput = {
    AND?: InventoryTransactionScalarWhereWithAggregatesInput | InventoryTransactionScalarWhereWithAggregatesInput[]
    OR?: InventoryTransactionScalarWhereWithAggregatesInput[]
    NOT?: InventoryTransactionScalarWhereWithAggregatesInput | InventoryTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InventoryTransaction"> | string
    item_id?: StringWithAggregatesFilter<"InventoryTransaction"> | string
    project_id?: StringNullableWithAggregatesFilter<"InventoryTransaction"> | string | null
    type?: EnumInventoryTransactionTypeWithAggregatesFilter<"InventoryTransaction"> | $Enums.InventoryTransactionType
    quantity?: FloatWithAggregatesFilter<"InventoryTransaction"> | number
    date?: DateTimeWithAggregatesFilter<"InventoryTransaction"> | Date | string
    reference_no?: StringNullableWithAggregatesFilter<"InventoryTransaction"> | string | null
    notes?: StringNullableWithAggregatesFilter<"InventoryTransaction"> | string | null
    created_by?: StringWithAggregatesFilter<"InventoryTransaction"> | string
    created_at?: DateTimeWithAggregatesFilter<"InventoryTransaction"> | Date | string
  }

  export type PurchaseRequestWhereInput = {
    AND?: PurchaseRequestWhereInput | PurchaseRequestWhereInput[]
    OR?: PurchaseRequestWhereInput[]
    NOT?: PurchaseRequestWhereInput | PurchaseRequestWhereInput[]
    id?: StringFilter<"PurchaseRequest"> | string
    project_id?: StringNullableFilter<"PurchaseRequest"> | string | null
    item_name?: StringFilter<"PurchaseRequest"> | string
    quantity?: FloatFilter<"PurchaseRequest"> | number
    unit?: StringFilter<"PurchaseRequest"> | string
    estimated_cost?: DecimalNullableFilter<"PurchaseRequest"> | Decimal | DecimalJsLike | number | string | null
    priority?: EnumPriorityLevelFilter<"PurchaseRequest"> | $Enums.PriorityLevel
    status?: EnumPurchaseStatusFilter<"PurchaseRequest"> | $Enums.PurchaseStatus
    requested_by?: StringFilter<"PurchaseRequest"> | string
    needed_by?: DateTimeNullableFilter<"PurchaseRequest"> | Date | string | null
    notes?: StringNullableFilter<"PurchaseRequest"> | string | null
    created_at?: DateTimeFilter<"PurchaseRequest"> | Date | string
    updated_at?: DateTimeFilter<"PurchaseRequest"> | Date | string
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    requester?: XOR<UserScalarRelationFilter, UserWhereInput>
    purchase_orders?: PurchaseOrderListRelationFilter
  }

  export type PurchaseRequestOrderByWithRelationInput = {
    id?: SortOrder
    project_id?: SortOrderInput | SortOrder
    item_name?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    estimated_cost?: SortOrderInput | SortOrder
    priority?: SortOrder
    status?: SortOrder
    requested_by?: SortOrder
    needed_by?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    project?: ProjectOrderByWithRelationInput
    requester?: UserOrderByWithRelationInput
    purchase_orders?: PurchaseOrderOrderByRelationAggregateInput
  }

  export type PurchaseRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PurchaseRequestWhereInput | PurchaseRequestWhereInput[]
    OR?: PurchaseRequestWhereInput[]
    NOT?: PurchaseRequestWhereInput | PurchaseRequestWhereInput[]
    project_id?: StringNullableFilter<"PurchaseRequest"> | string | null
    item_name?: StringFilter<"PurchaseRequest"> | string
    quantity?: FloatFilter<"PurchaseRequest"> | number
    unit?: StringFilter<"PurchaseRequest"> | string
    estimated_cost?: DecimalNullableFilter<"PurchaseRequest"> | Decimal | DecimalJsLike | number | string | null
    priority?: EnumPriorityLevelFilter<"PurchaseRequest"> | $Enums.PriorityLevel
    status?: EnumPurchaseStatusFilter<"PurchaseRequest"> | $Enums.PurchaseStatus
    requested_by?: StringFilter<"PurchaseRequest"> | string
    needed_by?: DateTimeNullableFilter<"PurchaseRequest"> | Date | string | null
    notes?: StringNullableFilter<"PurchaseRequest"> | string | null
    created_at?: DateTimeFilter<"PurchaseRequest"> | Date | string
    updated_at?: DateTimeFilter<"PurchaseRequest"> | Date | string
    project?: XOR<ProjectNullableScalarRelationFilter, ProjectWhereInput> | null
    requester?: XOR<UserScalarRelationFilter, UserWhereInput>
    purchase_orders?: PurchaseOrderListRelationFilter
  }, "id">

  export type PurchaseRequestOrderByWithAggregationInput = {
    id?: SortOrder
    project_id?: SortOrderInput | SortOrder
    item_name?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    estimated_cost?: SortOrderInput | SortOrder
    priority?: SortOrder
    status?: SortOrder
    requested_by?: SortOrder
    needed_by?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: PurchaseRequestCountOrderByAggregateInput
    _avg?: PurchaseRequestAvgOrderByAggregateInput
    _max?: PurchaseRequestMaxOrderByAggregateInput
    _min?: PurchaseRequestMinOrderByAggregateInput
    _sum?: PurchaseRequestSumOrderByAggregateInput
  }

  export type PurchaseRequestScalarWhereWithAggregatesInput = {
    AND?: PurchaseRequestScalarWhereWithAggregatesInput | PurchaseRequestScalarWhereWithAggregatesInput[]
    OR?: PurchaseRequestScalarWhereWithAggregatesInput[]
    NOT?: PurchaseRequestScalarWhereWithAggregatesInput | PurchaseRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseRequest"> | string
    project_id?: StringNullableWithAggregatesFilter<"PurchaseRequest"> | string | null
    item_name?: StringWithAggregatesFilter<"PurchaseRequest"> | string
    quantity?: FloatWithAggregatesFilter<"PurchaseRequest"> | number
    unit?: StringWithAggregatesFilter<"PurchaseRequest"> | string
    estimated_cost?: DecimalNullableWithAggregatesFilter<"PurchaseRequest"> | Decimal | DecimalJsLike | number | string | null
    priority?: EnumPriorityLevelWithAggregatesFilter<"PurchaseRequest"> | $Enums.PriorityLevel
    status?: EnumPurchaseStatusWithAggregatesFilter<"PurchaseRequest"> | $Enums.PurchaseStatus
    requested_by?: StringWithAggregatesFilter<"PurchaseRequest"> | string
    needed_by?: DateTimeNullableWithAggregatesFilter<"PurchaseRequest"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"PurchaseRequest"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"PurchaseRequest"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"PurchaseRequest"> | Date | string
  }

  export type VendorWhereInput = {
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    id?: StringFilter<"Vendor"> | string
    name?: StringFilter<"Vendor"> | string
    contact_person?: StringNullableFilter<"Vendor"> | string | null
    email?: StringNullableFilter<"Vendor"> | string | null
    phone?: StringNullableFilter<"Vendor"> | string | null
    address?: StringNullableFilter<"Vendor"> | string | null
    vat_no?: StringNullableFilter<"Vendor"> | string | null
    created_at?: DateTimeFilter<"Vendor"> | Date | string
    updated_at?: DateTimeFilter<"Vendor"> | Date | string
    purchase_orders?: PurchaseOrderListRelationFilter
    vendor_bills?: VendorBillListRelationFilter
  }

  export type VendorOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    contact_person?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    vat_no?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    purchase_orders?: PurchaseOrderOrderByRelationAggregateInput
    vendor_bills?: VendorBillOrderByRelationAggregateInput
  }

  export type VendorWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VendorWhereInput | VendorWhereInput[]
    OR?: VendorWhereInput[]
    NOT?: VendorWhereInput | VendorWhereInput[]
    name?: StringFilter<"Vendor"> | string
    contact_person?: StringNullableFilter<"Vendor"> | string | null
    email?: StringNullableFilter<"Vendor"> | string | null
    phone?: StringNullableFilter<"Vendor"> | string | null
    address?: StringNullableFilter<"Vendor"> | string | null
    vat_no?: StringNullableFilter<"Vendor"> | string | null
    created_at?: DateTimeFilter<"Vendor"> | Date | string
    updated_at?: DateTimeFilter<"Vendor"> | Date | string
    purchase_orders?: PurchaseOrderListRelationFilter
    vendor_bills?: VendorBillListRelationFilter
  }, "id">

  export type VendorOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    contact_person?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    vat_no?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: VendorCountOrderByAggregateInput
    _max?: VendorMaxOrderByAggregateInput
    _min?: VendorMinOrderByAggregateInput
  }

  export type VendorScalarWhereWithAggregatesInput = {
    AND?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    OR?: VendorScalarWhereWithAggregatesInput[]
    NOT?: VendorScalarWhereWithAggregatesInput | VendorScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Vendor"> | string
    name?: StringWithAggregatesFilter<"Vendor"> | string
    contact_person?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    email?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    address?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    vat_no?: StringNullableWithAggregatesFilter<"Vendor"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"Vendor"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"Vendor"> | Date | string
  }

  export type PurchaseOrderWhereInput = {
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    id?: StringFilter<"PurchaseOrder"> | string
    po_number?: StringFilter<"PurchaseOrder"> | string
    purchase_request_id?: StringNullableFilter<"PurchaseOrder"> | string | null
    vendor_id?: StringFilter<"PurchaseOrder"> | string
    total_amount?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFilter<"PurchaseOrder"> | $Enums.PurchaseStatus
    created_by?: StringFilter<"PurchaseOrder"> | string
    created_at?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updated_at?: DateTimeFilter<"PurchaseOrder"> | Date | string
    purchase_request?: XOR<PurchaseRequestNullableScalarRelationFilter, PurchaseRequestWhereInput> | null
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    grns?: GRNListRelationFilter
    vendor_bills?: VendorBillListRelationFilter
  }

  export type PurchaseOrderOrderByWithRelationInput = {
    id?: SortOrder
    po_number?: SortOrder
    purchase_request_id?: SortOrderInput | SortOrder
    vendor_id?: SortOrder
    total_amount?: SortOrder
    status?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    purchase_request?: PurchaseRequestOrderByWithRelationInput
    vendor?: VendorOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    grns?: GRNOrderByRelationAggregateInput
    vendor_bills?: VendorBillOrderByRelationAggregateInput
  }

  export type PurchaseOrderWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    po_number?: string
    AND?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    OR?: PurchaseOrderWhereInput[]
    NOT?: PurchaseOrderWhereInput | PurchaseOrderWhereInput[]
    purchase_request_id?: StringNullableFilter<"PurchaseOrder"> | string | null
    vendor_id?: StringFilter<"PurchaseOrder"> | string
    total_amount?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFilter<"PurchaseOrder"> | $Enums.PurchaseStatus
    created_by?: StringFilter<"PurchaseOrder"> | string
    created_at?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updated_at?: DateTimeFilter<"PurchaseOrder"> | Date | string
    purchase_request?: XOR<PurchaseRequestNullableScalarRelationFilter, PurchaseRequestWhereInput> | null
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
    creator?: XOR<UserScalarRelationFilter, UserWhereInput>
    grns?: GRNListRelationFilter
    vendor_bills?: VendorBillListRelationFilter
  }, "id" | "po_number">

  export type PurchaseOrderOrderByWithAggregationInput = {
    id?: SortOrder
    po_number?: SortOrder
    purchase_request_id?: SortOrderInput | SortOrder
    vendor_id?: SortOrder
    total_amount?: SortOrder
    status?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: PurchaseOrderCountOrderByAggregateInput
    _avg?: PurchaseOrderAvgOrderByAggregateInput
    _max?: PurchaseOrderMaxOrderByAggregateInput
    _min?: PurchaseOrderMinOrderByAggregateInput
    _sum?: PurchaseOrderSumOrderByAggregateInput
  }

  export type PurchaseOrderScalarWhereWithAggregatesInput = {
    AND?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    OR?: PurchaseOrderScalarWhereWithAggregatesInput[]
    NOT?: PurchaseOrderScalarWhereWithAggregatesInput | PurchaseOrderScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    po_number?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    purchase_request_id?: StringNullableWithAggregatesFilter<"PurchaseOrder"> | string | null
    vendor_id?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    total_amount?: DecimalWithAggregatesFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusWithAggregatesFilter<"PurchaseOrder"> | $Enums.PurchaseStatus
    created_by?: StringWithAggregatesFilter<"PurchaseOrder"> | string
    created_at?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"PurchaseOrder"> | Date | string
  }

  export type GRNWhereInput = {
    AND?: GRNWhereInput | GRNWhereInput[]
    OR?: GRNWhereInput[]
    NOT?: GRNWhereInput | GRNWhereInput[]
    id?: StringFilter<"GRN"> | string
    grn_number?: StringFilter<"GRN"> | string
    purchase_order_id?: StringFilter<"GRN"> | string
    received_date?: DateTimeFilter<"GRN"> | Date | string
    received_by?: StringFilter<"GRN"> | string
    notes?: StringNullableFilter<"GRN"> | string | null
    created_at?: DateTimeFilter<"GRN"> | Date | string
    purchase_order?: XOR<PurchaseOrderScalarRelationFilter, PurchaseOrderWhereInput>
    receiver?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type GRNOrderByWithRelationInput = {
    id?: SortOrder
    grn_number?: SortOrder
    purchase_order_id?: SortOrder
    received_date?: SortOrder
    received_by?: SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    purchase_order?: PurchaseOrderOrderByWithRelationInput
    receiver?: UserOrderByWithRelationInput
  }

  export type GRNWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    grn_number?: string
    AND?: GRNWhereInput | GRNWhereInput[]
    OR?: GRNWhereInput[]
    NOT?: GRNWhereInput | GRNWhereInput[]
    purchase_order_id?: StringFilter<"GRN"> | string
    received_date?: DateTimeFilter<"GRN"> | Date | string
    received_by?: StringFilter<"GRN"> | string
    notes?: StringNullableFilter<"GRN"> | string | null
    created_at?: DateTimeFilter<"GRN"> | Date | string
    purchase_order?: XOR<PurchaseOrderScalarRelationFilter, PurchaseOrderWhereInput>
    receiver?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "grn_number">

  export type GRNOrderByWithAggregationInput = {
    id?: SortOrder
    grn_number?: SortOrder
    purchase_order_id?: SortOrder
    received_date?: SortOrder
    received_by?: SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: GRNCountOrderByAggregateInput
    _max?: GRNMaxOrderByAggregateInput
    _min?: GRNMinOrderByAggregateInput
  }

  export type GRNScalarWhereWithAggregatesInput = {
    AND?: GRNScalarWhereWithAggregatesInput | GRNScalarWhereWithAggregatesInput[]
    OR?: GRNScalarWhereWithAggregatesInput[]
    NOT?: GRNScalarWhereWithAggregatesInput | GRNScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"GRN"> | string
    grn_number?: StringWithAggregatesFilter<"GRN"> | string
    purchase_order_id?: StringWithAggregatesFilter<"GRN"> | string
    received_date?: DateTimeWithAggregatesFilter<"GRN"> | Date | string
    received_by?: StringWithAggregatesFilter<"GRN"> | string
    notes?: StringNullableWithAggregatesFilter<"GRN"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"GRN"> | Date | string
  }

  export type VendorBillWhereInput = {
    AND?: VendorBillWhereInput | VendorBillWhereInput[]
    OR?: VendorBillWhereInput[]
    NOT?: VendorBillWhereInput | VendorBillWhereInput[]
    id?: StringFilter<"VendorBill"> | string
    bill_number?: StringFilter<"VendorBill"> | string
    purchase_order_id?: StringFilter<"VendorBill"> | string
    vendor_id?: StringFilter<"VendorBill"> | string
    amount?: DecimalFilter<"VendorBill"> | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalNullableFilter<"VendorBill"> | Decimal | DecimalJsLike | number | string | null
    due_date?: DateTimeFilter<"VendorBill"> | Date | string
    status?: EnumInvoiceStatusFilter<"VendorBill"> | $Enums.InvoiceStatus
    created_at?: DateTimeFilter<"VendorBill"> | Date | string
    updated_at?: DateTimeFilter<"VendorBill"> | Date | string
    purchase_order?: XOR<PurchaseOrderScalarRelationFilter, PurchaseOrderWhereInput>
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
    vendor_payments?: VendorPaymentListRelationFilter
  }

  export type VendorBillOrderByWithRelationInput = {
    id?: SortOrder
    bill_number?: SortOrder
    purchase_order_id?: SortOrder
    vendor_id?: SortOrder
    amount?: SortOrder
    tax_amount?: SortOrderInput | SortOrder
    due_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    purchase_order?: PurchaseOrderOrderByWithRelationInput
    vendor?: VendorOrderByWithRelationInput
    vendor_payments?: VendorPaymentOrderByRelationAggregateInput
  }

  export type VendorBillWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    bill_number?: string
    AND?: VendorBillWhereInput | VendorBillWhereInput[]
    OR?: VendorBillWhereInput[]
    NOT?: VendorBillWhereInput | VendorBillWhereInput[]
    purchase_order_id?: StringFilter<"VendorBill"> | string
    vendor_id?: StringFilter<"VendorBill"> | string
    amount?: DecimalFilter<"VendorBill"> | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalNullableFilter<"VendorBill"> | Decimal | DecimalJsLike | number | string | null
    due_date?: DateTimeFilter<"VendorBill"> | Date | string
    status?: EnumInvoiceStatusFilter<"VendorBill"> | $Enums.InvoiceStatus
    created_at?: DateTimeFilter<"VendorBill"> | Date | string
    updated_at?: DateTimeFilter<"VendorBill"> | Date | string
    purchase_order?: XOR<PurchaseOrderScalarRelationFilter, PurchaseOrderWhereInput>
    vendor?: XOR<VendorScalarRelationFilter, VendorWhereInput>
    vendor_payments?: VendorPaymentListRelationFilter
  }, "id" | "bill_number">

  export type VendorBillOrderByWithAggregationInput = {
    id?: SortOrder
    bill_number?: SortOrder
    purchase_order_id?: SortOrder
    vendor_id?: SortOrder
    amount?: SortOrder
    tax_amount?: SortOrderInput | SortOrder
    due_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: VendorBillCountOrderByAggregateInput
    _avg?: VendorBillAvgOrderByAggregateInput
    _max?: VendorBillMaxOrderByAggregateInput
    _min?: VendorBillMinOrderByAggregateInput
    _sum?: VendorBillSumOrderByAggregateInput
  }

  export type VendorBillScalarWhereWithAggregatesInput = {
    AND?: VendorBillScalarWhereWithAggregatesInput | VendorBillScalarWhereWithAggregatesInput[]
    OR?: VendorBillScalarWhereWithAggregatesInput[]
    NOT?: VendorBillScalarWhereWithAggregatesInput | VendorBillScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VendorBill"> | string
    bill_number?: StringWithAggregatesFilter<"VendorBill"> | string
    purchase_order_id?: StringWithAggregatesFilter<"VendorBill"> | string
    vendor_id?: StringWithAggregatesFilter<"VendorBill"> | string
    amount?: DecimalWithAggregatesFilter<"VendorBill"> | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalNullableWithAggregatesFilter<"VendorBill"> | Decimal | DecimalJsLike | number | string | null
    due_date?: DateTimeWithAggregatesFilter<"VendorBill"> | Date | string
    status?: EnumInvoiceStatusWithAggregatesFilter<"VendorBill"> | $Enums.InvoiceStatus
    created_at?: DateTimeWithAggregatesFilter<"VendorBill"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"VendorBill"> | Date | string
  }

  export type VendorPaymentWhereInput = {
    AND?: VendorPaymentWhereInput | VendorPaymentWhereInput[]
    OR?: VendorPaymentWhereInput[]
    NOT?: VendorPaymentWhereInput | VendorPaymentWhereInput[]
    id?: StringFilter<"VendorPayment"> | string
    vendor_bill_id?: StringFilter<"VendorPayment"> | string
    amount?: DecimalFilter<"VendorPayment"> | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFilter<"VendorPayment"> | Date | string
    payment_method?: StringFilter<"VendorPayment"> | string
    reference_no?: StringNullableFilter<"VendorPayment"> | string | null
    notes?: StringNullableFilter<"VendorPayment"> | string | null
    created_at?: DateTimeFilter<"VendorPayment"> | Date | string
    vendor_bill?: XOR<VendorBillScalarRelationFilter, VendorBillWhereInput>
  }

  export type VendorPaymentOrderByWithRelationInput = {
    id?: SortOrder
    vendor_bill_id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_method?: SortOrder
    reference_no?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    vendor_bill?: VendorBillOrderByWithRelationInput
  }

  export type VendorPaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: VendorPaymentWhereInput | VendorPaymentWhereInput[]
    OR?: VendorPaymentWhereInput[]
    NOT?: VendorPaymentWhereInput | VendorPaymentWhereInput[]
    vendor_bill_id?: StringFilter<"VendorPayment"> | string
    amount?: DecimalFilter<"VendorPayment"> | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFilter<"VendorPayment"> | Date | string
    payment_method?: StringFilter<"VendorPayment"> | string
    reference_no?: StringNullableFilter<"VendorPayment"> | string | null
    notes?: StringNullableFilter<"VendorPayment"> | string | null
    created_at?: DateTimeFilter<"VendorPayment"> | Date | string
    vendor_bill?: XOR<VendorBillScalarRelationFilter, VendorBillWhereInput>
  }, "id">

  export type VendorPaymentOrderByWithAggregationInput = {
    id?: SortOrder
    vendor_bill_id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_method?: SortOrder
    reference_no?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    created_at?: SortOrder
    _count?: VendorPaymentCountOrderByAggregateInput
    _avg?: VendorPaymentAvgOrderByAggregateInput
    _max?: VendorPaymentMaxOrderByAggregateInput
    _min?: VendorPaymentMinOrderByAggregateInput
    _sum?: VendorPaymentSumOrderByAggregateInput
  }

  export type VendorPaymentScalarWhereWithAggregatesInput = {
    AND?: VendorPaymentScalarWhereWithAggregatesInput | VendorPaymentScalarWhereWithAggregatesInput[]
    OR?: VendorPaymentScalarWhereWithAggregatesInput[]
    NOT?: VendorPaymentScalarWhereWithAggregatesInput | VendorPaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"VendorPayment"> | string
    vendor_bill_id?: StringWithAggregatesFilter<"VendorPayment"> | string
    amount?: DecimalWithAggregatesFilter<"VendorPayment"> | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeWithAggregatesFilter<"VendorPayment"> | Date | string
    payment_method?: StringWithAggregatesFilter<"VendorPayment"> | string
    reference_no?: StringNullableWithAggregatesFilter<"VendorPayment"> | string | null
    notes?: StringNullableWithAggregatesFilter<"VendorPayment"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"VendorPayment"> | Date | string
  }

  export type BankAccountWhereInput = {
    AND?: BankAccountWhereInput | BankAccountWhereInput[]
    OR?: BankAccountWhereInput[]
    NOT?: BankAccountWhereInput | BankAccountWhereInput[]
    id?: StringFilter<"BankAccount"> | string
    name?: StringFilter<"BankAccount"> | string
    account_number?: StringNullableFilter<"BankAccount"> | string | null
    bank_name?: StringNullableFilter<"BankAccount"> | string | null
    currency?: StringFilter<"BankAccount"> | string
    current_balance?: DecimalFilter<"BankAccount"> | Decimal | DecimalJsLike | number | string
    type?: StringFilter<"BankAccount"> | string
    created_at?: DateTimeFilter<"BankAccount"> | Date | string
    updated_at?: DateTimeFilter<"BankAccount"> | Date | string
    transactions?: BankTransactionListRelationFilter
  }

  export type BankAccountOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    account_number?: SortOrderInput | SortOrder
    bank_name?: SortOrderInput | SortOrder
    currency?: SortOrder
    current_balance?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    transactions?: BankTransactionOrderByRelationAggregateInput
  }

  export type BankAccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BankAccountWhereInput | BankAccountWhereInput[]
    OR?: BankAccountWhereInput[]
    NOT?: BankAccountWhereInput | BankAccountWhereInput[]
    name?: StringFilter<"BankAccount"> | string
    account_number?: StringNullableFilter<"BankAccount"> | string | null
    bank_name?: StringNullableFilter<"BankAccount"> | string | null
    currency?: StringFilter<"BankAccount"> | string
    current_balance?: DecimalFilter<"BankAccount"> | Decimal | DecimalJsLike | number | string
    type?: StringFilter<"BankAccount"> | string
    created_at?: DateTimeFilter<"BankAccount"> | Date | string
    updated_at?: DateTimeFilter<"BankAccount"> | Date | string
    transactions?: BankTransactionListRelationFilter
  }, "id">

  export type BankAccountOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    account_number?: SortOrderInput | SortOrder
    bank_name?: SortOrderInput | SortOrder
    currency?: SortOrder
    current_balance?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: BankAccountCountOrderByAggregateInput
    _avg?: BankAccountAvgOrderByAggregateInput
    _max?: BankAccountMaxOrderByAggregateInput
    _min?: BankAccountMinOrderByAggregateInput
    _sum?: BankAccountSumOrderByAggregateInput
  }

  export type BankAccountScalarWhereWithAggregatesInput = {
    AND?: BankAccountScalarWhereWithAggregatesInput | BankAccountScalarWhereWithAggregatesInput[]
    OR?: BankAccountScalarWhereWithAggregatesInput[]
    NOT?: BankAccountScalarWhereWithAggregatesInput | BankAccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BankAccount"> | string
    name?: StringWithAggregatesFilter<"BankAccount"> | string
    account_number?: StringNullableWithAggregatesFilter<"BankAccount"> | string | null
    bank_name?: StringNullableWithAggregatesFilter<"BankAccount"> | string | null
    currency?: StringWithAggregatesFilter<"BankAccount"> | string
    current_balance?: DecimalWithAggregatesFilter<"BankAccount"> | Decimal | DecimalJsLike | number | string
    type?: StringWithAggregatesFilter<"BankAccount"> | string
    created_at?: DateTimeWithAggregatesFilter<"BankAccount"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"BankAccount"> | Date | string
  }

  export type BankTransactionWhereInput = {
    AND?: BankTransactionWhereInput | BankTransactionWhereInput[]
    OR?: BankTransactionWhereInput[]
    NOT?: BankTransactionWhereInput | BankTransactionWhereInput[]
    id?: StringFilter<"BankTransaction"> | string
    bank_account_id?: StringFilter<"BankTransaction"> | string
    date?: DateTimeFilter<"BankTransaction"> | Date | string
    description?: StringFilter<"BankTransaction"> | string
    amount?: DecimalFilter<"BankTransaction"> | Decimal | DecimalJsLike | number | string
    reference?: StringNullableFilter<"BankTransaction"> | string | null
    status?: StringFilter<"BankTransaction"> | string
    type?: StringFilter<"BankTransaction"> | string
    system_transaction_id?: StringNullableFilter<"BankTransaction"> | string | null
    created_at?: DateTimeFilter<"BankTransaction"> | Date | string
    updated_at?: DateTimeFilter<"BankTransaction"> | Date | string
    bank_account?: XOR<BankAccountScalarRelationFilter, BankAccountWhereInput>
  }

  export type BankTransactionOrderByWithRelationInput = {
    id?: SortOrder
    bank_account_id?: SortOrder
    date?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    reference?: SortOrderInput | SortOrder
    status?: SortOrder
    type?: SortOrder
    system_transaction_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    bank_account?: BankAccountOrderByWithRelationInput
  }

  export type BankTransactionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BankTransactionWhereInput | BankTransactionWhereInput[]
    OR?: BankTransactionWhereInput[]
    NOT?: BankTransactionWhereInput | BankTransactionWhereInput[]
    bank_account_id?: StringFilter<"BankTransaction"> | string
    date?: DateTimeFilter<"BankTransaction"> | Date | string
    description?: StringFilter<"BankTransaction"> | string
    amount?: DecimalFilter<"BankTransaction"> | Decimal | DecimalJsLike | number | string
    reference?: StringNullableFilter<"BankTransaction"> | string | null
    status?: StringFilter<"BankTransaction"> | string
    type?: StringFilter<"BankTransaction"> | string
    system_transaction_id?: StringNullableFilter<"BankTransaction"> | string | null
    created_at?: DateTimeFilter<"BankTransaction"> | Date | string
    updated_at?: DateTimeFilter<"BankTransaction"> | Date | string
    bank_account?: XOR<BankAccountScalarRelationFilter, BankAccountWhereInput>
  }, "id">

  export type BankTransactionOrderByWithAggregationInput = {
    id?: SortOrder
    bank_account_id?: SortOrder
    date?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    reference?: SortOrderInput | SortOrder
    status?: SortOrder
    type?: SortOrder
    system_transaction_id?: SortOrderInput | SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
    _count?: BankTransactionCountOrderByAggregateInput
    _avg?: BankTransactionAvgOrderByAggregateInput
    _max?: BankTransactionMaxOrderByAggregateInput
    _min?: BankTransactionMinOrderByAggregateInput
    _sum?: BankTransactionSumOrderByAggregateInput
  }

  export type BankTransactionScalarWhereWithAggregatesInput = {
    AND?: BankTransactionScalarWhereWithAggregatesInput | BankTransactionScalarWhereWithAggregatesInput[]
    OR?: BankTransactionScalarWhereWithAggregatesInput[]
    NOT?: BankTransactionScalarWhereWithAggregatesInput | BankTransactionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BankTransaction"> | string
    bank_account_id?: StringWithAggregatesFilter<"BankTransaction"> | string
    date?: DateTimeWithAggregatesFilter<"BankTransaction"> | Date | string
    description?: StringWithAggregatesFilter<"BankTransaction"> | string
    amount?: DecimalWithAggregatesFilter<"BankTransaction"> | Decimal | DecimalJsLike | number | string
    reference?: StringNullableWithAggregatesFilter<"BankTransaction"> | string | null
    status?: StringWithAggregatesFilter<"BankTransaction"> | string
    type?: StringWithAggregatesFilter<"BankTransaction"> | string
    system_transaction_id?: StringNullableWithAggregatesFilter<"BankTransaction"> | string | null
    created_at?: DateTimeWithAggregatesFilter<"BankTransaction"> | Date | string
    updated_at?: DateTimeWithAggregatesFilter<"BankTransaction"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password?: string | null
    full_name: string
    role?: $Enums.UserRole
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    projects?: ProjectCreateNestedManyWithoutClientInput
    project_files?: ProjectFileCreateNestedManyWithoutUploaderInput
    project_updates?: ProjectUpdateCreateNestedManyWithoutAuthorInput
    support_requests?: SupportRequestCreateNestedManyWithoutClientInput
    support_messages?: SupportMessageCreateNestedManyWithoutSenderInput
    meeting_requests?: MeetingRequestCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    inventory_logs?: InventoryTransactionCreateNestedManyWithoutUserInput
    purchase_requests?: PurchaseRequestCreateNestedManyWithoutRequesterInput
    purchase_orders?: PurchaseOrderCreateNestedManyWithoutCreatorInput
    grns?: GRNCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password?: string | null
    full_name: string
    role?: $Enums.UserRole
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    project_files?: ProjectFileUncheckedCreateNestedManyWithoutUploaderInput
    project_updates?: ProjectUpdateUncheckedCreateNestedManyWithoutAuthorInput
    support_requests?: SupportRequestUncheckedCreateNestedManyWithoutClientInput
    support_messages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
    meeting_requests?: MeetingRequestUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    inventory_logs?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    purchase_requests?: PurchaseRequestUncheckedCreateNestedManyWithoutRequesterInput
    purchase_orders?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatorInput
    grns?: GRNUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutClientNestedInput
    project_files?: ProjectFileUpdateManyWithoutUploaderNestedInput
    project_updates?: ProjectUpdateUpdateManyWithoutAuthorNestedInput
    support_requests?: SupportRequestUpdateManyWithoutClientNestedInput
    support_messages?: SupportMessageUpdateManyWithoutSenderNestedInput
    meeting_requests?: MeetingRequestUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    inventory_logs?: InventoryTransactionUpdateManyWithoutUserNestedInput
    purchase_requests?: PurchaseRequestUpdateManyWithoutRequesterNestedInput
    purchase_orders?: PurchaseOrderUpdateManyWithoutCreatorNestedInput
    grns?: GRNUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    project_files?: ProjectFileUncheckedUpdateManyWithoutUploaderNestedInput
    project_updates?: ProjectUpdateUncheckedUpdateManyWithoutAuthorNestedInput
    support_requests?: SupportRequestUncheckedUpdateManyWithoutClientNestedInput
    support_messages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
    meeting_requests?: MeetingRequestUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    inventory_logs?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    purchase_requests?: PurchaseRequestUncheckedUpdateManyWithoutRequesterNestedInput
    purchase_orders?: PurchaseOrderUncheckedUpdateManyWithoutCreatorNestedInput
    grns?: GRNUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password?: string | null
    full_name: string
    role?: $Enums.UserRole
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.ProjectStatus
    github_link?: string | null
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    actual_cost?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    test_asset_url?: string | null
    deployment_url?: string | null
    live_preview_type?: string | null
    live_preview_url?: string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectCreatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    client: UserCreateNestedOneWithoutProjectsInput
    files?: ProjectFileCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateCreateNestedManyWithoutProjectInput
    support_requests?: SupportRequestCreateNestedManyWithoutProjectInput
    meeting_requests?: MeetingRequestCreateNestedManyWithoutProjectInput
    invoices?: InvoiceCreateNestedManyWithoutProjectInput
    inventory_logs?: InventoryTransactionCreateNestedManyWithoutProjectInput
    purchase_requests?: PurchaseRequestCreateNestedManyWithoutProjectInput
    attendance?: AttendanceCreateNestedManyWithoutProjectInput
    labour_allocations?: LabourAllocationCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateInput = {
    id?: string
    client_id: string
    title: string
    description: string
    status?: $Enums.ProjectStatus
    github_link?: string | null
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    actual_cost?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    test_asset_url?: string | null
    deployment_url?: string | null
    live_preview_type?: string | null
    live_preview_url?: string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectCreatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    files?: ProjectFileUncheckedCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput
    support_requests?: SupportRequestUncheckedCreateNestedManyWithoutProjectInput
    meeting_requests?: MeetingRequestUncheckedCreateNestedManyWithoutProjectInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutProjectInput
    inventory_logs?: InventoryTransactionUncheckedCreateNestedManyWithoutProjectInput
    purchase_requests?: PurchaseRequestUncheckedCreateNestedManyWithoutProjectInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutProjectInput
    labour_allocations?: LabourAllocationUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    github_link?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actual_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_asset_url?: NullableStringFieldUpdateOperationsInput | string | null
    deployment_url?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_type?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_url?: NullableStringFieldUpdateOperationsInput | string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectUpdatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: UserUpdateOneRequiredWithoutProjectsNestedInput
    files?: ProjectFileUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUpdateManyWithoutProjectNestedInput
    support_requests?: SupportRequestUpdateManyWithoutProjectNestedInput
    meeting_requests?: MeetingRequestUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUpdateManyWithoutProjectNestedInput
    inventory_logs?: InventoryTransactionUpdateManyWithoutProjectNestedInput
    purchase_requests?: PurchaseRequestUpdateManyWithoutProjectNestedInput
    attendance?: AttendanceUpdateManyWithoutProjectNestedInput
    labour_allocations?: LabourAllocationUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    github_link?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actual_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_asset_url?: NullableStringFieldUpdateOperationsInput | string | null
    deployment_url?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_type?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_url?: NullableStringFieldUpdateOperationsInput | string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectUpdatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: ProjectFileUncheckedUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput
    support_requests?: SupportRequestUncheckedUpdateManyWithoutProjectNestedInput
    meeting_requests?: MeetingRequestUncheckedUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutProjectNestedInput
    inventory_logs?: InventoryTransactionUncheckedUpdateManyWithoutProjectNestedInput
    purchase_requests?: PurchaseRequestUncheckedUpdateManyWithoutProjectNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutProjectNestedInput
    labour_allocations?: LabourAllocationUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectCreateManyInput = {
    id?: string
    client_id: string
    title: string
    description: string
    status?: $Enums.ProjectStatus
    github_link?: string | null
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    actual_cost?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    test_asset_url?: string | null
    deployment_url?: string | null
    live_preview_type?: string | null
    live_preview_url?: string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectCreatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    github_link?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actual_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_asset_url?: NullableStringFieldUpdateOperationsInput | string | null
    deployment_url?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_type?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_url?: NullableStringFieldUpdateOperationsInput | string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectUpdatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    github_link?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actual_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_asset_url?: NullableStringFieldUpdateOperationsInput | string | null
    deployment_url?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_type?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_url?: NullableStringFieldUpdateOperationsInput | string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectUpdatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectFileCreateInput = {
    id?: string
    file_name: string
    file_url: string
    file_type?: $Enums.FileType
    file_size: bigint | number
    created_at?: Date | string
    project: ProjectCreateNestedOneWithoutFilesInput
    uploader: UserCreateNestedOneWithoutProject_filesInput
  }

  export type ProjectFileUncheckedCreateInput = {
    id?: string
    project_id: string
    file_name: string
    file_url: string
    file_type?: $Enums.FileType
    file_size: bigint | number
    uploaded_by: string
    created_at?: Date | string
  }

  export type ProjectFileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    file_url?: StringFieldUpdateOperationsInput | string
    file_type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    file_size?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutFilesNestedInput
    uploader?: UserUpdateOneRequiredWithoutProject_filesNestedInput
  }

  export type ProjectFileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    file_url?: StringFieldUpdateOperationsInput | string
    file_type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    file_size?: BigIntFieldUpdateOperationsInput | bigint | number
    uploaded_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectFileCreateManyInput = {
    id?: string
    project_id: string
    file_name: string
    file_url: string
    file_type?: $Enums.FileType
    file_size: bigint | number
    uploaded_by: string
    created_at?: Date | string
  }

  export type ProjectFileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    file_url?: StringFieldUpdateOperationsInput | string
    file_type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    file_size?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectFileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    file_url?: StringFieldUpdateOperationsInput | string
    file_type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    file_size?: BigIntFieldUpdateOperationsInput | bigint | number
    uploaded_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateCreateInput = {
    id?: string
    update_text: string
    created_at?: Date | string
    project: ProjectCreateNestedOneWithoutUpdatesInput
    author: UserCreateNestedOneWithoutProject_updatesInput
  }

  export type ProjectUpdateUncheckedCreateInput = {
    id?: string
    project_id: string
    update_text: string
    created_by: string
    created_at?: Date | string
  }

  export type ProjectUpdateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    update_text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutUpdatesNestedInput
    author?: UserUpdateOneRequiredWithoutProject_updatesNestedInput
  }

  export type ProjectUpdateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    update_text?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateCreateManyInput = {
    id?: string
    project_id: string
    update_text: string
    created_by: string
    created_at?: Date | string
  }

  export type ProjectUpdateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    update_text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    update_text?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportRequestCreateInput = {
    id?: string
    subject: string
    description: string
    status?: $Enums.SupportStatus
    priority?: $Enums.PriorityLevel
    created_at?: Date | string
    updated_at?: Date | string
    project?: ProjectCreateNestedOneWithoutSupport_requestsInput
    client: UserCreateNestedOneWithoutSupport_requestsInput
    messages?: SupportMessageCreateNestedManyWithoutRequestInput
  }

  export type SupportRequestUncheckedCreateInput = {
    id?: string
    project_id?: string | null
    client_id: string
    subject: string
    description: string
    status?: $Enums.SupportStatus
    priority?: $Enums.PriorityLevel
    created_at?: Date | string
    updated_at?: Date | string
    messages?: SupportMessageUncheckedCreateNestedManyWithoutRequestInput
  }

  export type SupportRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSupportStatusFieldUpdateOperationsInput | $Enums.SupportStatus
    priority?: EnumPriorityLevelFieldUpdateOperationsInput | $Enums.PriorityLevel
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutSupport_requestsNestedInput
    client?: UserUpdateOneRequiredWithoutSupport_requestsNestedInput
    messages?: SupportMessageUpdateManyWithoutRequestNestedInput
  }

  export type SupportRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSupportStatusFieldUpdateOperationsInput | $Enums.SupportStatus
    priority?: EnumPriorityLevelFieldUpdateOperationsInput | $Enums.PriorityLevel
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: SupportMessageUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type SupportRequestCreateManyInput = {
    id?: string
    project_id?: string | null
    client_id: string
    subject: string
    description: string
    status?: $Enums.SupportStatus
    priority?: $Enums.PriorityLevel
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SupportRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSupportStatusFieldUpdateOperationsInput | $Enums.SupportStatus
    priority?: EnumPriorityLevelFieldUpdateOperationsInput | $Enums.PriorityLevel
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSupportStatusFieldUpdateOperationsInput | $Enums.SupportStatus
    priority?: EnumPriorityLevelFieldUpdateOperationsInput | $Enums.PriorityLevel
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportMessageCreateInput = {
    id?: string
    message: string
    created_at?: Date | string
    request: SupportRequestCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutSupport_messagesInput
  }

  export type SupportMessageUncheckedCreateInput = {
    id?: string
    support_request_id: string
    user_id: string
    message: string
    created_at?: Date | string
  }

  export type SupportMessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: SupportRequestUpdateOneRequiredWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutSupport_messagesNestedInput
  }

  export type SupportMessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    support_request_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportMessageCreateManyInput = {
    id?: string
    support_request_id: string
    user_id: string
    message: string
    created_at?: Date | string
  }

  export type SupportMessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportMessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    support_request_id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingRequestCreateInput = {
    id?: string
    requested_date: Date | string
    duration_minutes?: number
    purpose: string
    status?: $Enums.MeetingStatus
    meeting_link?: string | null
    admin_notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project?: ProjectCreateNestedOneWithoutMeeting_requestsInput
    client: UserCreateNestedOneWithoutMeeting_requestsInput
  }

  export type MeetingRequestUncheckedCreateInput = {
    id?: string
    project_id?: string | null
    client_id: string
    requested_date: Date | string
    duration_minutes?: number
    purpose: string
    status?: $Enums.MeetingStatus
    meeting_link?: string | null
    admin_notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MeetingRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requested_date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_minutes?: IntFieldUpdateOperationsInput | number
    purpose?: StringFieldUpdateOperationsInput | string
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus
    meeting_link?: NullableStringFieldUpdateOperationsInput | string | null
    admin_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutMeeting_requestsNestedInput
    client?: UserUpdateOneRequiredWithoutMeeting_requestsNestedInput
  }

  export type MeetingRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: StringFieldUpdateOperationsInput | string
    requested_date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_minutes?: IntFieldUpdateOperationsInput | number
    purpose?: StringFieldUpdateOperationsInput | string
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus
    meeting_link?: NullableStringFieldUpdateOperationsInput | string | null
    admin_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingRequestCreateManyInput = {
    id?: string
    project_id?: string | null
    client_id: string
    requested_date: Date | string
    duration_minutes?: number
    purpose: string
    status?: $Enums.MeetingStatus
    meeting_link?: string | null
    admin_notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MeetingRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    requested_date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_minutes?: IntFieldUpdateOperationsInput | number
    purpose?: StringFieldUpdateOperationsInput | string
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus
    meeting_link?: NullableStringFieldUpdateOperationsInput | string | null
    admin_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: StringFieldUpdateOperationsInput | string
    requested_date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_minutes?: IntFieldUpdateOperationsInput | number
    purpose?: StringFieldUpdateOperationsInput | string
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus
    meeting_link?: NullableStringFieldUpdateOperationsInput | string | null
    admin_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceCreateInput = {
    id?: string
    invoice_number: string
    amount: Decimal | DecimalJsLike | number | string
    due_date: Date | string
    status?: $Enums.InvoiceStatus
    payment_qr_url?: string | null
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    paid_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: ProjectCreateNestedOneWithoutInvoicesInput
    client: UserCreateNestedOneWithoutInvoicesInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateInput = {
    id?: string
    project_id: string
    client_id: string
    invoice_number: string
    amount: Decimal | DecimalJsLike | number | string
    due_date: Date | string
    status?: $Enums.InvoiceStatus
    payment_qr_url?: string | null
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    paid_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    payment_qr_url?: NullableStringFieldUpdateOperationsInput | string | null
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutInvoicesNestedInput
    client?: UserUpdateOneRequiredWithoutInvoicesNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    payment_qr_url?: NullableStringFieldUpdateOperationsInput | string | null
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceCreateManyInput = {
    id?: string
    project_id: string
    client_id: string
    invoice_number: string
    amount: Decimal | DecimalJsLike | number | string
    due_date: Date | string
    status?: $Enums.InvoiceStatus
    payment_qr_url?: string | null
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    paid_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InvoiceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    payment_qr_url?: NullableStringFieldUpdateOperationsInput | string | null
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    payment_qr_url?: NullableStringFieldUpdateOperationsInput | string | null
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    payment_method: string
    transaction_id?: string | null
    payment_date?: Date | string
    notes?: string | null
    created_at?: Date | string
    invoice: InvoiceCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    invoice_id: string
    amount: Decimal | DecimalJsLike | number | string
    payment_method: string
    transaction_id?: string | null
    payment_date?: Date | string
    notes?: string | null
    created_at?: Date | string
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: StringFieldUpdateOperationsInput | string
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    invoice?: InvoiceUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: StringFieldUpdateOperationsInput | string
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInput = {
    id?: string
    invoice_id: string
    amount: Decimal | DecimalJsLike | number | string
    payment_method: string
    transaction_id?: string | null
    payment_date?: Date | string
    notes?: string | null
    created_at?: Date | string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: StringFieldUpdateOperationsInput | string
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: StringFieldUpdateOperationsInput | string
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateInput = {
    id?: string
    employee_id: string
    name: string
    role: string
    skill_type: string
    employment_type: string
    department?: string | null
    joining_date: Date | string
    basic_salary?: Decimal | DecimalJsLike | number | string
    overtime_rate?: Decimal | DecimalJsLike | number | string
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.MemberStatus
    created_at?: Date | string
    updated_at?: Date | string
    attendance?: AttendanceCreateNestedManyWithoutEmployeeInput
    allocations?: LabourAllocationCreateNestedManyWithoutEmployeeInput
    payroll_items?: PayrollLineCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: string
    employee_id: string
    name: string
    role: string
    skill_type: string
    employment_type: string
    department?: string | null
    joining_date: Date | string
    basic_salary?: Decimal | DecimalJsLike | number | string
    overtime_rate?: Decimal | DecimalJsLike | number | string
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.MemberStatus
    created_at?: Date | string
    updated_at?: Date | string
    attendance?: AttendanceUncheckedCreateNestedManyWithoutEmployeeInput
    allocations?: LabourAllocationUncheckedCreateNestedManyWithoutEmployeeInput
    payroll_items?: PayrollLineUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    skill_type?: StringFieldUpdateOperationsInput | string
    employment_type?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    joining_date?: DateTimeFieldUpdateOperationsInput | Date | string
    basic_salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtime_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: AttendanceUpdateManyWithoutEmployeeNestedInput
    allocations?: LabourAllocationUpdateManyWithoutEmployeeNestedInput
    payroll_items?: PayrollLineUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    skill_type?: StringFieldUpdateOperationsInput | string
    employment_type?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    joining_date?: DateTimeFieldUpdateOperationsInput | Date | string
    basic_salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtime_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: AttendanceUncheckedUpdateManyWithoutEmployeeNestedInput
    allocations?: LabourAllocationUncheckedUpdateManyWithoutEmployeeNestedInput
    payroll_items?: PayrollLineUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateManyInput = {
    id?: string
    employee_id: string
    name: string
    role: string
    skill_type: string
    employment_type: string
    department?: string | null
    joining_date: Date | string
    basic_salary?: Decimal | DecimalJsLike | number | string
    overtime_rate?: Decimal | DecimalJsLike | number | string
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.MemberStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type EmployeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    skill_type?: StringFieldUpdateOperationsInput | string
    employment_type?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    joining_date?: DateTimeFieldUpdateOperationsInput | Date | string
    basic_salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtime_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    skill_type?: StringFieldUpdateOperationsInput | string
    employment_type?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    joining_date?: DateTimeFieldUpdateOperationsInput | Date | string
    basic_salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtime_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateInput = {
    id?: string
    date: Date | string
    status: string
    overtime_hours?: number
    check_in?: Date | string | null
    check_out?: Date | string | null
    created_at?: Date | string
    employee: EmployeeCreateNestedOneWithoutAttendanceInput
    project?: ProjectCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateInput = {
    id?: string
    employee_id: string
    date: Date | string
    status: string
    overtime_hours?: number
    project_id?: string | null
    check_in?: Date | string | null
    check_out?: Date | string | null
    created_at?: Date | string
  }

  export type AttendanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    overtime_hours?: FloatFieldUpdateOperationsInput | number
    check_in?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    check_out?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutAttendanceNestedInput
    project?: ProjectUpdateOneWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    overtime_hours?: FloatFieldUpdateOperationsInput | number
    project_id?: NullableStringFieldUpdateOperationsInput | string | null
    check_in?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    check_out?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateManyInput = {
    id?: string
    employee_id: string
    date: Date | string
    status: string
    overtime_hours?: number
    project_id?: string | null
    check_in?: Date | string | null
    check_out?: Date | string | null
    created_at?: Date | string
  }

  export type AttendanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    overtime_hours?: FloatFieldUpdateOperationsInput | number
    check_in?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    check_out?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    overtime_hours?: FloatFieldUpdateOperationsInput | number
    project_id?: NullableStringFieldUpdateOperationsInput | string | null
    check_in?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    check_out?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabourAllocationCreateInput = {
    id?: string
    start_date: Date | string
    end_date?: Date | string | null
    status: string
    created_at?: Date | string
    employee: EmployeeCreateNestedOneWithoutAllocationsInput
    project: ProjectCreateNestedOneWithoutLabour_allocationsInput
  }

  export type LabourAllocationUncheckedCreateInput = {
    id?: string
    employee_id: string
    project_id: string
    start_date: Date | string
    end_date?: Date | string | null
    status: string
    created_at?: Date | string
  }

  export type LabourAllocationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutAllocationsNestedInput
    project?: ProjectUpdateOneRequiredWithoutLabour_allocationsNestedInput
  }

  export type LabourAllocationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabourAllocationCreateManyInput = {
    id?: string
    employee_id: string
    project_id: string
    start_date: Date | string
    end_date?: Date | string | null
    status: string
    created_at?: Date | string
  }

  export type LabourAllocationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabourAllocationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollCreateInput = {
    id?: string
    month: string
    status: string
    total_amount: Decimal | DecimalJsLike | number | string
    approved_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    lines?: PayrollLineCreateNestedManyWithoutPayrollInput
  }

  export type PayrollUncheckedCreateInput = {
    id?: string
    month: string
    status: string
    total_amount: Decimal | DecimalJsLike | number | string
    approved_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    lines?: PayrollLineUncheckedCreateNestedManyWithoutPayrollInput
  }

  export type PayrollUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: PayrollLineUpdateManyWithoutPayrollNestedInput
  }

  export type PayrollUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    lines?: PayrollLineUncheckedUpdateManyWithoutPayrollNestedInput
  }

  export type PayrollCreateManyInput = {
    id?: string
    month: string
    status: string
    total_amount: Decimal | DecimalJsLike | number | string
    approved_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PayrollUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollLineCreateInput = {
    id?: string
    basic_pay: Decimal | DecimalJsLike | number | string
    overtime_pay: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    total_pay: Decimal | DecimalJsLike | number | string
    status: string
    payroll: PayrollCreateNestedOneWithoutLinesInput
    employee: EmployeeCreateNestedOneWithoutPayroll_itemsInput
  }

  export type PayrollLineUncheckedCreateInput = {
    id?: string
    payroll_id: string
    employee_id: string
    basic_pay: Decimal | DecimalJsLike | number | string
    overtime_pay: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    total_pay: Decimal | DecimalJsLike | number | string
    status: string
  }

  export type PayrollLineUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    basic_pay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtime_pay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_pay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    payroll?: PayrollUpdateOneRequiredWithoutLinesNestedInput
    employee?: EmployeeUpdateOneRequiredWithoutPayroll_itemsNestedInput
  }

  export type PayrollLineUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    payroll_id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    basic_pay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtime_pay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_pay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type PayrollLineCreateManyInput = {
    id?: string
    payroll_id: string
    employee_id: string
    basic_pay: Decimal | DecimalJsLike | number | string
    overtime_pay: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    total_pay: Decimal | DecimalJsLike | number | string
    status: string
  }

  export type PayrollLineUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    basic_pay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtime_pay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_pay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type PayrollLineUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    payroll_id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    basic_pay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtime_pay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_pay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    message: string
    type?: $Enums.NotificationType
    link?: string | null
    read?: boolean
    created_at?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    user_id: string
    title: string
    message: string
    type?: $Enums.NotificationType
    link?: string | null
    read?: boolean
    created_at?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    user_id: string
    title: string
    message: string
    type?: $Enums.NotificationType
    link?: string | null
    read?: boolean
    created_at?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsCreateInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    updated_at?: Date | string
  }

  export type SystemSettingsUncheckedCreateInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    updated_at?: Date | string
  }

  export type SystemSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsCreateManyInput = {
    id?: string
    key: string
    value: JsonNullValueInput | InputJsonValue
    updated_at?: Date | string
  }

  export type SystemSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SystemSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: JsonNullValueInput | InputJsonValue
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateInput = {
    id?: string
    type: $Enums.TransactionType
    category: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    date: Date | string
    description?: string | null
    notes?: string | null
    payment_method?: string | null
    reference_number?: string | null
    attachment_url?: string | null
    tax_rate_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    creator: UserCreateNestedOneWithoutTransactionsInput
  }

  export type TransactionUncheckedCreateInput = {
    id?: string
    type: $Enums.TransactionType
    category: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    date: Date | string
    description?: string | null
    notes?: string | null
    payment_method?: string | null
    reference_number?: string | null
    attachment_url?: string | null
    tax_rate_id?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    attachment_url?: NullableStringFieldUpdateOperationsInput | string | null
    tax_rate_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type TransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    attachment_url?: NullableStringFieldUpdateOperationsInput | string | null
    tax_rate_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionCreateManyInput = {
    id?: string
    type: $Enums.TransactionType
    category: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    date: Date | string
    description?: string | null
    notes?: string | null
    payment_method?: string | null
    reference_number?: string | null
    attachment_url?: string | null
    tax_rate_id?: string | null
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    attachment_url?: NullableStringFieldUpdateOperationsInput | string | null
    tax_rate_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    attachment_url?: NullableStringFieldUpdateOperationsInput | string | null
    tax_rate_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemCreateInput = {
    id?: string
    code: string
    name: string
    category: string
    unit: string
    current_stock?: number
    min_stock?: number | null
    cost_price?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
    transactions?: InventoryTransactionCreateNestedManyWithoutItemInput
  }

  export type InventoryItemUncheckedCreateInput = {
    id?: string
    code: string
    name: string
    category: string
    unit: string
    current_stock?: number
    min_stock?: number | null
    cost_price?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
    transactions?: InventoryTransactionUncheckedCreateNestedManyWithoutItemInput
  }

  export type InventoryItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    current_stock?: FloatFieldUpdateOperationsInput | number
    min_stock?: NullableFloatFieldUpdateOperationsInput | number | null
    cost_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: InventoryTransactionUpdateManyWithoutItemNestedInput
  }

  export type InventoryItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    current_stock?: FloatFieldUpdateOperationsInput | number
    min_stock?: NullableFloatFieldUpdateOperationsInput | number | null
    cost_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: InventoryTransactionUncheckedUpdateManyWithoutItemNestedInput
  }

  export type InventoryItemCreateManyInput = {
    id?: string
    code: string
    name: string
    category: string
    unit: string
    current_stock?: number
    min_stock?: number | null
    cost_price?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InventoryItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    current_stock?: FloatFieldUpdateOperationsInput | number
    min_stock?: NullableFloatFieldUpdateOperationsInput | number | null
    cost_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    current_stock?: FloatFieldUpdateOperationsInput | number
    min_stock?: NullableFloatFieldUpdateOperationsInput | number | null
    cost_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryTransactionCreateInput = {
    id?: string
    type: $Enums.InventoryTransactionType
    quantity: number
    date?: Date | string
    reference_no?: string | null
    notes?: string | null
    created_at?: Date | string
    item: InventoryItemCreateNestedOneWithoutTransactionsInput
    project?: ProjectCreateNestedOneWithoutInventory_logsInput
    user: UserCreateNestedOneWithoutInventory_logsInput
  }

  export type InventoryTransactionUncheckedCreateInput = {
    id?: string
    item_id: string
    project_id?: string | null
    type: $Enums.InventoryTransactionType
    quantity: number
    date?: Date | string
    reference_no?: string | null
    notes?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type InventoryTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInventoryTransactionTypeFieldUpdateOperationsInput | $Enums.InventoryTransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: InventoryItemUpdateOneRequiredWithoutTransactionsNestedInput
    project?: ProjectUpdateOneWithoutInventory_logsNestedInput
    user?: UserUpdateOneRequiredWithoutInventory_logsNestedInput
  }

  export type InventoryTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    project_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInventoryTransactionTypeFieldUpdateOperationsInput | $Enums.InventoryTransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryTransactionCreateManyInput = {
    id?: string
    item_id: string
    project_id?: string | null
    type: $Enums.InventoryTransactionType
    quantity: number
    date?: Date | string
    reference_no?: string | null
    notes?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type InventoryTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInventoryTransactionTypeFieldUpdateOperationsInput | $Enums.InventoryTransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    project_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInventoryTransactionTypeFieldUpdateOperationsInput | $Enums.InventoryTransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseRequestCreateInput = {
    id?: string
    item_name: string
    quantity: number
    unit: string
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    priority?: $Enums.PriorityLevel
    status?: $Enums.PurchaseStatus
    needed_by?: Date | string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project?: ProjectCreateNestedOneWithoutPurchase_requestsInput
    requester: UserCreateNestedOneWithoutPurchase_requestsInput
    purchase_orders?: PurchaseOrderCreateNestedManyWithoutPurchase_requestInput
  }

  export type PurchaseRequestUncheckedCreateInput = {
    id?: string
    project_id?: string | null
    item_name: string
    quantity: number
    unit: string
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    priority?: $Enums.PriorityLevel
    status?: $Enums.PurchaseStatus
    requested_by: string
    needed_by?: Date | string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    purchase_orders?: PurchaseOrderUncheckedCreateNestedManyWithoutPurchase_requestInput
  }

  export type PurchaseRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_name?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priority?: EnumPriorityLevelFieldUpdateOperationsInput | $Enums.PriorityLevel
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    needed_by?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutPurchase_requestsNestedInput
    requester?: UserUpdateOneRequiredWithoutPurchase_requestsNestedInput
    purchase_orders?: PurchaseOrderUpdateManyWithoutPurchase_requestNestedInput
  }

  export type PurchaseRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: NullableStringFieldUpdateOperationsInput | string | null
    item_name?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priority?: EnumPriorityLevelFieldUpdateOperationsInput | $Enums.PriorityLevel
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    requested_by?: StringFieldUpdateOperationsInput | string
    needed_by?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase_orders?: PurchaseOrderUncheckedUpdateManyWithoutPurchase_requestNestedInput
  }

  export type PurchaseRequestCreateManyInput = {
    id?: string
    project_id?: string | null
    item_name: string
    quantity: number
    unit: string
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    priority?: $Enums.PriorityLevel
    status?: $Enums.PurchaseStatus
    requested_by: string
    needed_by?: Date | string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PurchaseRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_name?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priority?: EnumPriorityLevelFieldUpdateOperationsInput | $Enums.PriorityLevel
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    needed_by?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: NullableStringFieldUpdateOperationsInput | string | null
    item_name?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priority?: EnumPriorityLevelFieldUpdateOperationsInput | $Enums.PriorityLevel
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    requested_by?: StringFieldUpdateOperationsInput | string
    needed_by?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorCreateInput = {
    id?: string
    name: string
    contact_person?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    vat_no?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    purchase_orders?: PurchaseOrderCreateNestedManyWithoutVendorInput
    vendor_bills?: VendorBillCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateInput = {
    id?: string
    name: string
    contact_person?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    vat_no?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    purchase_orders?: PurchaseOrderUncheckedCreateNestedManyWithoutVendorInput
    vendor_bills?: VendorBillUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vat_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase_orders?: PurchaseOrderUpdateManyWithoutVendorNestedInput
    vendor_bills?: VendorBillUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vat_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase_orders?: PurchaseOrderUncheckedUpdateManyWithoutVendorNestedInput
    vendor_bills?: VendorBillUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type VendorCreateManyInput = {
    id?: string
    name: string
    contact_person?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    vat_no?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vat_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vat_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderCreateInput = {
    id?: string
    po_number: string
    total_amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.PurchaseStatus
    created_at?: Date | string
    updated_at?: Date | string
    purchase_request?: PurchaseRequestCreateNestedOneWithoutPurchase_ordersInput
    vendor: VendorCreateNestedOneWithoutPurchase_ordersInput
    creator: UserCreateNestedOneWithoutPurchase_ordersInput
    grns?: GRNCreateNestedManyWithoutPurchase_orderInput
    vendor_bills?: VendorBillCreateNestedManyWithoutPurchase_orderInput
  }

  export type PurchaseOrderUncheckedCreateInput = {
    id?: string
    po_number: string
    purchase_request_id?: string | null
    vendor_id: string
    total_amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.PurchaseStatus
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    grns?: GRNUncheckedCreateNestedManyWithoutPurchase_orderInput
    vendor_bills?: VendorBillUncheckedCreateNestedManyWithoutPurchase_orderInput
  }

  export type PurchaseOrderUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase_request?: PurchaseRequestUpdateOneWithoutPurchase_ordersNestedInput
    vendor?: VendorUpdateOneRequiredWithoutPurchase_ordersNestedInput
    creator?: UserUpdateOneRequiredWithoutPurchase_ordersNestedInput
    grns?: GRNUpdateManyWithoutPurchase_orderNestedInput
    vendor_bills?: VendorBillUpdateManyWithoutPurchase_orderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    purchase_request_id?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_id?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    grns?: GRNUncheckedUpdateManyWithoutPurchase_orderNestedInput
    vendor_bills?: VendorBillUncheckedUpdateManyWithoutPurchase_orderNestedInput
  }

  export type PurchaseOrderCreateManyInput = {
    id?: string
    po_number: string
    purchase_request_id?: string | null
    vendor_id: string
    total_amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.PurchaseStatus
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PurchaseOrderUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    purchase_request_id?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_id?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GRNCreateInput = {
    id?: string
    grn_number: string
    received_date?: Date | string
    notes?: string | null
    created_at?: Date | string
    purchase_order: PurchaseOrderCreateNestedOneWithoutGrnsInput
    receiver: UserCreateNestedOneWithoutGrnsInput
  }

  export type GRNUncheckedCreateInput = {
    id?: string
    grn_number: string
    purchase_order_id: string
    received_date?: Date | string
    received_by: string
    notes?: string | null
    created_at?: Date | string
  }

  export type GRNUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    grn_number?: StringFieldUpdateOperationsInput | string
    received_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase_order?: PurchaseOrderUpdateOneRequiredWithoutGrnsNestedInput
    receiver?: UserUpdateOneRequiredWithoutGrnsNestedInput
  }

  export type GRNUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    grn_number?: StringFieldUpdateOperationsInput | string
    purchase_order_id?: StringFieldUpdateOperationsInput | string
    received_date?: DateTimeFieldUpdateOperationsInput | Date | string
    received_by?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GRNCreateManyInput = {
    id?: string
    grn_number: string
    purchase_order_id: string
    received_date?: Date | string
    received_by: string
    notes?: string | null
    created_at?: Date | string
  }

  export type GRNUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    grn_number?: StringFieldUpdateOperationsInput | string
    received_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GRNUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    grn_number?: StringFieldUpdateOperationsInput | string
    purchase_order_id?: StringFieldUpdateOperationsInput | string
    received_date?: DateTimeFieldUpdateOperationsInput | Date | string
    received_by?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorBillCreateInput = {
    id?: string
    bill_number: string
    amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    due_date: Date | string
    status?: $Enums.InvoiceStatus
    created_at?: Date | string
    updated_at?: Date | string
    purchase_order: PurchaseOrderCreateNestedOneWithoutVendor_billsInput
    vendor: VendorCreateNestedOneWithoutVendor_billsInput
    vendor_payments?: VendorPaymentCreateNestedManyWithoutVendor_billInput
  }

  export type VendorBillUncheckedCreateInput = {
    id?: string
    bill_number: string
    purchase_order_id: string
    vendor_id: string
    amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    due_date: Date | string
    status?: $Enums.InvoiceStatus
    created_at?: Date | string
    updated_at?: Date | string
    vendor_payments?: VendorPaymentUncheckedCreateNestedManyWithoutVendor_billInput
  }

  export type VendorBillUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bill_number?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase_order?: PurchaseOrderUpdateOneRequiredWithoutVendor_billsNestedInput
    vendor?: VendorUpdateOneRequiredWithoutVendor_billsNestedInput
    vendor_payments?: VendorPaymentUpdateManyWithoutVendor_billNestedInput
  }

  export type VendorBillUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bill_number?: StringFieldUpdateOperationsInput | string
    purchase_order_id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor_payments?: VendorPaymentUncheckedUpdateManyWithoutVendor_billNestedInput
  }

  export type VendorBillCreateManyInput = {
    id?: string
    bill_number: string
    purchase_order_id: string
    vendor_id: string
    amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    due_date: Date | string
    status?: $Enums.InvoiceStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorBillUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    bill_number?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorBillUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bill_number?: StringFieldUpdateOperationsInput | string
    purchase_order_id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorPaymentCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string
    payment_method: string
    reference_no?: string | null
    notes?: string | null
    created_at?: Date | string
    vendor_bill: VendorBillCreateNestedOneWithoutVendor_paymentsInput
  }

  export type VendorPaymentUncheckedCreateInput = {
    id?: string
    vendor_bill_id: string
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string
    payment_method: string
    reference_no?: string | null
    notes?: string | null
    created_at?: Date | string
  }

  export type VendorPaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: StringFieldUpdateOperationsInput | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor_bill?: VendorBillUpdateOneRequiredWithoutVendor_paymentsNestedInput
  }

  export type VendorPaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_bill_id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: StringFieldUpdateOperationsInput | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorPaymentCreateManyInput = {
    id?: string
    vendor_bill_id: string
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string
    payment_method: string
    reference_no?: string | null
    notes?: string | null
    created_at?: Date | string
  }

  export type VendorPaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: StringFieldUpdateOperationsInput | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorPaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    vendor_bill_id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: StringFieldUpdateOperationsInput | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountCreateInput = {
    id?: string
    name: string
    account_number?: string | null
    bank_name?: string | null
    currency?: string
    current_balance?: Decimal | DecimalJsLike | number | string
    type?: string
    created_at?: Date | string
    updated_at?: Date | string
    transactions?: BankTransactionCreateNestedManyWithoutBank_accountInput
  }

  export type BankAccountUncheckedCreateInput = {
    id?: string
    name: string
    account_number?: string | null
    bank_name?: string | null
    currency?: string
    current_balance?: Decimal | DecimalJsLike | number | string
    type?: string
    created_at?: Date | string
    updated_at?: Date | string
    transactions?: BankTransactionUncheckedCreateNestedManyWithoutBank_accountInput
  }

  export type BankAccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    current_balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: BankTransactionUpdateManyWithoutBank_accountNestedInput
  }

  export type BankAccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    current_balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    transactions?: BankTransactionUncheckedUpdateManyWithoutBank_accountNestedInput
  }

  export type BankAccountCreateManyInput = {
    id?: string
    name: string
    account_number?: string | null
    bank_name?: string | null
    currency?: string
    current_balance?: Decimal | DecimalJsLike | number | string
    type?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BankAccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    current_balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    current_balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankTransactionCreateInput = {
    id?: string
    date: Date | string
    description: string
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    status?: string
    type: string
    system_transaction_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    bank_account: BankAccountCreateNestedOneWithoutTransactionsInput
  }

  export type BankTransactionUncheckedCreateInput = {
    id?: string
    bank_account_id: string
    date: Date | string
    description: string
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    status?: string
    type: string
    system_transaction_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BankTransactionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    system_transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    bank_account?: BankAccountUpdateOneRequiredWithoutTransactionsNestedInput
  }

  export type BankTransactionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank_account_id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    system_transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankTransactionCreateManyInput = {
    id?: string
    bank_account_id: string
    date: Date | string
    description: string
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    status?: string
    type: string
    system_transaction_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BankTransactionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    system_transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankTransactionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    bank_account_id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    system_transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type EnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type ProjectListRelationFilter = {
    every?: ProjectWhereInput
    some?: ProjectWhereInput
    none?: ProjectWhereInput
  }

  export type ProjectFileListRelationFilter = {
    every?: ProjectFileWhereInput
    some?: ProjectFileWhereInput
    none?: ProjectFileWhereInput
  }

  export type ProjectUpdateListRelationFilter = {
    every?: ProjectUpdateWhereInput
    some?: ProjectUpdateWhereInput
    none?: ProjectUpdateWhereInput
  }

  export type SupportRequestListRelationFilter = {
    every?: SupportRequestWhereInput
    some?: SupportRequestWhereInput
    none?: SupportRequestWhereInput
  }

  export type SupportMessageListRelationFilter = {
    every?: SupportMessageWhereInput
    some?: SupportMessageWhereInput
    none?: SupportMessageWhereInput
  }

  export type MeetingRequestListRelationFilter = {
    every?: MeetingRequestWhereInput
    some?: MeetingRequestWhereInput
    none?: MeetingRequestWhereInput
  }

  export type InvoiceListRelationFilter = {
    every?: InvoiceWhereInput
    some?: InvoiceWhereInput
    none?: InvoiceWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type TransactionListRelationFilter = {
    every?: TransactionWhereInput
    some?: TransactionWhereInput
    none?: TransactionWhereInput
  }

  export type InventoryTransactionListRelationFilter = {
    every?: InventoryTransactionWhereInput
    some?: InventoryTransactionWhereInput
    none?: InventoryTransactionWhereInput
  }

  export type PurchaseRequestListRelationFilter = {
    every?: PurchaseRequestWhereInput
    some?: PurchaseRequestWhereInput
    none?: PurchaseRequestWhereInput
  }

  export type PurchaseOrderListRelationFilter = {
    every?: PurchaseOrderWhereInput
    some?: PurchaseOrderWhereInput
    none?: PurchaseOrderWhereInput
  }

  export type GRNListRelationFilter = {
    every?: GRNWhereInput
    some?: GRNWhereInput
    none?: GRNWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type ProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectFileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectUpdateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupportRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SupportMessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MeetingRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InventoryTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PurchaseOrderOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type GRNOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    full_name?: SortOrder
    role?: SortOrder
    avatar_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    full_name?: SortOrder
    role?: SortOrder
    avatar_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    full_name?: SortOrder
    role?: SortOrder
    avatar_url?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type EnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type EnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type AttendanceListRelationFilter = {
    every?: AttendanceWhereInput
    some?: AttendanceWhereInput
    none?: AttendanceWhereInput
  }

  export type LabourAllocationListRelationFilter = {
    every?: LabourAllocationWhereInput
    some?: LabourAllocationWhereInput
    none?: LabourAllocationWhereInput
  }

  export type AttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LabourAllocationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProjectCountOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    github_link?: SortOrder
    estimated_cost?: SortOrder
    actual_cost?: SortOrder
    deadline?: SortOrder
    test_asset_url?: SortOrder
    deployment_url?: SortOrder
    live_preview_type?: SortOrder
    live_preview_url?: SortOrder
    technical_config?: SortOrder
    tickets?: SortOrder
    notes?: SortOrder
    labour_data?: SortOrder
    inventory_data?: SortOrder
    resources_data?: SortOrder
    design_data?: SortOrder
    expenses_data?: SortOrder
    timeline_data?: SortOrder
    is_featured?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProjectAvgOrderByAggregateInput = {
    estimated_cost?: SortOrder
    actual_cost?: SortOrder
  }

  export type ProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    github_link?: SortOrder
    estimated_cost?: SortOrder
    actual_cost?: SortOrder
    deadline?: SortOrder
    test_asset_url?: SortOrder
    deployment_url?: SortOrder
    live_preview_type?: SortOrder
    live_preview_url?: SortOrder
    is_featured?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProjectMinOrderByAggregateInput = {
    id?: SortOrder
    client_id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    status?: SortOrder
    github_link?: SortOrder
    estimated_cost?: SortOrder
    actual_cost?: SortOrder
    deadline?: SortOrder
    test_asset_url?: SortOrder
    deployment_url?: SortOrder
    live_preview_type?: SortOrder
    live_preview_url?: SortOrder
    is_featured?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type ProjectSumOrderByAggregateInput = {
    estimated_cost?: SortOrder
    actual_cost?: SortOrder
  }

  export type EnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumFileTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeFilter<$PrismaModel> | $Enums.FileType
  }

  export type BigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type ProjectScalarRelationFilter = {
    is?: ProjectWhereInput
    isNot?: ProjectWhereInput
  }

  export type ProjectFileCountOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    file_name?: SortOrder
    file_url?: SortOrder
    file_type?: SortOrder
    file_size?: SortOrder
    uploaded_by?: SortOrder
    created_at?: SortOrder
  }

  export type ProjectFileAvgOrderByAggregateInput = {
    file_size?: SortOrder
  }

  export type ProjectFileMaxOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    file_name?: SortOrder
    file_url?: SortOrder
    file_type?: SortOrder
    file_size?: SortOrder
    uploaded_by?: SortOrder
    created_at?: SortOrder
  }

  export type ProjectFileMinOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    file_name?: SortOrder
    file_url?: SortOrder
    file_type?: SortOrder
    file_size?: SortOrder
    uploaded_by?: SortOrder
    created_at?: SortOrder
  }

  export type ProjectFileSumOrderByAggregateInput = {
    file_size?: SortOrder
  }

  export type EnumFileTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeWithAggregatesFilter<$PrismaModel> | $Enums.FileType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileTypeFilter<$PrismaModel>
    _max?: NestedEnumFileTypeFilter<$PrismaModel>
  }

  export type BigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type ProjectUpdateCountOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    update_text?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type ProjectUpdateMaxOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    update_text?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type ProjectUpdateMinOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    update_text?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type EnumSupportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SupportStatus | EnumSupportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SupportStatus[] | ListEnumSupportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SupportStatus[] | ListEnumSupportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSupportStatusFilter<$PrismaModel> | $Enums.SupportStatus
  }

  export type EnumPriorityLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.PriorityLevel | EnumPriorityLevelFieldRefInput<$PrismaModel>
    in?: $Enums.PriorityLevel[] | ListEnumPriorityLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PriorityLevel[] | ListEnumPriorityLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityLevelFilter<$PrismaModel> | $Enums.PriorityLevel
  }

  export type ProjectNullableScalarRelationFilter = {
    is?: ProjectWhereInput | null
    isNot?: ProjectWhereInput | null
  }

  export type SupportRequestCountOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    client_id?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SupportRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    client_id?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type SupportRequestMinOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    client_id?: SortOrder
    subject?: SortOrder
    description?: SortOrder
    status?: SortOrder
    priority?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EnumSupportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SupportStatus | EnumSupportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SupportStatus[] | ListEnumSupportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SupportStatus[] | ListEnumSupportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSupportStatusWithAggregatesFilter<$PrismaModel> | $Enums.SupportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSupportStatusFilter<$PrismaModel>
    _max?: NestedEnumSupportStatusFilter<$PrismaModel>
  }

  export type EnumPriorityLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PriorityLevel | EnumPriorityLevelFieldRefInput<$PrismaModel>
    in?: $Enums.PriorityLevel[] | ListEnumPriorityLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PriorityLevel[] | ListEnumPriorityLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityLevelWithAggregatesFilter<$PrismaModel> | $Enums.PriorityLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityLevelFilter<$PrismaModel>
    _max?: NestedEnumPriorityLevelFilter<$PrismaModel>
  }

  export type SupportRequestScalarRelationFilter = {
    is?: SupportRequestWhereInput
    isNot?: SupportRequestWhereInput
  }

  export type SupportMessageCountOrderByAggregateInput = {
    id?: SortOrder
    support_request_id?: SortOrder
    user_id?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
  }

  export type SupportMessageMaxOrderByAggregateInput = {
    id?: SortOrder
    support_request_id?: SortOrder
    user_id?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
  }

  export type SupportMessageMinOrderByAggregateInput = {
    id?: SortOrder
    support_request_id?: SortOrder
    user_id?: SortOrder
    message?: SortOrder
    created_at?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type EnumMeetingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MeetingStatus | EnumMeetingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MeetingStatus[] | ListEnumMeetingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeetingStatus[] | ListEnumMeetingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMeetingStatusFilter<$PrismaModel> | $Enums.MeetingStatus
  }

  export type MeetingRequestCountOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    client_id?: SortOrder
    requested_date?: SortOrder
    duration_minutes?: SortOrder
    purpose?: SortOrder
    status?: SortOrder
    meeting_link?: SortOrder
    admin_notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MeetingRequestAvgOrderByAggregateInput = {
    duration_minutes?: SortOrder
  }

  export type MeetingRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    client_id?: SortOrder
    requested_date?: SortOrder
    duration_minutes?: SortOrder
    purpose?: SortOrder
    status?: SortOrder
    meeting_link?: SortOrder
    admin_notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MeetingRequestMinOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    client_id?: SortOrder
    requested_date?: SortOrder
    duration_minutes?: SortOrder
    purpose?: SortOrder
    status?: SortOrder
    meeting_link?: SortOrder
    admin_notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type MeetingRequestSumOrderByAggregateInput = {
    duration_minutes?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type EnumMeetingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MeetingStatus | EnumMeetingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MeetingStatus[] | ListEnumMeetingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeetingStatus[] | ListEnumMeetingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMeetingStatusWithAggregatesFilter<$PrismaModel> | $Enums.MeetingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMeetingStatusFilter<$PrismaModel>
    _max?: NestedEnumMeetingStatusFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InvoiceCountOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    client_id?: SortOrder
    invoice_number?: SortOrder
    amount?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    payment_qr_url?: SortOrder
    bank_details?: SortOrder
    paid_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type InvoiceAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InvoiceMaxOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    client_id?: SortOrder
    invoice_number?: SortOrder
    amount?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    payment_qr_url?: SortOrder
    paid_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type InvoiceMinOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    client_id?: SortOrder
    invoice_number?: SortOrder
    amount?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    payment_qr_url?: SortOrder
    paid_at?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type InvoiceSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type InvoiceScalarRelationFilter = {
    is?: InvoiceWhereInput
    isNot?: InvoiceWhereInput
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    amount?: SortOrder
    payment_method?: SortOrder
    transaction_id?: SortOrder
    payment_date?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    amount?: SortOrder
    payment_method?: SortOrder
    transaction_id?: SortOrder
    payment_date?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    invoice_id?: SortOrder
    amount?: SortOrder
    payment_method?: SortOrder
    transaction_id?: SortOrder
    payment_date?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type EnumMemberStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberStatus | EnumMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberStatusFilter<$PrismaModel> | $Enums.MemberStatus
  }

  export type PayrollLineListRelationFilter = {
    every?: PayrollLineWhereInput
    some?: PayrollLineWhereInput
    none?: PayrollLineWhereInput
  }

  export type PayrollLineOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    skill_type?: SortOrder
    employment_type?: SortOrder
    department?: SortOrder
    joining_date?: SortOrder
    basic_salary?: SortOrder
    overtime_rate?: SortOrder
    bank_details?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EmployeeAvgOrderByAggregateInput = {
    basic_salary?: SortOrder
    overtime_rate?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    skill_type?: SortOrder
    employment_type?: SortOrder
    department?: SortOrder
    joining_date?: SortOrder
    basic_salary?: SortOrder
    overtime_rate?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    name?: SortOrder
    role?: SortOrder
    skill_type?: SortOrder
    employment_type?: SortOrder
    department?: SortOrder
    joining_date?: SortOrder
    basic_salary?: SortOrder
    overtime_rate?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type EmployeeSumOrderByAggregateInput = {
    basic_salary?: SortOrder
    overtime_rate?: SortOrder
  }

  export type EnumMemberStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberStatus | EnumMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberStatusWithAggregatesFilter<$PrismaModel> | $Enums.MemberStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMemberStatusFilter<$PrismaModel>
    _max?: NestedEnumMemberStatusFilter<$PrismaModel>
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type EmployeeScalarRelationFilter = {
    is?: EmployeeWhereInput
    isNot?: EmployeeWhereInput
  }

  export type AttendanceEmployee_idDateCompoundUniqueInput = {
    employee_id: string
    date: Date | string
  }

  export type AttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    overtime_hours?: SortOrder
    project_id?: SortOrder
    check_in?: SortOrder
    check_out?: SortOrder
    created_at?: SortOrder
  }

  export type AttendanceAvgOrderByAggregateInput = {
    overtime_hours?: SortOrder
  }

  export type AttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    overtime_hours?: SortOrder
    project_id?: SortOrder
    check_in?: SortOrder
    check_out?: SortOrder
    created_at?: SortOrder
  }

  export type AttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    date?: SortOrder
    status?: SortOrder
    overtime_hours?: SortOrder
    project_id?: SortOrder
    check_in?: SortOrder
    check_out?: SortOrder
    created_at?: SortOrder
  }

  export type AttendanceSumOrderByAggregateInput = {
    overtime_hours?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type LabourAllocationCountOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    project_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type LabourAllocationMaxOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    project_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type LabourAllocationMinOrderByAggregateInput = {
    id?: SortOrder
    employee_id?: SortOrder
    project_id?: SortOrder
    start_date?: SortOrder
    end_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
  }

  export type PayrollCountOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    status?: SortOrder
    total_amount?: SortOrder
    approved_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PayrollAvgOrderByAggregateInput = {
    total_amount?: SortOrder
  }

  export type PayrollMaxOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    status?: SortOrder
    total_amount?: SortOrder
    approved_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PayrollMinOrderByAggregateInput = {
    id?: SortOrder
    month?: SortOrder
    status?: SortOrder
    total_amount?: SortOrder
    approved_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PayrollSumOrderByAggregateInput = {
    total_amount?: SortOrder
  }

  export type PayrollScalarRelationFilter = {
    is?: PayrollWhereInput
    isNot?: PayrollWhereInput
  }

  export type PayrollLineCountOrderByAggregateInput = {
    id?: SortOrder
    payroll_id?: SortOrder
    employee_id?: SortOrder
    basic_pay?: SortOrder
    overtime_pay?: SortOrder
    deductions?: SortOrder
    total_pay?: SortOrder
    status?: SortOrder
  }

  export type PayrollLineAvgOrderByAggregateInput = {
    basic_pay?: SortOrder
    overtime_pay?: SortOrder
    deductions?: SortOrder
    total_pay?: SortOrder
  }

  export type PayrollLineMaxOrderByAggregateInput = {
    id?: SortOrder
    payroll_id?: SortOrder
    employee_id?: SortOrder
    basic_pay?: SortOrder
    overtime_pay?: SortOrder
    deductions?: SortOrder
    total_pay?: SortOrder
    status?: SortOrder
  }

  export type PayrollLineMinOrderByAggregateInput = {
    id?: SortOrder
    payroll_id?: SortOrder
    employee_id?: SortOrder
    basic_pay?: SortOrder
    overtime_pay?: SortOrder
    deductions?: SortOrder
    total_pay?: SortOrder
    status?: SortOrder
  }

  export type PayrollLineSumOrderByAggregateInput = {
    basic_pay?: SortOrder
    overtime_pay?: SortOrder
    deductions?: SortOrder
    total_pay?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    link?: SortOrder
    read?: SortOrder
    created_at?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    link?: SortOrder
    read?: SortOrder
    created_at?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    user_id?: SortOrder
    title?: SortOrder
    message?: SortOrder
    type?: SortOrder
    link?: SortOrder
    read?: SortOrder
    created_at?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }
  export type JsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonFilterBase<$PrismaModel>>, 'path'>>

  export type JsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type SystemSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    updated_at?: SortOrder
  }

  export type SystemSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    updated_at?: SortOrder
  }

  export type SystemSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    updated_at?: SortOrder
  }
  export type JsonWithAggregatesFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedJsonFilter<$PrismaModel>
    _max?: NestedJsonFilter<$PrismaModel>
  }

  export type EnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type TransactionCountOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    exchange_rate?: SortOrder
    date?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    payment_method?: SortOrder
    reference_number?: SortOrder
    attachment_url?: SortOrder
    tax_rate_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
    exchange_rate?: SortOrder
  }

  export type TransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    exchange_rate?: SortOrder
    date?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    payment_method?: SortOrder
    reference_number?: SortOrder
    attachment_url?: SortOrder
    tax_rate_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TransactionMinOrderByAggregateInput = {
    id?: SortOrder
    type?: SortOrder
    category?: SortOrder
    amount?: SortOrder
    currency?: SortOrder
    exchange_rate?: SortOrder
    date?: SortOrder
    description?: SortOrder
    notes?: SortOrder
    payment_method?: SortOrder
    reference_number?: SortOrder
    attachment_url?: SortOrder
    tax_rate_id?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type TransactionSumOrderByAggregateInput = {
    amount?: SortOrder
    exchange_rate?: SortOrder
  }

  export type EnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type InventoryItemCountOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unit?: SortOrder
    current_stock?: SortOrder
    min_stock?: SortOrder
    cost_price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type InventoryItemAvgOrderByAggregateInput = {
    current_stock?: SortOrder
    min_stock?: SortOrder
    cost_price?: SortOrder
  }

  export type InventoryItemMaxOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unit?: SortOrder
    current_stock?: SortOrder
    min_stock?: SortOrder
    cost_price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type InventoryItemMinOrderByAggregateInput = {
    id?: SortOrder
    code?: SortOrder
    name?: SortOrder
    category?: SortOrder
    unit?: SortOrder
    current_stock?: SortOrder
    min_stock?: SortOrder
    cost_price?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type InventoryItemSumOrderByAggregateInput = {
    current_stock?: SortOrder
    min_stock?: SortOrder
    cost_price?: SortOrder
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type EnumInventoryTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryTransactionType | EnumInventoryTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryTransactionType[] | ListEnumInventoryTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryTransactionType[] | ListEnumInventoryTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryTransactionTypeFilter<$PrismaModel> | $Enums.InventoryTransactionType
  }

  export type InventoryItemScalarRelationFilter = {
    is?: InventoryItemWhereInput
    isNot?: InventoryItemWhereInput
  }

  export type InventoryTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    project_id?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    date?: SortOrder
    reference_no?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type InventoryTransactionAvgOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type InventoryTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    project_id?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    date?: SortOrder
    reference_no?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type InventoryTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    item_id?: SortOrder
    project_id?: SortOrder
    type?: SortOrder
    quantity?: SortOrder
    date?: SortOrder
    reference_no?: SortOrder
    notes?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
  }

  export type InventoryTransactionSumOrderByAggregateInput = {
    quantity?: SortOrder
  }

  export type EnumInventoryTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryTransactionType | EnumInventoryTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryTransactionType[] | ListEnumInventoryTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryTransactionType[] | ListEnumInventoryTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.InventoryTransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInventoryTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumInventoryTransactionTypeFilter<$PrismaModel>
  }

  export type EnumPurchaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseStatus | EnumPurchaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseStatusFilter<$PrismaModel> | $Enums.PurchaseStatus
  }

  export type PurchaseRequestCountOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    item_name?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    estimated_cost?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    requested_by?: SortOrder
    needed_by?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PurchaseRequestAvgOrderByAggregateInput = {
    quantity?: SortOrder
    estimated_cost?: SortOrder
  }

  export type PurchaseRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    item_name?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    estimated_cost?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    requested_by?: SortOrder
    needed_by?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PurchaseRequestMinOrderByAggregateInput = {
    id?: SortOrder
    project_id?: SortOrder
    item_name?: SortOrder
    quantity?: SortOrder
    unit?: SortOrder
    estimated_cost?: SortOrder
    priority?: SortOrder
    status?: SortOrder
    requested_by?: SortOrder
    needed_by?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PurchaseRequestSumOrderByAggregateInput = {
    quantity?: SortOrder
    estimated_cost?: SortOrder
  }

  export type EnumPurchaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseStatus | EnumPurchaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.PurchaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPurchaseStatusFilter<$PrismaModel>
    _max?: NestedEnumPurchaseStatusFilter<$PrismaModel>
  }

  export type VendorBillListRelationFilter = {
    every?: VendorBillWhereInput
    some?: VendorBillWhereInput
    none?: VendorBillWhereInput
  }

  export type VendorBillOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact_person?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    vat_no?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VendorMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact_person?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    vat_no?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VendorMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    contact_person?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    address?: SortOrder
    vat_no?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PurchaseRequestNullableScalarRelationFilter = {
    is?: PurchaseRequestWhereInput | null
    isNot?: PurchaseRequestWhereInput | null
  }

  export type VendorScalarRelationFilter = {
    is?: VendorWhereInput
    isNot?: VendorWhereInput
  }

  export type PurchaseOrderCountOrderByAggregateInput = {
    id?: SortOrder
    po_number?: SortOrder
    purchase_request_id?: SortOrder
    vendor_id?: SortOrder
    total_amount?: SortOrder
    status?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PurchaseOrderAvgOrderByAggregateInput = {
    total_amount?: SortOrder
  }

  export type PurchaseOrderMaxOrderByAggregateInput = {
    id?: SortOrder
    po_number?: SortOrder
    purchase_request_id?: SortOrder
    vendor_id?: SortOrder
    total_amount?: SortOrder
    status?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PurchaseOrderMinOrderByAggregateInput = {
    id?: SortOrder
    po_number?: SortOrder
    purchase_request_id?: SortOrder
    vendor_id?: SortOrder
    total_amount?: SortOrder
    status?: SortOrder
    created_by?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type PurchaseOrderSumOrderByAggregateInput = {
    total_amount?: SortOrder
  }

  export type PurchaseOrderScalarRelationFilter = {
    is?: PurchaseOrderWhereInput
    isNot?: PurchaseOrderWhereInput
  }

  export type GRNCountOrderByAggregateInput = {
    id?: SortOrder
    grn_number?: SortOrder
    purchase_order_id?: SortOrder
    received_date?: SortOrder
    received_by?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
  }

  export type GRNMaxOrderByAggregateInput = {
    id?: SortOrder
    grn_number?: SortOrder
    purchase_order_id?: SortOrder
    received_date?: SortOrder
    received_by?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
  }

  export type GRNMinOrderByAggregateInput = {
    id?: SortOrder
    grn_number?: SortOrder
    purchase_order_id?: SortOrder
    received_date?: SortOrder
    received_by?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
  }

  export type VendorPaymentListRelationFilter = {
    every?: VendorPaymentWhereInput
    some?: VendorPaymentWhereInput
    none?: VendorPaymentWhereInput
  }

  export type VendorPaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type VendorBillCountOrderByAggregateInput = {
    id?: SortOrder
    bill_number?: SortOrder
    purchase_order_id?: SortOrder
    vendor_id?: SortOrder
    amount?: SortOrder
    tax_amount?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VendorBillAvgOrderByAggregateInput = {
    amount?: SortOrder
    tax_amount?: SortOrder
  }

  export type VendorBillMaxOrderByAggregateInput = {
    id?: SortOrder
    bill_number?: SortOrder
    purchase_order_id?: SortOrder
    vendor_id?: SortOrder
    amount?: SortOrder
    tax_amount?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VendorBillMinOrderByAggregateInput = {
    id?: SortOrder
    bill_number?: SortOrder
    purchase_order_id?: SortOrder
    vendor_id?: SortOrder
    amount?: SortOrder
    tax_amount?: SortOrder
    due_date?: SortOrder
    status?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type VendorBillSumOrderByAggregateInput = {
    amount?: SortOrder
    tax_amount?: SortOrder
  }

  export type VendorBillScalarRelationFilter = {
    is?: VendorBillWhereInput
    isNot?: VendorBillWhereInput
  }

  export type VendorPaymentCountOrderByAggregateInput = {
    id?: SortOrder
    vendor_bill_id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_method?: SortOrder
    reference_no?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
  }

  export type VendorPaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type VendorPaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    vendor_bill_id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_method?: SortOrder
    reference_no?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
  }

  export type VendorPaymentMinOrderByAggregateInput = {
    id?: SortOrder
    vendor_bill_id?: SortOrder
    amount?: SortOrder
    payment_date?: SortOrder
    payment_method?: SortOrder
    reference_no?: SortOrder
    notes?: SortOrder
    created_at?: SortOrder
  }

  export type VendorPaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BankTransactionListRelationFilter = {
    every?: BankTransactionWhereInput
    some?: BankTransactionWhereInput
    none?: BankTransactionWhereInput
  }

  export type BankTransactionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BankAccountCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    account_number?: SortOrder
    bank_name?: SortOrder
    currency?: SortOrder
    current_balance?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BankAccountAvgOrderByAggregateInput = {
    current_balance?: SortOrder
  }

  export type BankAccountMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    account_number?: SortOrder
    bank_name?: SortOrder
    currency?: SortOrder
    current_balance?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BankAccountMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    account_number?: SortOrder
    bank_name?: SortOrder
    currency?: SortOrder
    current_balance?: SortOrder
    type?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BankAccountSumOrderByAggregateInput = {
    current_balance?: SortOrder
  }

  export type BankAccountScalarRelationFilter = {
    is?: BankAccountWhereInput
    isNot?: BankAccountWhereInput
  }

  export type BankTransactionCountOrderByAggregateInput = {
    id?: SortOrder
    bank_account_id?: SortOrder
    date?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    type?: SortOrder
    system_transaction_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BankTransactionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type BankTransactionMaxOrderByAggregateInput = {
    id?: SortOrder
    bank_account_id?: SortOrder
    date?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    type?: SortOrder
    system_transaction_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BankTransactionMinOrderByAggregateInput = {
    id?: SortOrder
    bank_account_id?: SortOrder
    date?: SortOrder
    description?: SortOrder
    amount?: SortOrder
    reference?: SortOrder
    status?: SortOrder
    type?: SortOrder
    system_transaction_id?: SortOrder
    created_at?: SortOrder
    updated_at?: SortOrder
  }

  export type BankTransactionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type ProjectCreateNestedManyWithoutClientInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectFileCreateNestedManyWithoutUploaderInput = {
    create?: XOR<ProjectFileCreateWithoutUploaderInput, ProjectFileUncheckedCreateWithoutUploaderInput> | ProjectFileCreateWithoutUploaderInput[] | ProjectFileUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: ProjectFileCreateOrConnectWithoutUploaderInput | ProjectFileCreateOrConnectWithoutUploaderInput[]
    createMany?: ProjectFileCreateManyUploaderInputEnvelope
    connect?: ProjectFileWhereUniqueInput | ProjectFileWhereUniqueInput[]
  }

  export type ProjectUpdateCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ProjectUpdateCreateWithoutAuthorInput, ProjectUpdateUncheckedCreateWithoutAuthorInput> | ProjectUpdateCreateWithoutAuthorInput[] | ProjectUpdateUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ProjectUpdateCreateOrConnectWithoutAuthorInput | ProjectUpdateCreateOrConnectWithoutAuthorInput[]
    createMany?: ProjectUpdateCreateManyAuthorInputEnvelope
    connect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
  }

  export type SupportRequestCreateNestedManyWithoutClientInput = {
    create?: XOR<SupportRequestCreateWithoutClientInput, SupportRequestUncheckedCreateWithoutClientInput> | SupportRequestCreateWithoutClientInput[] | SupportRequestUncheckedCreateWithoutClientInput[]
    connectOrCreate?: SupportRequestCreateOrConnectWithoutClientInput | SupportRequestCreateOrConnectWithoutClientInput[]
    createMany?: SupportRequestCreateManyClientInputEnvelope
    connect?: SupportRequestWhereUniqueInput | SupportRequestWhereUniqueInput[]
  }

  export type SupportMessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<SupportMessageCreateWithoutSenderInput, SupportMessageUncheckedCreateWithoutSenderInput> | SupportMessageCreateWithoutSenderInput[] | SupportMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: SupportMessageCreateOrConnectWithoutSenderInput | SupportMessageCreateOrConnectWithoutSenderInput[]
    createMany?: SupportMessageCreateManySenderInputEnvelope
    connect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
  }

  export type MeetingRequestCreateNestedManyWithoutClientInput = {
    create?: XOR<MeetingRequestCreateWithoutClientInput, MeetingRequestUncheckedCreateWithoutClientInput> | MeetingRequestCreateWithoutClientInput[] | MeetingRequestUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MeetingRequestCreateOrConnectWithoutClientInput | MeetingRequestCreateOrConnectWithoutClientInput[]
    createMany?: MeetingRequestCreateManyClientInputEnvelope
    connect?: MeetingRequestWhereUniqueInput | MeetingRequestWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutClientInput = {
    create?: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput> | InvoiceCreateWithoutClientInput[] | InvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClientInput | InvoiceCreateOrConnectWithoutClientInput[]
    createMany?: InvoiceCreateManyClientInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type TransactionCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TransactionCreateWithoutCreatorInput, TransactionUncheckedCreateWithoutCreatorInput> | TransactionCreateWithoutCreatorInput[] | TransactionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCreatorInput | TransactionCreateOrConnectWithoutCreatorInput[]
    createMany?: TransactionCreateManyCreatorInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type InventoryTransactionCreateNestedManyWithoutUserInput = {
    create?: XOR<InventoryTransactionCreateWithoutUserInput, InventoryTransactionUncheckedCreateWithoutUserInput> | InventoryTransactionCreateWithoutUserInput[] | InventoryTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutUserInput | InventoryTransactionCreateOrConnectWithoutUserInput[]
    createMany?: InventoryTransactionCreateManyUserInputEnvelope
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
  }

  export type PurchaseRequestCreateNestedManyWithoutRequesterInput = {
    create?: XOR<PurchaseRequestCreateWithoutRequesterInput, PurchaseRequestUncheckedCreateWithoutRequesterInput> | PurchaseRequestCreateWithoutRequesterInput[] | PurchaseRequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: PurchaseRequestCreateOrConnectWithoutRequesterInput | PurchaseRequestCreateOrConnectWithoutRequesterInput[]
    createMany?: PurchaseRequestCreateManyRequesterInputEnvelope
    connect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
  }

  export type PurchaseOrderCreateNestedManyWithoutCreatorInput = {
    create?: XOR<PurchaseOrderCreateWithoutCreatorInput, PurchaseOrderUncheckedCreateWithoutCreatorInput> | PurchaseOrderCreateWithoutCreatorInput[] | PurchaseOrderUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutCreatorInput | PurchaseOrderCreateOrConnectWithoutCreatorInput[]
    createMany?: PurchaseOrderCreateManyCreatorInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type GRNCreateNestedManyWithoutReceiverInput = {
    create?: XOR<GRNCreateWithoutReceiverInput, GRNUncheckedCreateWithoutReceiverInput> | GRNCreateWithoutReceiverInput[] | GRNUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: GRNCreateOrConnectWithoutReceiverInput | GRNCreateOrConnectWithoutReceiverInput[]
    createMany?: GRNCreateManyReceiverInputEnvelope
    connect?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
  }

  export type ProjectUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
  }

  export type ProjectFileUncheckedCreateNestedManyWithoutUploaderInput = {
    create?: XOR<ProjectFileCreateWithoutUploaderInput, ProjectFileUncheckedCreateWithoutUploaderInput> | ProjectFileCreateWithoutUploaderInput[] | ProjectFileUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: ProjectFileCreateOrConnectWithoutUploaderInput | ProjectFileCreateOrConnectWithoutUploaderInput[]
    createMany?: ProjectFileCreateManyUploaderInputEnvelope
    connect?: ProjectFileWhereUniqueInput | ProjectFileWhereUniqueInput[]
  }

  export type ProjectUpdateUncheckedCreateNestedManyWithoutAuthorInput = {
    create?: XOR<ProjectUpdateCreateWithoutAuthorInput, ProjectUpdateUncheckedCreateWithoutAuthorInput> | ProjectUpdateCreateWithoutAuthorInput[] | ProjectUpdateUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ProjectUpdateCreateOrConnectWithoutAuthorInput | ProjectUpdateCreateOrConnectWithoutAuthorInput[]
    createMany?: ProjectUpdateCreateManyAuthorInputEnvelope
    connect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
  }

  export type SupportRequestUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<SupportRequestCreateWithoutClientInput, SupportRequestUncheckedCreateWithoutClientInput> | SupportRequestCreateWithoutClientInput[] | SupportRequestUncheckedCreateWithoutClientInput[]
    connectOrCreate?: SupportRequestCreateOrConnectWithoutClientInput | SupportRequestCreateOrConnectWithoutClientInput[]
    createMany?: SupportRequestCreateManyClientInputEnvelope
    connect?: SupportRequestWhereUniqueInput | SupportRequestWhereUniqueInput[]
  }

  export type SupportMessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<SupportMessageCreateWithoutSenderInput, SupportMessageUncheckedCreateWithoutSenderInput> | SupportMessageCreateWithoutSenderInput[] | SupportMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: SupportMessageCreateOrConnectWithoutSenderInput | SupportMessageCreateOrConnectWithoutSenderInput[]
    createMany?: SupportMessageCreateManySenderInputEnvelope
    connect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
  }

  export type MeetingRequestUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<MeetingRequestCreateWithoutClientInput, MeetingRequestUncheckedCreateWithoutClientInput> | MeetingRequestCreateWithoutClientInput[] | MeetingRequestUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MeetingRequestCreateOrConnectWithoutClientInput | MeetingRequestCreateOrConnectWithoutClientInput[]
    createMany?: MeetingRequestCreateManyClientInputEnvelope
    connect?: MeetingRequestWhereUniqueInput | MeetingRequestWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutClientInput = {
    create?: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput> | InvoiceCreateWithoutClientInput[] | InvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClientInput | InvoiceCreateOrConnectWithoutClientInput[]
    createMany?: InvoiceCreateManyClientInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type TransactionUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<TransactionCreateWithoutCreatorInput, TransactionUncheckedCreateWithoutCreatorInput> | TransactionCreateWithoutCreatorInput[] | TransactionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCreatorInput | TransactionCreateOrConnectWithoutCreatorInput[]
    createMany?: TransactionCreateManyCreatorInputEnvelope
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
  }

  export type InventoryTransactionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<InventoryTransactionCreateWithoutUserInput, InventoryTransactionUncheckedCreateWithoutUserInput> | InventoryTransactionCreateWithoutUserInput[] | InventoryTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutUserInput | InventoryTransactionCreateOrConnectWithoutUserInput[]
    createMany?: InventoryTransactionCreateManyUserInputEnvelope
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
  }

  export type PurchaseRequestUncheckedCreateNestedManyWithoutRequesterInput = {
    create?: XOR<PurchaseRequestCreateWithoutRequesterInput, PurchaseRequestUncheckedCreateWithoutRequesterInput> | PurchaseRequestCreateWithoutRequesterInput[] | PurchaseRequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: PurchaseRequestCreateOrConnectWithoutRequesterInput | PurchaseRequestCreateOrConnectWithoutRequesterInput[]
    createMany?: PurchaseRequestCreateManyRequesterInputEnvelope
    connect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<PurchaseOrderCreateWithoutCreatorInput, PurchaseOrderUncheckedCreateWithoutCreatorInput> | PurchaseOrderCreateWithoutCreatorInput[] | PurchaseOrderUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutCreatorInput | PurchaseOrderCreateOrConnectWithoutCreatorInput[]
    createMany?: PurchaseOrderCreateManyCreatorInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type GRNUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<GRNCreateWithoutReceiverInput, GRNUncheckedCreateWithoutReceiverInput> | GRNCreateWithoutReceiverInput[] | GRNUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: GRNCreateOrConnectWithoutReceiverInput | GRNCreateOrConnectWithoutReceiverInput[]
    createMany?: GRNCreateManyReceiverInputEnvelope
    connect?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type EnumUserRoleFieldUpdateOperationsInput = {
    set?: $Enums.UserRole
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type ProjectUpdateManyWithoutClientNestedInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutClientInput | ProjectUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutClientInput | ProjectUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutClientInput | ProjectUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectFileUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<ProjectFileCreateWithoutUploaderInput, ProjectFileUncheckedCreateWithoutUploaderInput> | ProjectFileCreateWithoutUploaderInput[] | ProjectFileUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: ProjectFileCreateOrConnectWithoutUploaderInput | ProjectFileCreateOrConnectWithoutUploaderInput[]
    upsert?: ProjectFileUpsertWithWhereUniqueWithoutUploaderInput | ProjectFileUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: ProjectFileCreateManyUploaderInputEnvelope
    set?: ProjectFileWhereUniqueInput | ProjectFileWhereUniqueInput[]
    disconnect?: ProjectFileWhereUniqueInput | ProjectFileWhereUniqueInput[]
    delete?: ProjectFileWhereUniqueInput | ProjectFileWhereUniqueInput[]
    connect?: ProjectFileWhereUniqueInput | ProjectFileWhereUniqueInput[]
    update?: ProjectFileUpdateWithWhereUniqueWithoutUploaderInput | ProjectFileUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: ProjectFileUpdateManyWithWhereWithoutUploaderInput | ProjectFileUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: ProjectFileScalarWhereInput | ProjectFileScalarWhereInput[]
  }

  export type ProjectUpdateUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ProjectUpdateCreateWithoutAuthorInput, ProjectUpdateUncheckedCreateWithoutAuthorInput> | ProjectUpdateCreateWithoutAuthorInput[] | ProjectUpdateUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ProjectUpdateCreateOrConnectWithoutAuthorInput | ProjectUpdateCreateOrConnectWithoutAuthorInput[]
    upsert?: ProjectUpdateUpsertWithWhereUniqueWithoutAuthorInput | ProjectUpdateUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ProjectUpdateCreateManyAuthorInputEnvelope
    set?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    disconnect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    delete?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    connect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    update?: ProjectUpdateUpdateWithWhereUniqueWithoutAuthorInput | ProjectUpdateUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ProjectUpdateUpdateManyWithWhereWithoutAuthorInput | ProjectUpdateUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ProjectUpdateScalarWhereInput | ProjectUpdateScalarWhereInput[]
  }

  export type SupportRequestUpdateManyWithoutClientNestedInput = {
    create?: XOR<SupportRequestCreateWithoutClientInput, SupportRequestUncheckedCreateWithoutClientInput> | SupportRequestCreateWithoutClientInput[] | SupportRequestUncheckedCreateWithoutClientInput[]
    connectOrCreate?: SupportRequestCreateOrConnectWithoutClientInput | SupportRequestCreateOrConnectWithoutClientInput[]
    upsert?: SupportRequestUpsertWithWhereUniqueWithoutClientInput | SupportRequestUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: SupportRequestCreateManyClientInputEnvelope
    set?: SupportRequestWhereUniqueInput | SupportRequestWhereUniqueInput[]
    disconnect?: SupportRequestWhereUniqueInput | SupportRequestWhereUniqueInput[]
    delete?: SupportRequestWhereUniqueInput | SupportRequestWhereUniqueInput[]
    connect?: SupportRequestWhereUniqueInput | SupportRequestWhereUniqueInput[]
    update?: SupportRequestUpdateWithWhereUniqueWithoutClientInput | SupportRequestUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: SupportRequestUpdateManyWithWhereWithoutClientInput | SupportRequestUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: SupportRequestScalarWhereInput | SupportRequestScalarWhereInput[]
  }

  export type SupportMessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<SupportMessageCreateWithoutSenderInput, SupportMessageUncheckedCreateWithoutSenderInput> | SupportMessageCreateWithoutSenderInput[] | SupportMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: SupportMessageCreateOrConnectWithoutSenderInput | SupportMessageCreateOrConnectWithoutSenderInput[]
    upsert?: SupportMessageUpsertWithWhereUniqueWithoutSenderInput | SupportMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: SupportMessageCreateManySenderInputEnvelope
    set?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    disconnect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    delete?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    connect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    update?: SupportMessageUpdateWithWhereUniqueWithoutSenderInput | SupportMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: SupportMessageUpdateManyWithWhereWithoutSenderInput | SupportMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: SupportMessageScalarWhereInput | SupportMessageScalarWhereInput[]
  }

  export type MeetingRequestUpdateManyWithoutClientNestedInput = {
    create?: XOR<MeetingRequestCreateWithoutClientInput, MeetingRequestUncheckedCreateWithoutClientInput> | MeetingRequestCreateWithoutClientInput[] | MeetingRequestUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MeetingRequestCreateOrConnectWithoutClientInput | MeetingRequestCreateOrConnectWithoutClientInput[]
    upsert?: MeetingRequestUpsertWithWhereUniqueWithoutClientInput | MeetingRequestUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: MeetingRequestCreateManyClientInputEnvelope
    set?: MeetingRequestWhereUniqueInput | MeetingRequestWhereUniqueInput[]
    disconnect?: MeetingRequestWhereUniqueInput | MeetingRequestWhereUniqueInput[]
    delete?: MeetingRequestWhereUniqueInput | MeetingRequestWhereUniqueInput[]
    connect?: MeetingRequestWhereUniqueInput | MeetingRequestWhereUniqueInput[]
    update?: MeetingRequestUpdateWithWhereUniqueWithoutClientInput | MeetingRequestUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: MeetingRequestUpdateManyWithWhereWithoutClientInput | MeetingRequestUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: MeetingRequestScalarWhereInput | MeetingRequestScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutClientNestedInput = {
    create?: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput> | InvoiceCreateWithoutClientInput[] | InvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClientInput | InvoiceCreateOrConnectWithoutClientInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutClientInput | InvoiceUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: InvoiceCreateManyClientInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutClientInput | InvoiceUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutClientInput | InvoiceUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type TransactionUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TransactionCreateWithoutCreatorInput, TransactionUncheckedCreateWithoutCreatorInput> | TransactionCreateWithoutCreatorInput[] | TransactionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCreatorInput | TransactionCreateOrConnectWithoutCreatorInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCreatorInput | TransactionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TransactionCreateManyCreatorInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCreatorInput | TransactionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCreatorInput | TransactionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type InventoryTransactionUpdateManyWithoutUserNestedInput = {
    create?: XOR<InventoryTransactionCreateWithoutUserInput, InventoryTransactionUncheckedCreateWithoutUserInput> | InventoryTransactionCreateWithoutUserInput[] | InventoryTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutUserInput | InventoryTransactionCreateOrConnectWithoutUserInput[]
    upsert?: InventoryTransactionUpsertWithWhereUniqueWithoutUserInput | InventoryTransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InventoryTransactionCreateManyUserInputEnvelope
    set?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    disconnect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    delete?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    update?: InventoryTransactionUpdateWithWhereUniqueWithoutUserInput | InventoryTransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InventoryTransactionUpdateManyWithWhereWithoutUserInput | InventoryTransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
  }

  export type PurchaseRequestUpdateManyWithoutRequesterNestedInput = {
    create?: XOR<PurchaseRequestCreateWithoutRequesterInput, PurchaseRequestUncheckedCreateWithoutRequesterInput> | PurchaseRequestCreateWithoutRequesterInput[] | PurchaseRequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: PurchaseRequestCreateOrConnectWithoutRequesterInput | PurchaseRequestCreateOrConnectWithoutRequesterInput[]
    upsert?: PurchaseRequestUpsertWithWhereUniqueWithoutRequesterInput | PurchaseRequestUpsertWithWhereUniqueWithoutRequesterInput[]
    createMany?: PurchaseRequestCreateManyRequesterInputEnvelope
    set?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    disconnect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    delete?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    connect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    update?: PurchaseRequestUpdateWithWhereUniqueWithoutRequesterInput | PurchaseRequestUpdateWithWhereUniqueWithoutRequesterInput[]
    updateMany?: PurchaseRequestUpdateManyWithWhereWithoutRequesterInput | PurchaseRequestUpdateManyWithWhereWithoutRequesterInput[]
    deleteMany?: PurchaseRequestScalarWhereInput | PurchaseRequestScalarWhereInput[]
  }

  export type PurchaseOrderUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutCreatorInput, PurchaseOrderUncheckedCreateWithoutCreatorInput> | PurchaseOrderCreateWithoutCreatorInput[] | PurchaseOrderUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutCreatorInput | PurchaseOrderCreateOrConnectWithoutCreatorInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutCreatorInput | PurchaseOrderUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: PurchaseOrderCreateManyCreatorInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutCreatorInput | PurchaseOrderUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutCreatorInput | PurchaseOrderUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type GRNUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<GRNCreateWithoutReceiverInput, GRNUncheckedCreateWithoutReceiverInput> | GRNCreateWithoutReceiverInput[] | GRNUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: GRNCreateOrConnectWithoutReceiverInput | GRNCreateOrConnectWithoutReceiverInput[]
    upsert?: GRNUpsertWithWhereUniqueWithoutReceiverInput | GRNUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: GRNCreateManyReceiverInputEnvelope
    set?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
    disconnect?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
    delete?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
    connect?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
    update?: GRNUpdateWithWhereUniqueWithoutReceiverInput | GRNUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: GRNUpdateManyWithWhereWithoutReceiverInput | GRNUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: GRNScalarWhereInput | GRNScalarWhereInput[]
  }

  export type ProjectUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput> | ProjectCreateWithoutClientInput[] | ProjectUncheckedCreateWithoutClientInput[]
    connectOrCreate?: ProjectCreateOrConnectWithoutClientInput | ProjectCreateOrConnectWithoutClientInput[]
    upsert?: ProjectUpsertWithWhereUniqueWithoutClientInput | ProjectUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: ProjectCreateManyClientInputEnvelope
    set?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    disconnect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    delete?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    connect?: ProjectWhereUniqueInput | ProjectWhereUniqueInput[]
    update?: ProjectUpdateWithWhereUniqueWithoutClientInput | ProjectUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: ProjectUpdateManyWithWhereWithoutClientInput | ProjectUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
  }

  export type ProjectFileUncheckedUpdateManyWithoutUploaderNestedInput = {
    create?: XOR<ProjectFileCreateWithoutUploaderInput, ProjectFileUncheckedCreateWithoutUploaderInput> | ProjectFileCreateWithoutUploaderInput[] | ProjectFileUncheckedCreateWithoutUploaderInput[]
    connectOrCreate?: ProjectFileCreateOrConnectWithoutUploaderInput | ProjectFileCreateOrConnectWithoutUploaderInput[]
    upsert?: ProjectFileUpsertWithWhereUniqueWithoutUploaderInput | ProjectFileUpsertWithWhereUniqueWithoutUploaderInput[]
    createMany?: ProjectFileCreateManyUploaderInputEnvelope
    set?: ProjectFileWhereUniqueInput | ProjectFileWhereUniqueInput[]
    disconnect?: ProjectFileWhereUniqueInput | ProjectFileWhereUniqueInput[]
    delete?: ProjectFileWhereUniqueInput | ProjectFileWhereUniqueInput[]
    connect?: ProjectFileWhereUniqueInput | ProjectFileWhereUniqueInput[]
    update?: ProjectFileUpdateWithWhereUniqueWithoutUploaderInput | ProjectFileUpdateWithWhereUniqueWithoutUploaderInput[]
    updateMany?: ProjectFileUpdateManyWithWhereWithoutUploaderInput | ProjectFileUpdateManyWithWhereWithoutUploaderInput[]
    deleteMany?: ProjectFileScalarWhereInput | ProjectFileScalarWhereInput[]
  }

  export type ProjectUpdateUncheckedUpdateManyWithoutAuthorNestedInput = {
    create?: XOR<ProjectUpdateCreateWithoutAuthorInput, ProjectUpdateUncheckedCreateWithoutAuthorInput> | ProjectUpdateCreateWithoutAuthorInput[] | ProjectUpdateUncheckedCreateWithoutAuthorInput[]
    connectOrCreate?: ProjectUpdateCreateOrConnectWithoutAuthorInput | ProjectUpdateCreateOrConnectWithoutAuthorInput[]
    upsert?: ProjectUpdateUpsertWithWhereUniqueWithoutAuthorInput | ProjectUpdateUpsertWithWhereUniqueWithoutAuthorInput[]
    createMany?: ProjectUpdateCreateManyAuthorInputEnvelope
    set?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    disconnect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    delete?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    connect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    update?: ProjectUpdateUpdateWithWhereUniqueWithoutAuthorInput | ProjectUpdateUpdateWithWhereUniqueWithoutAuthorInput[]
    updateMany?: ProjectUpdateUpdateManyWithWhereWithoutAuthorInput | ProjectUpdateUpdateManyWithWhereWithoutAuthorInput[]
    deleteMany?: ProjectUpdateScalarWhereInput | ProjectUpdateScalarWhereInput[]
  }

  export type SupportRequestUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<SupportRequestCreateWithoutClientInput, SupportRequestUncheckedCreateWithoutClientInput> | SupportRequestCreateWithoutClientInput[] | SupportRequestUncheckedCreateWithoutClientInput[]
    connectOrCreate?: SupportRequestCreateOrConnectWithoutClientInput | SupportRequestCreateOrConnectWithoutClientInput[]
    upsert?: SupportRequestUpsertWithWhereUniqueWithoutClientInput | SupportRequestUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: SupportRequestCreateManyClientInputEnvelope
    set?: SupportRequestWhereUniqueInput | SupportRequestWhereUniqueInput[]
    disconnect?: SupportRequestWhereUniqueInput | SupportRequestWhereUniqueInput[]
    delete?: SupportRequestWhereUniqueInput | SupportRequestWhereUniqueInput[]
    connect?: SupportRequestWhereUniqueInput | SupportRequestWhereUniqueInput[]
    update?: SupportRequestUpdateWithWhereUniqueWithoutClientInput | SupportRequestUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: SupportRequestUpdateManyWithWhereWithoutClientInput | SupportRequestUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: SupportRequestScalarWhereInput | SupportRequestScalarWhereInput[]
  }

  export type SupportMessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<SupportMessageCreateWithoutSenderInput, SupportMessageUncheckedCreateWithoutSenderInput> | SupportMessageCreateWithoutSenderInput[] | SupportMessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: SupportMessageCreateOrConnectWithoutSenderInput | SupportMessageCreateOrConnectWithoutSenderInput[]
    upsert?: SupportMessageUpsertWithWhereUniqueWithoutSenderInput | SupportMessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: SupportMessageCreateManySenderInputEnvelope
    set?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    disconnect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    delete?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    connect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    update?: SupportMessageUpdateWithWhereUniqueWithoutSenderInput | SupportMessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: SupportMessageUpdateManyWithWhereWithoutSenderInput | SupportMessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: SupportMessageScalarWhereInput | SupportMessageScalarWhereInput[]
  }

  export type MeetingRequestUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<MeetingRequestCreateWithoutClientInput, MeetingRequestUncheckedCreateWithoutClientInput> | MeetingRequestCreateWithoutClientInput[] | MeetingRequestUncheckedCreateWithoutClientInput[]
    connectOrCreate?: MeetingRequestCreateOrConnectWithoutClientInput | MeetingRequestCreateOrConnectWithoutClientInput[]
    upsert?: MeetingRequestUpsertWithWhereUniqueWithoutClientInput | MeetingRequestUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: MeetingRequestCreateManyClientInputEnvelope
    set?: MeetingRequestWhereUniqueInput | MeetingRequestWhereUniqueInput[]
    disconnect?: MeetingRequestWhereUniqueInput | MeetingRequestWhereUniqueInput[]
    delete?: MeetingRequestWhereUniqueInput | MeetingRequestWhereUniqueInput[]
    connect?: MeetingRequestWhereUniqueInput | MeetingRequestWhereUniqueInput[]
    update?: MeetingRequestUpdateWithWhereUniqueWithoutClientInput | MeetingRequestUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: MeetingRequestUpdateManyWithWhereWithoutClientInput | MeetingRequestUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: MeetingRequestScalarWhereInput | MeetingRequestScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutClientNestedInput = {
    create?: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput> | InvoiceCreateWithoutClientInput[] | InvoiceUncheckedCreateWithoutClientInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutClientInput | InvoiceCreateOrConnectWithoutClientInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutClientInput | InvoiceUpsertWithWhereUniqueWithoutClientInput[]
    createMany?: InvoiceCreateManyClientInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutClientInput | InvoiceUpdateWithWhereUniqueWithoutClientInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutClientInput | InvoiceUpdateManyWithWhereWithoutClientInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type TransactionUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<TransactionCreateWithoutCreatorInput, TransactionUncheckedCreateWithoutCreatorInput> | TransactionCreateWithoutCreatorInput[] | TransactionUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: TransactionCreateOrConnectWithoutCreatorInput | TransactionCreateOrConnectWithoutCreatorInput[]
    upsert?: TransactionUpsertWithWhereUniqueWithoutCreatorInput | TransactionUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: TransactionCreateManyCreatorInputEnvelope
    set?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    disconnect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    delete?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    connect?: TransactionWhereUniqueInput | TransactionWhereUniqueInput[]
    update?: TransactionUpdateWithWhereUniqueWithoutCreatorInput | TransactionUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: TransactionUpdateManyWithWhereWithoutCreatorInput | TransactionUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
  }

  export type InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<InventoryTransactionCreateWithoutUserInput, InventoryTransactionUncheckedCreateWithoutUserInput> | InventoryTransactionCreateWithoutUserInput[] | InventoryTransactionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutUserInput | InventoryTransactionCreateOrConnectWithoutUserInput[]
    upsert?: InventoryTransactionUpsertWithWhereUniqueWithoutUserInput | InventoryTransactionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: InventoryTransactionCreateManyUserInputEnvelope
    set?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    disconnect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    delete?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    update?: InventoryTransactionUpdateWithWhereUniqueWithoutUserInput | InventoryTransactionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: InventoryTransactionUpdateManyWithWhereWithoutUserInput | InventoryTransactionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
  }

  export type PurchaseRequestUncheckedUpdateManyWithoutRequesterNestedInput = {
    create?: XOR<PurchaseRequestCreateWithoutRequesterInput, PurchaseRequestUncheckedCreateWithoutRequesterInput> | PurchaseRequestCreateWithoutRequesterInput[] | PurchaseRequestUncheckedCreateWithoutRequesterInput[]
    connectOrCreate?: PurchaseRequestCreateOrConnectWithoutRequesterInput | PurchaseRequestCreateOrConnectWithoutRequesterInput[]
    upsert?: PurchaseRequestUpsertWithWhereUniqueWithoutRequesterInput | PurchaseRequestUpsertWithWhereUniqueWithoutRequesterInput[]
    createMany?: PurchaseRequestCreateManyRequesterInputEnvelope
    set?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    disconnect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    delete?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    connect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    update?: PurchaseRequestUpdateWithWhereUniqueWithoutRequesterInput | PurchaseRequestUpdateWithWhereUniqueWithoutRequesterInput[]
    updateMany?: PurchaseRequestUpdateManyWithWhereWithoutRequesterInput | PurchaseRequestUpdateManyWithWhereWithoutRequesterInput[]
    deleteMany?: PurchaseRequestScalarWhereInput | PurchaseRequestScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutCreatorInput, PurchaseOrderUncheckedCreateWithoutCreatorInput> | PurchaseOrderCreateWithoutCreatorInput[] | PurchaseOrderUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutCreatorInput | PurchaseOrderCreateOrConnectWithoutCreatorInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutCreatorInput | PurchaseOrderUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: PurchaseOrderCreateManyCreatorInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutCreatorInput | PurchaseOrderUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutCreatorInput | PurchaseOrderUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type GRNUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<GRNCreateWithoutReceiverInput, GRNUncheckedCreateWithoutReceiverInput> | GRNCreateWithoutReceiverInput[] | GRNUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: GRNCreateOrConnectWithoutReceiverInput | GRNCreateOrConnectWithoutReceiverInput[]
    upsert?: GRNUpsertWithWhereUniqueWithoutReceiverInput | GRNUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: GRNCreateManyReceiverInputEnvelope
    set?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
    disconnect?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
    delete?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
    connect?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
    update?: GRNUpdateWithWhereUniqueWithoutReceiverInput | GRNUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: GRNUpdateManyWithWhereWithoutReceiverInput | GRNUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: GRNScalarWhereInput | GRNScalarWhereInput[]
  }

  export type ProjectCreatenotesInput = {
    set: string[]
  }

  export type UserCreateNestedOneWithoutProjectsInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectFileCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectFileCreateWithoutProjectInput, ProjectFileUncheckedCreateWithoutProjectInput> | ProjectFileCreateWithoutProjectInput[] | ProjectFileUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectFileCreateOrConnectWithoutProjectInput | ProjectFileCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectFileCreateManyProjectInputEnvelope
    connect?: ProjectFileWhereUniqueInput | ProjectFileWhereUniqueInput[]
  }

  export type ProjectUpdateCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectUpdateCreateWithoutProjectInput, ProjectUpdateUncheckedCreateWithoutProjectInput> | ProjectUpdateCreateWithoutProjectInput[] | ProjectUpdateUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectUpdateCreateOrConnectWithoutProjectInput | ProjectUpdateCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectUpdateCreateManyProjectInputEnvelope
    connect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
  }

  export type SupportRequestCreateNestedManyWithoutProjectInput = {
    create?: XOR<SupportRequestCreateWithoutProjectInput, SupportRequestUncheckedCreateWithoutProjectInput> | SupportRequestCreateWithoutProjectInput[] | SupportRequestUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SupportRequestCreateOrConnectWithoutProjectInput | SupportRequestCreateOrConnectWithoutProjectInput[]
    createMany?: SupportRequestCreateManyProjectInputEnvelope
    connect?: SupportRequestWhereUniqueInput | SupportRequestWhereUniqueInput[]
  }

  export type MeetingRequestCreateNestedManyWithoutProjectInput = {
    create?: XOR<MeetingRequestCreateWithoutProjectInput, MeetingRequestUncheckedCreateWithoutProjectInput> | MeetingRequestCreateWithoutProjectInput[] | MeetingRequestUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MeetingRequestCreateOrConnectWithoutProjectInput | MeetingRequestCreateOrConnectWithoutProjectInput[]
    createMany?: MeetingRequestCreateManyProjectInputEnvelope
    connect?: MeetingRequestWhereUniqueInput | MeetingRequestWhereUniqueInput[]
  }

  export type InvoiceCreateNestedManyWithoutProjectInput = {
    create?: XOR<InvoiceCreateWithoutProjectInput, InvoiceUncheckedCreateWithoutProjectInput> | InvoiceCreateWithoutProjectInput[] | InvoiceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutProjectInput | InvoiceCreateOrConnectWithoutProjectInput[]
    createMany?: InvoiceCreateManyProjectInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type InventoryTransactionCreateNestedManyWithoutProjectInput = {
    create?: XOR<InventoryTransactionCreateWithoutProjectInput, InventoryTransactionUncheckedCreateWithoutProjectInput> | InventoryTransactionCreateWithoutProjectInput[] | InventoryTransactionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutProjectInput | InventoryTransactionCreateOrConnectWithoutProjectInput[]
    createMany?: InventoryTransactionCreateManyProjectInputEnvelope
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
  }

  export type PurchaseRequestCreateNestedManyWithoutProjectInput = {
    create?: XOR<PurchaseRequestCreateWithoutProjectInput, PurchaseRequestUncheckedCreateWithoutProjectInput> | PurchaseRequestCreateWithoutProjectInput[] | PurchaseRequestUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PurchaseRequestCreateOrConnectWithoutProjectInput | PurchaseRequestCreateOrConnectWithoutProjectInput[]
    createMany?: PurchaseRequestCreateManyProjectInputEnvelope
    connect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutProjectInput = {
    create?: XOR<AttendanceCreateWithoutProjectInput, AttendanceUncheckedCreateWithoutProjectInput> | AttendanceCreateWithoutProjectInput[] | AttendanceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutProjectInput | AttendanceCreateOrConnectWithoutProjectInput[]
    createMany?: AttendanceCreateManyProjectInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type LabourAllocationCreateNestedManyWithoutProjectInput = {
    create?: XOR<LabourAllocationCreateWithoutProjectInput, LabourAllocationUncheckedCreateWithoutProjectInput> | LabourAllocationCreateWithoutProjectInput[] | LabourAllocationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LabourAllocationCreateOrConnectWithoutProjectInput | LabourAllocationCreateOrConnectWithoutProjectInput[]
    createMany?: LabourAllocationCreateManyProjectInputEnvelope
    connect?: LabourAllocationWhereUniqueInput | LabourAllocationWhereUniqueInput[]
  }

  export type ProjectFileUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectFileCreateWithoutProjectInput, ProjectFileUncheckedCreateWithoutProjectInput> | ProjectFileCreateWithoutProjectInput[] | ProjectFileUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectFileCreateOrConnectWithoutProjectInput | ProjectFileCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectFileCreateManyProjectInputEnvelope
    connect?: ProjectFileWhereUniqueInput | ProjectFileWhereUniqueInput[]
  }

  export type ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<ProjectUpdateCreateWithoutProjectInput, ProjectUpdateUncheckedCreateWithoutProjectInput> | ProjectUpdateCreateWithoutProjectInput[] | ProjectUpdateUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectUpdateCreateOrConnectWithoutProjectInput | ProjectUpdateCreateOrConnectWithoutProjectInput[]
    createMany?: ProjectUpdateCreateManyProjectInputEnvelope
    connect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
  }

  export type SupportRequestUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<SupportRequestCreateWithoutProjectInput, SupportRequestUncheckedCreateWithoutProjectInput> | SupportRequestCreateWithoutProjectInput[] | SupportRequestUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SupportRequestCreateOrConnectWithoutProjectInput | SupportRequestCreateOrConnectWithoutProjectInput[]
    createMany?: SupportRequestCreateManyProjectInputEnvelope
    connect?: SupportRequestWhereUniqueInput | SupportRequestWhereUniqueInput[]
  }

  export type MeetingRequestUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<MeetingRequestCreateWithoutProjectInput, MeetingRequestUncheckedCreateWithoutProjectInput> | MeetingRequestCreateWithoutProjectInput[] | MeetingRequestUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MeetingRequestCreateOrConnectWithoutProjectInput | MeetingRequestCreateOrConnectWithoutProjectInput[]
    createMany?: MeetingRequestCreateManyProjectInputEnvelope
    connect?: MeetingRequestWhereUniqueInput | MeetingRequestWhereUniqueInput[]
  }

  export type InvoiceUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<InvoiceCreateWithoutProjectInput, InvoiceUncheckedCreateWithoutProjectInput> | InvoiceCreateWithoutProjectInput[] | InvoiceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutProjectInput | InvoiceCreateOrConnectWithoutProjectInput[]
    createMany?: InvoiceCreateManyProjectInputEnvelope
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
  }

  export type InventoryTransactionUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<InventoryTransactionCreateWithoutProjectInput, InventoryTransactionUncheckedCreateWithoutProjectInput> | InventoryTransactionCreateWithoutProjectInput[] | InventoryTransactionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutProjectInput | InventoryTransactionCreateOrConnectWithoutProjectInput[]
    createMany?: InventoryTransactionCreateManyProjectInputEnvelope
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
  }

  export type PurchaseRequestUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<PurchaseRequestCreateWithoutProjectInput, PurchaseRequestUncheckedCreateWithoutProjectInput> | PurchaseRequestCreateWithoutProjectInput[] | PurchaseRequestUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PurchaseRequestCreateOrConnectWithoutProjectInput | PurchaseRequestCreateOrConnectWithoutProjectInput[]
    createMany?: PurchaseRequestCreateManyProjectInputEnvelope
    connect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<AttendanceCreateWithoutProjectInput, AttendanceUncheckedCreateWithoutProjectInput> | AttendanceCreateWithoutProjectInput[] | AttendanceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutProjectInput | AttendanceCreateOrConnectWithoutProjectInput[]
    createMany?: AttendanceCreateManyProjectInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type LabourAllocationUncheckedCreateNestedManyWithoutProjectInput = {
    create?: XOR<LabourAllocationCreateWithoutProjectInput, LabourAllocationUncheckedCreateWithoutProjectInput> | LabourAllocationCreateWithoutProjectInput[] | LabourAllocationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LabourAllocationCreateOrConnectWithoutProjectInput | LabourAllocationCreateOrConnectWithoutProjectInput[]
    createMany?: LabourAllocationCreateManyProjectInputEnvelope
    connect?: LabourAllocationWhereUniqueInput | LabourAllocationWhereUniqueInput[]
  }

  export type EnumProjectStatusFieldUpdateOperationsInput = {
    set?: $Enums.ProjectStatus
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type ProjectUpdatenotesInput = {
    set?: string[]
    push?: string | string[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type UserUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: UserCreateOrConnectWithoutProjectsInput
    upsert?: UserUpsertWithoutProjectsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProjectsInput, UserUpdateWithoutProjectsInput>, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type ProjectFileUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectFileCreateWithoutProjectInput, ProjectFileUncheckedCreateWithoutProjectInput> | ProjectFileCreateWithoutProjectInput[] | ProjectFileUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectFileCreateOrConnectWithoutProjectInput | ProjectFileCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectFileUpsertWithWhereUniqueWithoutProjectInput | ProjectFileUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectFileCreateManyProjectInputEnvelope
    set?: ProjectFileWhereUniqueInput | ProjectFileWhereUniqueInput[]
    disconnect?: ProjectFileWhereUniqueInput | ProjectFileWhereUniqueInput[]
    delete?: ProjectFileWhereUniqueInput | ProjectFileWhereUniqueInput[]
    connect?: ProjectFileWhereUniqueInput | ProjectFileWhereUniqueInput[]
    update?: ProjectFileUpdateWithWhereUniqueWithoutProjectInput | ProjectFileUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectFileUpdateManyWithWhereWithoutProjectInput | ProjectFileUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectFileScalarWhereInput | ProjectFileScalarWhereInput[]
  }

  export type ProjectUpdateUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectUpdateCreateWithoutProjectInput, ProjectUpdateUncheckedCreateWithoutProjectInput> | ProjectUpdateCreateWithoutProjectInput[] | ProjectUpdateUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectUpdateCreateOrConnectWithoutProjectInput | ProjectUpdateCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectUpdateUpsertWithWhereUniqueWithoutProjectInput | ProjectUpdateUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectUpdateCreateManyProjectInputEnvelope
    set?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    disconnect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    delete?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    connect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    update?: ProjectUpdateUpdateWithWhereUniqueWithoutProjectInput | ProjectUpdateUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectUpdateUpdateManyWithWhereWithoutProjectInput | ProjectUpdateUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectUpdateScalarWhereInput | ProjectUpdateScalarWhereInput[]
  }

  export type SupportRequestUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SupportRequestCreateWithoutProjectInput, SupportRequestUncheckedCreateWithoutProjectInput> | SupportRequestCreateWithoutProjectInput[] | SupportRequestUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SupportRequestCreateOrConnectWithoutProjectInput | SupportRequestCreateOrConnectWithoutProjectInput[]
    upsert?: SupportRequestUpsertWithWhereUniqueWithoutProjectInput | SupportRequestUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SupportRequestCreateManyProjectInputEnvelope
    set?: SupportRequestWhereUniqueInput | SupportRequestWhereUniqueInput[]
    disconnect?: SupportRequestWhereUniqueInput | SupportRequestWhereUniqueInput[]
    delete?: SupportRequestWhereUniqueInput | SupportRequestWhereUniqueInput[]
    connect?: SupportRequestWhereUniqueInput | SupportRequestWhereUniqueInput[]
    update?: SupportRequestUpdateWithWhereUniqueWithoutProjectInput | SupportRequestUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SupportRequestUpdateManyWithWhereWithoutProjectInput | SupportRequestUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SupportRequestScalarWhereInput | SupportRequestScalarWhereInput[]
  }

  export type MeetingRequestUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MeetingRequestCreateWithoutProjectInput, MeetingRequestUncheckedCreateWithoutProjectInput> | MeetingRequestCreateWithoutProjectInput[] | MeetingRequestUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MeetingRequestCreateOrConnectWithoutProjectInput | MeetingRequestCreateOrConnectWithoutProjectInput[]
    upsert?: MeetingRequestUpsertWithWhereUniqueWithoutProjectInput | MeetingRequestUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MeetingRequestCreateManyProjectInputEnvelope
    set?: MeetingRequestWhereUniqueInput | MeetingRequestWhereUniqueInput[]
    disconnect?: MeetingRequestWhereUniqueInput | MeetingRequestWhereUniqueInput[]
    delete?: MeetingRequestWhereUniqueInput | MeetingRequestWhereUniqueInput[]
    connect?: MeetingRequestWhereUniqueInput | MeetingRequestWhereUniqueInput[]
    update?: MeetingRequestUpdateWithWhereUniqueWithoutProjectInput | MeetingRequestUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MeetingRequestUpdateManyWithWhereWithoutProjectInput | MeetingRequestUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MeetingRequestScalarWhereInput | MeetingRequestScalarWhereInput[]
  }

  export type InvoiceUpdateManyWithoutProjectNestedInput = {
    create?: XOR<InvoiceCreateWithoutProjectInput, InvoiceUncheckedCreateWithoutProjectInput> | InvoiceCreateWithoutProjectInput[] | InvoiceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutProjectInput | InvoiceCreateOrConnectWithoutProjectInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutProjectInput | InvoiceUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: InvoiceCreateManyProjectInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutProjectInput | InvoiceUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutProjectInput | InvoiceUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type InventoryTransactionUpdateManyWithoutProjectNestedInput = {
    create?: XOR<InventoryTransactionCreateWithoutProjectInput, InventoryTransactionUncheckedCreateWithoutProjectInput> | InventoryTransactionCreateWithoutProjectInput[] | InventoryTransactionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutProjectInput | InventoryTransactionCreateOrConnectWithoutProjectInput[]
    upsert?: InventoryTransactionUpsertWithWhereUniqueWithoutProjectInput | InventoryTransactionUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: InventoryTransactionCreateManyProjectInputEnvelope
    set?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    disconnect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    delete?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    update?: InventoryTransactionUpdateWithWhereUniqueWithoutProjectInput | InventoryTransactionUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: InventoryTransactionUpdateManyWithWhereWithoutProjectInput | InventoryTransactionUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
  }

  export type PurchaseRequestUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PurchaseRequestCreateWithoutProjectInput, PurchaseRequestUncheckedCreateWithoutProjectInput> | PurchaseRequestCreateWithoutProjectInput[] | PurchaseRequestUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PurchaseRequestCreateOrConnectWithoutProjectInput | PurchaseRequestCreateOrConnectWithoutProjectInput[]
    upsert?: PurchaseRequestUpsertWithWhereUniqueWithoutProjectInput | PurchaseRequestUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PurchaseRequestCreateManyProjectInputEnvelope
    set?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    disconnect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    delete?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    connect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    update?: PurchaseRequestUpdateWithWhereUniqueWithoutProjectInput | PurchaseRequestUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PurchaseRequestUpdateManyWithWhereWithoutProjectInput | PurchaseRequestUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PurchaseRequestScalarWhereInput | PurchaseRequestScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutProjectNestedInput = {
    create?: XOR<AttendanceCreateWithoutProjectInput, AttendanceUncheckedCreateWithoutProjectInput> | AttendanceCreateWithoutProjectInput[] | AttendanceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutProjectInput | AttendanceCreateOrConnectWithoutProjectInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutProjectInput | AttendanceUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: AttendanceCreateManyProjectInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutProjectInput | AttendanceUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutProjectInput | AttendanceUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type LabourAllocationUpdateManyWithoutProjectNestedInput = {
    create?: XOR<LabourAllocationCreateWithoutProjectInput, LabourAllocationUncheckedCreateWithoutProjectInput> | LabourAllocationCreateWithoutProjectInput[] | LabourAllocationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LabourAllocationCreateOrConnectWithoutProjectInput | LabourAllocationCreateOrConnectWithoutProjectInput[]
    upsert?: LabourAllocationUpsertWithWhereUniqueWithoutProjectInput | LabourAllocationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: LabourAllocationCreateManyProjectInputEnvelope
    set?: LabourAllocationWhereUniqueInput | LabourAllocationWhereUniqueInput[]
    disconnect?: LabourAllocationWhereUniqueInput | LabourAllocationWhereUniqueInput[]
    delete?: LabourAllocationWhereUniqueInput | LabourAllocationWhereUniqueInput[]
    connect?: LabourAllocationWhereUniqueInput | LabourAllocationWhereUniqueInput[]
    update?: LabourAllocationUpdateWithWhereUniqueWithoutProjectInput | LabourAllocationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: LabourAllocationUpdateManyWithWhereWithoutProjectInput | LabourAllocationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: LabourAllocationScalarWhereInput | LabourAllocationScalarWhereInput[]
  }

  export type ProjectFileUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectFileCreateWithoutProjectInput, ProjectFileUncheckedCreateWithoutProjectInput> | ProjectFileCreateWithoutProjectInput[] | ProjectFileUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectFileCreateOrConnectWithoutProjectInput | ProjectFileCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectFileUpsertWithWhereUniqueWithoutProjectInput | ProjectFileUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectFileCreateManyProjectInputEnvelope
    set?: ProjectFileWhereUniqueInput | ProjectFileWhereUniqueInput[]
    disconnect?: ProjectFileWhereUniqueInput | ProjectFileWhereUniqueInput[]
    delete?: ProjectFileWhereUniqueInput | ProjectFileWhereUniqueInput[]
    connect?: ProjectFileWhereUniqueInput | ProjectFileWhereUniqueInput[]
    update?: ProjectFileUpdateWithWhereUniqueWithoutProjectInput | ProjectFileUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectFileUpdateManyWithWhereWithoutProjectInput | ProjectFileUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectFileScalarWhereInput | ProjectFileScalarWhereInput[]
  }

  export type ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<ProjectUpdateCreateWithoutProjectInput, ProjectUpdateUncheckedCreateWithoutProjectInput> | ProjectUpdateCreateWithoutProjectInput[] | ProjectUpdateUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: ProjectUpdateCreateOrConnectWithoutProjectInput | ProjectUpdateCreateOrConnectWithoutProjectInput[]
    upsert?: ProjectUpdateUpsertWithWhereUniqueWithoutProjectInput | ProjectUpdateUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: ProjectUpdateCreateManyProjectInputEnvelope
    set?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    disconnect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    delete?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    connect?: ProjectUpdateWhereUniqueInput | ProjectUpdateWhereUniqueInput[]
    update?: ProjectUpdateUpdateWithWhereUniqueWithoutProjectInput | ProjectUpdateUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: ProjectUpdateUpdateManyWithWhereWithoutProjectInput | ProjectUpdateUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: ProjectUpdateScalarWhereInput | ProjectUpdateScalarWhereInput[]
  }

  export type SupportRequestUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<SupportRequestCreateWithoutProjectInput, SupportRequestUncheckedCreateWithoutProjectInput> | SupportRequestCreateWithoutProjectInput[] | SupportRequestUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: SupportRequestCreateOrConnectWithoutProjectInput | SupportRequestCreateOrConnectWithoutProjectInput[]
    upsert?: SupportRequestUpsertWithWhereUniqueWithoutProjectInput | SupportRequestUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: SupportRequestCreateManyProjectInputEnvelope
    set?: SupportRequestWhereUniqueInput | SupportRequestWhereUniqueInput[]
    disconnect?: SupportRequestWhereUniqueInput | SupportRequestWhereUniqueInput[]
    delete?: SupportRequestWhereUniqueInput | SupportRequestWhereUniqueInput[]
    connect?: SupportRequestWhereUniqueInput | SupportRequestWhereUniqueInput[]
    update?: SupportRequestUpdateWithWhereUniqueWithoutProjectInput | SupportRequestUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: SupportRequestUpdateManyWithWhereWithoutProjectInput | SupportRequestUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: SupportRequestScalarWhereInput | SupportRequestScalarWhereInput[]
  }

  export type MeetingRequestUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<MeetingRequestCreateWithoutProjectInput, MeetingRequestUncheckedCreateWithoutProjectInput> | MeetingRequestCreateWithoutProjectInput[] | MeetingRequestUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: MeetingRequestCreateOrConnectWithoutProjectInput | MeetingRequestCreateOrConnectWithoutProjectInput[]
    upsert?: MeetingRequestUpsertWithWhereUniqueWithoutProjectInput | MeetingRequestUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: MeetingRequestCreateManyProjectInputEnvelope
    set?: MeetingRequestWhereUniqueInput | MeetingRequestWhereUniqueInput[]
    disconnect?: MeetingRequestWhereUniqueInput | MeetingRequestWhereUniqueInput[]
    delete?: MeetingRequestWhereUniqueInput | MeetingRequestWhereUniqueInput[]
    connect?: MeetingRequestWhereUniqueInput | MeetingRequestWhereUniqueInput[]
    update?: MeetingRequestUpdateWithWhereUniqueWithoutProjectInput | MeetingRequestUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: MeetingRequestUpdateManyWithWhereWithoutProjectInput | MeetingRequestUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: MeetingRequestScalarWhereInput | MeetingRequestScalarWhereInput[]
  }

  export type InvoiceUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<InvoiceCreateWithoutProjectInput, InvoiceUncheckedCreateWithoutProjectInput> | InvoiceCreateWithoutProjectInput[] | InvoiceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: InvoiceCreateOrConnectWithoutProjectInput | InvoiceCreateOrConnectWithoutProjectInput[]
    upsert?: InvoiceUpsertWithWhereUniqueWithoutProjectInput | InvoiceUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: InvoiceCreateManyProjectInputEnvelope
    set?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    disconnect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    delete?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    connect?: InvoiceWhereUniqueInput | InvoiceWhereUniqueInput[]
    update?: InvoiceUpdateWithWhereUniqueWithoutProjectInput | InvoiceUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: InvoiceUpdateManyWithWhereWithoutProjectInput | InvoiceUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
  }

  export type InventoryTransactionUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<InventoryTransactionCreateWithoutProjectInput, InventoryTransactionUncheckedCreateWithoutProjectInput> | InventoryTransactionCreateWithoutProjectInput[] | InventoryTransactionUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutProjectInput | InventoryTransactionCreateOrConnectWithoutProjectInput[]
    upsert?: InventoryTransactionUpsertWithWhereUniqueWithoutProjectInput | InventoryTransactionUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: InventoryTransactionCreateManyProjectInputEnvelope
    set?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    disconnect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    delete?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    update?: InventoryTransactionUpdateWithWhereUniqueWithoutProjectInput | InventoryTransactionUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: InventoryTransactionUpdateManyWithWhereWithoutProjectInput | InventoryTransactionUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
  }

  export type PurchaseRequestUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<PurchaseRequestCreateWithoutProjectInput, PurchaseRequestUncheckedCreateWithoutProjectInput> | PurchaseRequestCreateWithoutProjectInput[] | PurchaseRequestUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: PurchaseRequestCreateOrConnectWithoutProjectInput | PurchaseRequestCreateOrConnectWithoutProjectInput[]
    upsert?: PurchaseRequestUpsertWithWhereUniqueWithoutProjectInput | PurchaseRequestUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: PurchaseRequestCreateManyProjectInputEnvelope
    set?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    disconnect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    delete?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    connect?: PurchaseRequestWhereUniqueInput | PurchaseRequestWhereUniqueInput[]
    update?: PurchaseRequestUpdateWithWhereUniqueWithoutProjectInput | PurchaseRequestUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: PurchaseRequestUpdateManyWithWhereWithoutProjectInput | PurchaseRequestUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: PurchaseRequestScalarWhereInput | PurchaseRequestScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<AttendanceCreateWithoutProjectInput, AttendanceUncheckedCreateWithoutProjectInput> | AttendanceCreateWithoutProjectInput[] | AttendanceUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutProjectInput | AttendanceCreateOrConnectWithoutProjectInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutProjectInput | AttendanceUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: AttendanceCreateManyProjectInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutProjectInput | AttendanceUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutProjectInput | AttendanceUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type LabourAllocationUncheckedUpdateManyWithoutProjectNestedInput = {
    create?: XOR<LabourAllocationCreateWithoutProjectInput, LabourAllocationUncheckedCreateWithoutProjectInput> | LabourAllocationCreateWithoutProjectInput[] | LabourAllocationUncheckedCreateWithoutProjectInput[]
    connectOrCreate?: LabourAllocationCreateOrConnectWithoutProjectInput | LabourAllocationCreateOrConnectWithoutProjectInput[]
    upsert?: LabourAllocationUpsertWithWhereUniqueWithoutProjectInput | LabourAllocationUpsertWithWhereUniqueWithoutProjectInput[]
    createMany?: LabourAllocationCreateManyProjectInputEnvelope
    set?: LabourAllocationWhereUniqueInput | LabourAllocationWhereUniqueInput[]
    disconnect?: LabourAllocationWhereUniqueInput | LabourAllocationWhereUniqueInput[]
    delete?: LabourAllocationWhereUniqueInput | LabourAllocationWhereUniqueInput[]
    connect?: LabourAllocationWhereUniqueInput | LabourAllocationWhereUniqueInput[]
    update?: LabourAllocationUpdateWithWhereUniqueWithoutProjectInput | LabourAllocationUpdateWithWhereUniqueWithoutProjectInput[]
    updateMany?: LabourAllocationUpdateManyWithWhereWithoutProjectInput | LabourAllocationUpdateManyWithWhereWithoutProjectInput[]
    deleteMany?: LabourAllocationScalarWhereInput | LabourAllocationScalarWhereInput[]
  }

  export type ProjectCreateNestedOneWithoutFilesInput = {
    create?: XOR<ProjectCreateWithoutFilesInput, ProjectUncheckedCreateWithoutFilesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutFilesInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProject_filesInput = {
    create?: XOR<UserCreateWithoutProject_filesInput, UserUncheckedCreateWithoutProject_filesInput>
    connectOrCreate?: UserCreateOrConnectWithoutProject_filesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumFileTypeFieldUpdateOperationsInput = {
    set?: $Enums.FileType
  }

  export type BigIntFieldUpdateOperationsInput = {
    set?: bigint | number
    increment?: bigint | number
    decrement?: bigint | number
    multiply?: bigint | number
    divide?: bigint | number
  }

  export type ProjectUpdateOneRequiredWithoutFilesNestedInput = {
    create?: XOR<ProjectCreateWithoutFilesInput, ProjectUncheckedCreateWithoutFilesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutFilesInput
    upsert?: ProjectUpsertWithoutFilesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutFilesInput, ProjectUpdateWithoutFilesInput>, ProjectUncheckedUpdateWithoutFilesInput>
  }

  export type UserUpdateOneRequiredWithoutProject_filesNestedInput = {
    create?: XOR<UserCreateWithoutProject_filesInput, UserUncheckedCreateWithoutProject_filesInput>
    connectOrCreate?: UserCreateOrConnectWithoutProject_filesInput
    upsert?: UserUpsertWithoutProject_filesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProject_filesInput, UserUpdateWithoutProject_filesInput>, UserUncheckedUpdateWithoutProject_filesInput>
  }

  export type ProjectCreateNestedOneWithoutUpdatesInput = {
    create?: XOR<ProjectCreateWithoutUpdatesInput, ProjectUncheckedCreateWithoutUpdatesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutUpdatesInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutProject_updatesInput = {
    create?: XOR<UserCreateWithoutProject_updatesInput, UserUncheckedCreateWithoutProject_updatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutProject_updatesInput
    connect?: UserWhereUniqueInput
  }

  export type ProjectUpdateOneRequiredWithoutUpdatesNestedInput = {
    create?: XOR<ProjectCreateWithoutUpdatesInput, ProjectUncheckedCreateWithoutUpdatesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutUpdatesInput
    upsert?: ProjectUpsertWithoutUpdatesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutUpdatesInput, ProjectUpdateWithoutUpdatesInput>, ProjectUncheckedUpdateWithoutUpdatesInput>
  }

  export type UserUpdateOneRequiredWithoutProject_updatesNestedInput = {
    create?: XOR<UserCreateWithoutProject_updatesInput, UserUncheckedCreateWithoutProject_updatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutProject_updatesInput
    upsert?: UserUpsertWithoutProject_updatesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutProject_updatesInput, UserUpdateWithoutProject_updatesInput>, UserUncheckedUpdateWithoutProject_updatesInput>
  }

  export type ProjectCreateNestedOneWithoutSupport_requestsInput = {
    create?: XOR<ProjectCreateWithoutSupport_requestsInput, ProjectUncheckedCreateWithoutSupport_requestsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSupport_requestsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSupport_requestsInput = {
    create?: XOR<UserCreateWithoutSupport_requestsInput, UserUncheckedCreateWithoutSupport_requestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupport_requestsInput
    connect?: UserWhereUniqueInput
  }

  export type SupportMessageCreateNestedManyWithoutRequestInput = {
    create?: XOR<SupportMessageCreateWithoutRequestInput, SupportMessageUncheckedCreateWithoutRequestInput> | SupportMessageCreateWithoutRequestInput[] | SupportMessageUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: SupportMessageCreateOrConnectWithoutRequestInput | SupportMessageCreateOrConnectWithoutRequestInput[]
    createMany?: SupportMessageCreateManyRequestInputEnvelope
    connect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
  }

  export type SupportMessageUncheckedCreateNestedManyWithoutRequestInput = {
    create?: XOR<SupportMessageCreateWithoutRequestInput, SupportMessageUncheckedCreateWithoutRequestInput> | SupportMessageCreateWithoutRequestInput[] | SupportMessageUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: SupportMessageCreateOrConnectWithoutRequestInput | SupportMessageCreateOrConnectWithoutRequestInput[]
    createMany?: SupportMessageCreateManyRequestInputEnvelope
    connect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
  }

  export type EnumSupportStatusFieldUpdateOperationsInput = {
    set?: $Enums.SupportStatus
  }

  export type EnumPriorityLevelFieldUpdateOperationsInput = {
    set?: $Enums.PriorityLevel
  }

  export type ProjectUpdateOneWithoutSupport_requestsNestedInput = {
    create?: XOR<ProjectCreateWithoutSupport_requestsInput, ProjectUncheckedCreateWithoutSupport_requestsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutSupport_requestsInput
    upsert?: ProjectUpsertWithoutSupport_requestsInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutSupport_requestsInput, ProjectUpdateWithoutSupport_requestsInput>, ProjectUncheckedUpdateWithoutSupport_requestsInput>
  }

  export type UserUpdateOneRequiredWithoutSupport_requestsNestedInput = {
    create?: XOR<UserCreateWithoutSupport_requestsInput, UserUncheckedCreateWithoutSupport_requestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupport_requestsInput
    upsert?: UserUpsertWithoutSupport_requestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSupport_requestsInput, UserUpdateWithoutSupport_requestsInput>, UserUncheckedUpdateWithoutSupport_requestsInput>
  }

  export type SupportMessageUpdateManyWithoutRequestNestedInput = {
    create?: XOR<SupportMessageCreateWithoutRequestInput, SupportMessageUncheckedCreateWithoutRequestInput> | SupportMessageCreateWithoutRequestInput[] | SupportMessageUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: SupportMessageCreateOrConnectWithoutRequestInput | SupportMessageCreateOrConnectWithoutRequestInput[]
    upsert?: SupportMessageUpsertWithWhereUniqueWithoutRequestInput | SupportMessageUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: SupportMessageCreateManyRequestInputEnvelope
    set?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    disconnect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    delete?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    connect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    update?: SupportMessageUpdateWithWhereUniqueWithoutRequestInput | SupportMessageUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: SupportMessageUpdateManyWithWhereWithoutRequestInput | SupportMessageUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: SupportMessageScalarWhereInput | SupportMessageScalarWhereInput[]
  }

  export type SupportMessageUncheckedUpdateManyWithoutRequestNestedInput = {
    create?: XOR<SupportMessageCreateWithoutRequestInput, SupportMessageUncheckedCreateWithoutRequestInput> | SupportMessageCreateWithoutRequestInput[] | SupportMessageUncheckedCreateWithoutRequestInput[]
    connectOrCreate?: SupportMessageCreateOrConnectWithoutRequestInput | SupportMessageCreateOrConnectWithoutRequestInput[]
    upsert?: SupportMessageUpsertWithWhereUniqueWithoutRequestInput | SupportMessageUpsertWithWhereUniqueWithoutRequestInput[]
    createMany?: SupportMessageCreateManyRequestInputEnvelope
    set?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    disconnect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    delete?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    connect?: SupportMessageWhereUniqueInput | SupportMessageWhereUniqueInput[]
    update?: SupportMessageUpdateWithWhereUniqueWithoutRequestInput | SupportMessageUpdateWithWhereUniqueWithoutRequestInput[]
    updateMany?: SupportMessageUpdateManyWithWhereWithoutRequestInput | SupportMessageUpdateManyWithWhereWithoutRequestInput[]
    deleteMany?: SupportMessageScalarWhereInput | SupportMessageScalarWhereInput[]
  }

  export type SupportRequestCreateNestedOneWithoutMessagesInput = {
    create?: XOR<SupportRequestCreateWithoutMessagesInput, SupportRequestUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: SupportRequestCreateOrConnectWithoutMessagesInput
    connect?: SupportRequestWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSupport_messagesInput = {
    create?: XOR<UserCreateWithoutSupport_messagesInput, UserUncheckedCreateWithoutSupport_messagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupport_messagesInput
    connect?: UserWhereUniqueInput
  }

  export type SupportRequestUpdateOneRequiredWithoutMessagesNestedInput = {
    create?: XOR<SupportRequestCreateWithoutMessagesInput, SupportRequestUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: SupportRequestCreateOrConnectWithoutMessagesInput
    upsert?: SupportRequestUpsertWithoutMessagesInput
    connect?: SupportRequestWhereUniqueInput
    update?: XOR<XOR<SupportRequestUpdateToOneWithWhereWithoutMessagesInput, SupportRequestUpdateWithoutMessagesInput>, SupportRequestUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutSupport_messagesNestedInput = {
    create?: XOR<UserCreateWithoutSupport_messagesInput, UserUncheckedCreateWithoutSupport_messagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSupport_messagesInput
    upsert?: UserUpsertWithoutSupport_messagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSupport_messagesInput, UserUpdateWithoutSupport_messagesInput>, UserUncheckedUpdateWithoutSupport_messagesInput>
  }

  export type ProjectCreateNestedOneWithoutMeeting_requestsInput = {
    create?: XOR<ProjectCreateWithoutMeeting_requestsInput, ProjectUncheckedCreateWithoutMeeting_requestsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMeeting_requestsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutMeeting_requestsInput = {
    create?: XOR<UserCreateWithoutMeeting_requestsInput, UserUncheckedCreateWithoutMeeting_requestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMeeting_requestsInput
    connect?: UserWhereUniqueInput
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EnumMeetingStatusFieldUpdateOperationsInput = {
    set?: $Enums.MeetingStatus
  }

  export type ProjectUpdateOneWithoutMeeting_requestsNestedInput = {
    create?: XOR<ProjectCreateWithoutMeeting_requestsInput, ProjectUncheckedCreateWithoutMeeting_requestsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutMeeting_requestsInput
    upsert?: ProjectUpsertWithoutMeeting_requestsInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutMeeting_requestsInput, ProjectUpdateWithoutMeeting_requestsInput>, ProjectUncheckedUpdateWithoutMeeting_requestsInput>
  }

  export type UserUpdateOneRequiredWithoutMeeting_requestsNestedInput = {
    create?: XOR<UserCreateWithoutMeeting_requestsInput, UserUncheckedCreateWithoutMeeting_requestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutMeeting_requestsInput
    upsert?: UserUpsertWithoutMeeting_requestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutMeeting_requestsInput, UserUpdateWithoutMeeting_requestsInput>, UserUncheckedUpdateWithoutMeeting_requestsInput>
  }

  export type ProjectCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<ProjectCreateWithoutInvoicesInput, ProjectUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutInvoicesInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInvoicesInput = {
    create?: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesInput
    connect?: UserWhereUniqueInput
  }

  export type PaymentCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutInvoiceInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumInvoiceStatusFieldUpdateOperationsInput = {
    set?: $Enums.InvoiceStatus
  }

  export type ProjectUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<ProjectCreateWithoutInvoicesInput, ProjectUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutInvoicesInput
    upsert?: ProjectUpsertWithoutInvoicesInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutInvoicesInput, ProjectUpdateWithoutInvoicesInput>, ProjectUncheckedUpdateWithoutInvoicesInput>
  }

  export type UserUpdateOneRequiredWithoutInvoicesNestedInput = {
    create?: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutInvoicesInput
    upsert?: UserUpsertWithoutInvoicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInvoicesInput, UserUpdateWithoutInvoicesInput>, UserUncheckedUpdateWithoutInvoicesInput>
  }

  export type PaymentUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceNestedInput = {
    create?: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput> | PaymentCreateWithoutInvoiceInput[] | PaymentUncheckedCreateWithoutInvoiceInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutInvoiceInput | PaymentCreateOrConnectWithoutInvoiceInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutInvoiceInput | PaymentUpsertWithWhereUniqueWithoutInvoiceInput[]
    createMany?: PaymentCreateManyInvoiceInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutInvoiceInput | PaymentUpdateWithWhereUniqueWithoutInvoiceInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutInvoiceInput | PaymentUpdateManyWithWhereWithoutInvoiceInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type InvoiceCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
  }

  export type InvoiceUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: InvoiceCreateOrConnectWithoutPaymentsInput
    upsert?: InvoiceUpsertWithoutPaymentsInput
    connect?: InvoiceWhereUniqueInput
    update?: XOR<XOR<InvoiceUpdateToOneWithWhereWithoutPaymentsInput, InvoiceUpdateWithoutPaymentsInput>, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type AttendanceCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AttendanceCreateWithoutEmployeeInput, AttendanceUncheckedCreateWithoutEmployeeInput> | AttendanceCreateWithoutEmployeeInput[] | AttendanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutEmployeeInput | AttendanceCreateOrConnectWithoutEmployeeInput[]
    createMany?: AttendanceCreateManyEmployeeInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type LabourAllocationCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LabourAllocationCreateWithoutEmployeeInput, LabourAllocationUncheckedCreateWithoutEmployeeInput> | LabourAllocationCreateWithoutEmployeeInput[] | LabourAllocationUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LabourAllocationCreateOrConnectWithoutEmployeeInput | LabourAllocationCreateOrConnectWithoutEmployeeInput[]
    createMany?: LabourAllocationCreateManyEmployeeInputEnvelope
    connect?: LabourAllocationWhereUniqueInput | LabourAllocationWhereUniqueInput[]
  }

  export type PayrollLineCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PayrollLineCreateWithoutEmployeeInput, PayrollLineUncheckedCreateWithoutEmployeeInput> | PayrollLineCreateWithoutEmployeeInput[] | PayrollLineUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollLineCreateOrConnectWithoutEmployeeInput | PayrollLineCreateOrConnectWithoutEmployeeInput[]
    createMany?: PayrollLineCreateManyEmployeeInputEnvelope
    connect?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AttendanceCreateWithoutEmployeeInput, AttendanceUncheckedCreateWithoutEmployeeInput> | AttendanceCreateWithoutEmployeeInput[] | AttendanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutEmployeeInput | AttendanceCreateOrConnectWithoutEmployeeInput[]
    createMany?: AttendanceCreateManyEmployeeInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type LabourAllocationUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LabourAllocationCreateWithoutEmployeeInput, LabourAllocationUncheckedCreateWithoutEmployeeInput> | LabourAllocationCreateWithoutEmployeeInput[] | LabourAllocationUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LabourAllocationCreateOrConnectWithoutEmployeeInput | LabourAllocationCreateOrConnectWithoutEmployeeInput[]
    createMany?: LabourAllocationCreateManyEmployeeInputEnvelope
    connect?: LabourAllocationWhereUniqueInput | LabourAllocationWhereUniqueInput[]
  }

  export type PayrollLineUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PayrollLineCreateWithoutEmployeeInput, PayrollLineUncheckedCreateWithoutEmployeeInput> | PayrollLineCreateWithoutEmployeeInput[] | PayrollLineUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollLineCreateOrConnectWithoutEmployeeInput | PayrollLineCreateOrConnectWithoutEmployeeInput[]
    createMany?: PayrollLineCreateManyEmployeeInputEnvelope
    connect?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
  }

  export type EnumMemberStatusFieldUpdateOperationsInput = {
    set?: $Enums.MemberStatus
  }

  export type AttendanceUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AttendanceCreateWithoutEmployeeInput, AttendanceUncheckedCreateWithoutEmployeeInput> | AttendanceCreateWithoutEmployeeInput[] | AttendanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutEmployeeInput | AttendanceCreateOrConnectWithoutEmployeeInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutEmployeeInput | AttendanceUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AttendanceCreateManyEmployeeInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutEmployeeInput | AttendanceUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutEmployeeInput | AttendanceUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type LabourAllocationUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LabourAllocationCreateWithoutEmployeeInput, LabourAllocationUncheckedCreateWithoutEmployeeInput> | LabourAllocationCreateWithoutEmployeeInput[] | LabourAllocationUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LabourAllocationCreateOrConnectWithoutEmployeeInput | LabourAllocationCreateOrConnectWithoutEmployeeInput[]
    upsert?: LabourAllocationUpsertWithWhereUniqueWithoutEmployeeInput | LabourAllocationUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LabourAllocationCreateManyEmployeeInputEnvelope
    set?: LabourAllocationWhereUniqueInput | LabourAllocationWhereUniqueInput[]
    disconnect?: LabourAllocationWhereUniqueInput | LabourAllocationWhereUniqueInput[]
    delete?: LabourAllocationWhereUniqueInput | LabourAllocationWhereUniqueInput[]
    connect?: LabourAllocationWhereUniqueInput | LabourAllocationWhereUniqueInput[]
    update?: LabourAllocationUpdateWithWhereUniqueWithoutEmployeeInput | LabourAllocationUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LabourAllocationUpdateManyWithWhereWithoutEmployeeInput | LabourAllocationUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LabourAllocationScalarWhereInput | LabourAllocationScalarWhereInput[]
  }

  export type PayrollLineUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PayrollLineCreateWithoutEmployeeInput, PayrollLineUncheckedCreateWithoutEmployeeInput> | PayrollLineCreateWithoutEmployeeInput[] | PayrollLineUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollLineCreateOrConnectWithoutEmployeeInput | PayrollLineCreateOrConnectWithoutEmployeeInput[]
    upsert?: PayrollLineUpsertWithWhereUniqueWithoutEmployeeInput | PayrollLineUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PayrollLineCreateManyEmployeeInputEnvelope
    set?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    disconnect?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    delete?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    connect?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    update?: PayrollLineUpdateWithWhereUniqueWithoutEmployeeInput | PayrollLineUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PayrollLineUpdateManyWithWhereWithoutEmployeeInput | PayrollLineUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PayrollLineScalarWhereInput | PayrollLineScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AttendanceCreateWithoutEmployeeInput, AttendanceUncheckedCreateWithoutEmployeeInput> | AttendanceCreateWithoutEmployeeInput[] | AttendanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutEmployeeInput | AttendanceCreateOrConnectWithoutEmployeeInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutEmployeeInput | AttendanceUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AttendanceCreateManyEmployeeInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutEmployeeInput | AttendanceUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutEmployeeInput | AttendanceUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type LabourAllocationUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LabourAllocationCreateWithoutEmployeeInput, LabourAllocationUncheckedCreateWithoutEmployeeInput> | LabourAllocationCreateWithoutEmployeeInput[] | LabourAllocationUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LabourAllocationCreateOrConnectWithoutEmployeeInput | LabourAllocationCreateOrConnectWithoutEmployeeInput[]
    upsert?: LabourAllocationUpsertWithWhereUniqueWithoutEmployeeInput | LabourAllocationUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LabourAllocationCreateManyEmployeeInputEnvelope
    set?: LabourAllocationWhereUniqueInput | LabourAllocationWhereUniqueInput[]
    disconnect?: LabourAllocationWhereUniqueInput | LabourAllocationWhereUniqueInput[]
    delete?: LabourAllocationWhereUniqueInput | LabourAllocationWhereUniqueInput[]
    connect?: LabourAllocationWhereUniqueInput | LabourAllocationWhereUniqueInput[]
    update?: LabourAllocationUpdateWithWhereUniqueWithoutEmployeeInput | LabourAllocationUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LabourAllocationUpdateManyWithWhereWithoutEmployeeInput | LabourAllocationUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LabourAllocationScalarWhereInput | LabourAllocationScalarWhereInput[]
  }

  export type PayrollLineUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PayrollLineCreateWithoutEmployeeInput, PayrollLineUncheckedCreateWithoutEmployeeInput> | PayrollLineCreateWithoutEmployeeInput[] | PayrollLineUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollLineCreateOrConnectWithoutEmployeeInput | PayrollLineCreateOrConnectWithoutEmployeeInput[]
    upsert?: PayrollLineUpsertWithWhereUniqueWithoutEmployeeInput | PayrollLineUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PayrollLineCreateManyEmployeeInputEnvelope
    set?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    disconnect?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    delete?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    connect?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    update?: PayrollLineUpdateWithWhereUniqueWithoutEmployeeInput | PayrollLineUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PayrollLineUpdateManyWithWhereWithoutEmployeeInput | PayrollLineUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PayrollLineScalarWhereInput | PayrollLineScalarWhereInput[]
  }

  export type EmployeeCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<EmployeeCreateWithoutAttendanceInput, EmployeeUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAttendanceInput
    connect?: EmployeeWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutAttendanceInput = {
    create?: XOR<ProjectCreateWithoutAttendanceInput, ProjectUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAttendanceInput
    connect?: ProjectWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EmployeeUpdateOneRequiredWithoutAttendanceNestedInput = {
    create?: XOR<EmployeeCreateWithoutAttendanceInput, EmployeeUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAttendanceInput
    upsert?: EmployeeUpsertWithoutAttendanceInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutAttendanceInput, EmployeeUpdateWithoutAttendanceInput>, EmployeeUncheckedUpdateWithoutAttendanceInput>
  }

  export type ProjectUpdateOneWithoutAttendanceNestedInput = {
    create?: XOR<ProjectCreateWithoutAttendanceInput, ProjectUncheckedCreateWithoutAttendanceInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutAttendanceInput
    upsert?: ProjectUpsertWithoutAttendanceInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutAttendanceInput, ProjectUpdateWithoutAttendanceInput>, ProjectUncheckedUpdateWithoutAttendanceInput>
  }

  export type EmployeeCreateNestedOneWithoutAllocationsInput = {
    create?: XOR<EmployeeCreateWithoutAllocationsInput, EmployeeUncheckedCreateWithoutAllocationsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAllocationsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutLabour_allocationsInput = {
    create?: XOR<ProjectCreateWithoutLabour_allocationsInput, ProjectUncheckedCreateWithoutLabour_allocationsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutLabour_allocationsInput
    connect?: ProjectWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutAllocationsNestedInput = {
    create?: XOR<EmployeeCreateWithoutAllocationsInput, EmployeeUncheckedCreateWithoutAllocationsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAllocationsInput
    upsert?: EmployeeUpsertWithoutAllocationsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutAllocationsInput, EmployeeUpdateWithoutAllocationsInput>, EmployeeUncheckedUpdateWithoutAllocationsInput>
  }

  export type ProjectUpdateOneRequiredWithoutLabour_allocationsNestedInput = {
    create?: XOR<ProjectCreateWithoutLabour_allocationsInput, ProjectUncheckedCreateWithoutLabour_allocationsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutLabour_allocationsInput
    upsert?: ProjectUpsertWithoutLabour_allocationsInput
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutLabour_allocationsInput, ProjectUpdateWithoutLabour_allocationsInput>, ProjectUncheckedUpdateWithoutLabour_allocationsInput>
  }

  export type PayrollLineCreateNestedManyWithoutPayrollInput = {
    create?: XOR<PayrollLineCreateWithoutPayrollInput, PayrollLineUncheckedCreateWithoutPayrollInput> | PayrollLineCreateWithoutPayrollInput[] | PayrollLineUncheckedCreateWithoutPayrollInput[]
    connectOrCreate?: PayrollLineCreateOrConnectWithoutPayrollInput | PayrollLineCreateOrConnectWithoutPayrollInput[]
    createMany?: PayrollLineCreateManyPayrollInputEnvelope
    connect?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
  }

  export type PayrollLineUncheckedCreateNestedManyWithoutPayrollInput = {
    create?: XOR<PayrollLineCreateWithoutPayrollInput, PayrollLineUncheckedCreateWithoutPayrollInput> | PayrollLineCreateWithoutPayrollInput[] | PayrollLineUncheckedCreateWithoutPayrollInput[]
    connectOrCreate?: PayrollLineCreateOrConnectWithoutPayrollInput | PayrollLineCreateOrConnectWithoutPayrollInput[]
    createMany?: PayrollLineCreateManyPayrollInputEnvelope
    connect?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
  }

  export type PayrollLineUpdateManyWithoutPayrollNestedInput = {
    create?: XOR<PayrollLineCreateWithoutPayrollInput, PayrollLineUncheckedCreateWithoutPayrollInput> | PayrollLineCreateWithoutPayrollInput[] | PayrollLineUncheckedCreateWithoutPayrollInput[]
    connectOrCreate?: PayrollLineCreateOrConnectWithoutPayrollInput | PayrollLineCreateOrConnectWithoutPayrollInput[]
    upsert?: PayrollLineUpsertWithWhereUniqueWithoutPayrollInput | PayrollLineUpsertWithWhereUniqueWithoutPayrollInput[]
    createMany?: PayrollLineCreateManyPayrollInputEnvelope
    set?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    disconnect?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    delete?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    connect?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    update?: PayrollLineUpdateWithWhereUniqueWithoutPayrollInput | PayrollLineUpdateWithWhereUniqueWithoutPayrollInput[]
    updateMany?: PayrollLineUpdateManyWithWhereWithoutPayrollInput | PayrollLineUpdateManyWithWhereWithoutPayrollInput[]
    deleteMany?: PayrollLineScalarWhereInput | PayrollLineScalarWhereInput[]
  }

  export type PayrollLineUncheckedUpdateManyWithoutPayrollNestedInput = {
    create?: XOR<PayrollLineCreateWithoutPayrollInput, PayrollLineUncheckedCreateWithoutPayrollInput> | PayrollLineCreateWithoutPayrollInput[] | PayrollLineUncheckedCreateWithoutPayrollInput[]
    connectOrCreate?: PayrollLineCreateOrConnectWithoutPayrollInput | PayrollLineCreateOrConnectWithoutPayrollInput[]
    upsert?: PayrollLineUpsertWithWhereUniqueWithoutPayrollInput | PayrollLineUpsertWithWhereUniqueWithoutPayrollInput[]
    createMany?: PayrollLineCreateManyPayrollInputEnvelope
    set?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    disconnect?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    delete?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    connect?: PayrollLineWhereUniqueInput | PayrollLineWhereUniqueInput[]
    update?: PayrollLineUpdateWithWhereUniqueWithoutPayrollInput | PayrollLineUpdateWithWhereUniqueWithoutPayrollInput[]
    updateMany?: PayrollLineUpdateManyWithWhereWithoutPayrollInput | PayrollLineUpdateManyWithWhereWithoutPayrollInput[]
    deleteMany?: PayrollLineScalarWhereInput | PayrollLineScalarWhereInput[]
  }

  export type PayrollCreateNestedOneWithoutLinesInput = {
    create?: XOR<PayrollCreateWithoutLinesInput, PayrollUncheckedCreateWithoutLinesInput>
    connectOrCreate?: PayrollCreateOrConnectWithoutLinesInput
    connect?: PayrollWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutPayroll_itemsInput = {
    create?: XOR<EmployeeCreateWithoutPayroll_itemsInput, EmployeeUncheckedCreateWithoutPayroll_itemsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPayroll_itemsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type PayrollUpdateOneRequiredWithoutLinesNestedInput = {
    create?: XOR<PayrollCreateWithoutLinesInput, PayrollUncheckedCreateWithoutLinesInput>
    connectOrCreate?: PayrollCreateOrConnectWithoutLinesInput
    upsert?: PayrollUpsertWithoutLinesInput
    connect?: PayrollWhereUniqueInput
    update?: XOR<XOR<PayrollUpdateToOneWithWhereWithoutLinesInput, PayrollUpdateWithoutLinesInput>, PayrollUncheckedUpdateWithoutLinesInput>
  }

  export type EmployeeUpdateOneRequiredWithoutPayroll_itemsNestedInput = {
    create?: XOR<EmployeeCreateWithoutPayroll_itemsInput, EmployeeUncheckedCreateWithoutPayroll_itemsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutPayroll_itemsInput
    upsert?: EmployeeUpsertWithoutPayroll_itemsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutPayroll_itemsInput, EmployeeUpdateWithoutPayroll_itemsInput>, EmployeeUncheckedUpdateWithoutPayroll_itemsInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.TransactionType
  }

  export type UserUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTransactionsInput
    upsert?: UserUpsertWithoutTransactionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTransactionsInput, UserUpdateWithoutTransactionsInput>, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type InventoryTransactionCreateNestedManyWithoutItemInput = {
    create?: XOR<InventoryTransactionCreateWithoutItemInput, InventoryTransactionUncheckedCreateWithoutItemInput> | InventoryTransactionCreateWithoutItemInput[] | InventoryTransactionUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutItemInput | InventoryTransactionCreateOrConnectWithoutItemInput[]
    createMany?: InventoryTransactionCreateManyItemInputEnvelope
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
  }

  export type InventoryTransactionUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<InventoryTransactionCreateWithoutItemInput, InventoryTransactionUncheckedCreateWithoutItemInput> | InventoryTransactionCreateWithoutItemInput[] | InventoryTransactionUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutItemInput | InventoryTransactionCreateOrConnectWithoutItemInput[]
    createMany?: InventoryTransactionCreateManyItemInputEnvelope
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type InventoryTransactionUpdateManyWithoutItemNestedInput = {
    create?: XOR<InventoryTransactionCreateWithoutItemInput, InventoryTransactionUncheckedCreateWithoutItemInput> | InventoryTransactionCreateWithoutItemInput[] | InventoryTransactionUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutItemInput | InventoryTransactionCreateOrConnectWithoutItemInput[]
    upsert?: InventoryTransactionUpsertWithWhereUniqueWithoutItemInput | InventoryTransactionUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InventoryTransactionCreateManyItemInputEnvelope
    set?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    disconnect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    delete?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    update?: InventoryTransactionUpdateWithWhereUniqueWithoutItemInput | InventoryTransactionUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InventoryTransactionUpdateManyWithWhereWithoutItemInput | InventoryTransactionUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
  }

  export type InventoryTransactionUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<InventoryTransactionCreateWithoutItemInput, InventoryTransactionUncheckedCreateWithoutItemInput> | InventoryTransactionCreateWithoutItemInput[] | InventoryTransactionUncheckedCreateWithoutItemInput[]
    connectOrCreate?: InventoryTransactionCreateOrConnectWithoutItemInput | InventoryTransactionCreateOrConnectWithoutItemInput[]
    upsert?: InventoryTransactionUpsertWithWhereUniqueWithoutItemInput | InventoryTransactionUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: InventoryTransactionCreateManyItemInputEnvelope
    set?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    disconnect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    delete?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    connect?: InventoryTransactionWhereUniqueInput | InventoryTransactionWhereUniqueInput[]
    update?: InventoryTransactionUpdateWithWhereUniqueWithoutItemInput | InventoryTransactionUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: InventoryTransactionUpdateManyWithWhereWithoutItemInput | InventoryTransactionUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
  }

  export type InventoryItemCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<InventoryItemCreateWithoutTransactionsInput, InventoryItemUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutTransactionsInput
    connect?: InventoryItemWhereUniqueInput
  }

  export type ProjectCreateNestedOneWithoutInventory_logsInput = {
    create?: XOR<ProjectCreateWithoutInventory_logsInput, ProjectUncheckedCreateWithoutInventory_logsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutInventory_logsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInventory_logsInput = {
    create?: XOR<UserCreateWithoutInventory_logsInput, UserUncheckedCreateWithoutInventory_logsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventory_logsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumInventoryTransactionTypeFieldUpdateOperationsInput = {
    set?: $Enums.InventoryTransactionType
  }

  export type InventoryItemUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<InventoryItemCreateWithoutTransactionsInput, InventoryItemUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: InventoryItemCreateOrConnectWithoutTransactionsInput
    upsert?: InventoryItemUpsertWithoutTransactionsInput
    connect?: InventoryItemWhereUniqueInput
    update?: XOR<XOR<InventoryItemUpdateToOneWithWhereWithoutTransactionsInput, InventoryItemUpdateWithoutTransactionsInput>, InventoryItemUncheckedUpdateWithoutTransactionsInput>
  }

  export type ProjectUpdateOneWithoutInventory_logsNestedInput = {
    create?: XOR<ProjectCreateWithoutInventory_logsInput, ProjectUncheckedCreateWithoutInventory_logsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutInventory_logsInput
    upsert?: ProjectUpsertWithoutInventory_logsInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutInventory_logsInput, ProjectUpdateWithoutInventory_logsInput>, ProjectUncheckedUpdateWithoutInventory_logsInput>
  }

  export type UserUpdateOneRequiredWithoutInventory_logsNestedInput = {
    create?: XOR<UserCreateWithoutInventory_logsInput, UserUncheckedCreateWithoutInventory_logsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInventory_logsInput
    upsert?: UserUpsertWithoutInventory_logsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInventory_logsInput, UserUpdateWithoutInventory_logsInput>, UserUncheckedUpdateWithoutInventory_logsInput>
  }

  export type ProjectCreateNestedOneWithoutPurchase_requestsInput = {
    create?: XOR<ProjectCreateWithoutPurchase_requestsInput, ProjectUncheckedCreateWithoutPurchase_requestsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPurchase_requestsInput
    connect?: ProjectWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPurchase_requestsInput = {
    create?: XOR<UserCreateWithoutPurchase_requestsInput, UserUncheckedCreateWithoutPurchase_requestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchase_requestsInput
    connect?: UserWhereUniqueInput
  }

  export type PurchaseOrderCreateNestedManyWithoutPurchase_requestInput = {
    create?: XOR<PurchaseOrderCreateWithoutPurchase_requestInput, PurchaseOrderUncheckedCreateWithoutPurchase_requestInput> | PurchaseOrderCreateWithoutPurchase_requestInput[] | PurchaseOrderUncheckedCreateWithoutPurchase_requestInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutPurchase_requestInput | PurchaseOrderCreateOrConnectWithoutPurchase_requestInput[]
    createMany?: PurchaseOrderCreateManyPurchase_requestInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutPurchase_requestInput = {
    create?: XOR<PurchaseOrderCreateWithoutPurchase_requestInput, PurchaseOrderUncheckedCreateWithoutPurchase_requestInput> | PurchaseOrderCreateWithoutPurchase_requestInput[] | PurchaseOrderUncheckedCreateWithoutPurchase_requestInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutPurchase_requestInput | PurchaseOrderCreateOrConnectWithoutPurchase_requestInput[]
    createMany?: PurchaseOrderCreateManyPurchase_requestInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type EnumPurchaseStatusFieldUpdateOperationsInput = {
    set?: $Enums.PurchaseStatus
  }

  export type ProjectUpdateOneWithoutPurchase_requestsNestedInput = {
    create?: XOR<ProjectCreateWithoutPurchase_requestsInput, ProjectUncheckedCreateWithoutPurchase_requestsInput>
    connectOrCreate?: ProjectCreateOrConnectWithoutPurchase_requestsInput
    upsert?: ProjectUpsertWithoutPurchase_requestsInput
    disconnect?: ProjectWhereInput | boolean
    delete?: ProjectWhereInput | boolean
    connect?: ProjectWhereUniqueInput
    update?: XOR<XOR<ProjectUpdateToOneWithWhereWithoutPurchase_requestsInput, ProjectUpdateWithoutPurchase_requestsInput>, ProjectUncheckedUpdateWithoutPurchase_requestsInput>
  }

  export type UserUpdateOneRequiredWithoutPurchase_requestsNestedInput = {
    create?: XOR<UserCreateWithoutPurchase_requestsInput, UserUncheckedCreateWithoutPurchase_requestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchase_requestsInput
    upsert?: UserUpsertWithoutPurchase_requestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPurchase_requestsInput, UserUpdateWithoutPurchase_requestsInput>, UserUncheckedUpdateWithoutPurchase_requestsInput>
  }

  export type PurchaseOrderUpdateManyWithoutPurchase_requestNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutPurchase_requestInput, PurchaseOrderUncheckedCreateWithoutPurchase_requestInput> | PurchaseOrderCreateWithoutPurchase_requestInput[] | PurchaseOrderUncheckedCreateWithoutPurchase_requestInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutPurchase_requestInput | PurchaseOrderCreateOrConnectWithoutPurchase_requestInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutPurchase_requestInput | PurchaseOrderUpsertWithWhereUniqueWithoutPurchase_requestInput[]
    createMany?: PurchaseOrderCreateManyPurchase_requestInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutPurchase_requestInput | PurchaseOrderUpdateWithWhereUniqueWithoutPurchase_requestInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutPurchase_requestInput | PurchaseOrderUpdateManyWithWhereWithoutPurchase_requestInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutPurchase_requestNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutPurchase_requestInput, PurchaseOrderUncheckedCreateWithoutPurchase_requestInput> | PurchaseOrderCreateWithoutPurchase_requestInput[] | PurchaseOrderUncheckedCreateWithoutPurchase_requestInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutPurchase_requestInput | PurchaseOrderCreateOrConnectWithoutPurchase_requestInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutPurchase_requestInput | PurchaseOrderUpsertWithWhereUniqueWithoutPurchase_requestInput[]
    createMany?: PurchaseOrderCreateManyPurchase_requestInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutPurchase_requestInput | PurchaseOrderUpdateWithWhereUniqueWithoutPurchase_requestInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutPurchase_requestInput | PurchaseOrderUpdateManyWithWhereWithoutPurchase_requestInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type PurchaseOrderCreateNestedManyWithoutVendorInput = {
    create?: XOR<PurchaseOrderCreateWithoutVendorInput, PurchaseOrderUncheckedCreateWithoutVendorInput> | PurchaseOrderCreateWithoutVendorInput[] | PurchaseOrderUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutVendorInput | PurchaseOrderCreateOrConnectWithoutVendorInput[]
    createMany?: PurchaseOrderCreateManyVendorInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type VendorBillCreateNestedManyWithoutVendorInput = {
    create?: XOR<VendorBillCreateWithoutVendorInput, VendorBillUncheckedCreateWithoutVendorInput> | VendorBillCreateWithoutVendorInput[] | VendorBillUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorBillCreateOrConnectWithoutVendorInput | VendorBillCreateOrConnectWithoutVendorInput[]
    createMany?: VendorBillCreateManyVendorInputEnvelope
    connect?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
  }

  export type PurchaseOrderUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<PurchaseOrderCreateWithoutVendorInput, PurchaseOrderUncheckedCreateWithoutVendorInput> | PurchaseOrderCreateWithoutVendorInput[] | PurchaseOrderUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutVendorInput | PurchaseOrderCreateOrConnectWithoutVendorInput[]
    createMany?: PurchaseOrderCreateManyVendorInputEnvelope
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
  }

  export type VendorBillUncheckedCreateNestedManyWithoutVendorInput = {
    create?: XOR<VendorBillCreateWithoutVendorInput, VendorBillUncheckedCreateWithoutVendorInput> | VendorBillCreateWithoutVendorInput[] | VendorBillUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorBillCreateOrConnectWithoutVendorInput | VendorBillCreateOrConnectWithoutVendorInput[]
    createMany?: VendorBillCreateManyVendorInputEnvelope
    connect?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
  }

  export type PurchaseOrderUpdateManyWithoutVendorNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutVendorInput, PurchaseOrderUncheckedCreateWithoutVendorInput> | PurchaseOrderCreateWithoutVendorInput[] | PurchaseOrderUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutVendorInput | PurchaseOrderCreateOrConnectWithoutVendorInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutVendorInput | PurchaseOrderUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: PurchaseOrderCreateManyVendorInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutVendorInput | PurchaseOrderUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutVendorInput | PurchaseOrderUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type VendorBillUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VendorBillCreateWithoutVendorInput, VendorBillUncheckedCreateWithoutVendorInput> | VendorBillCreateWithoutVendorInput[] | VendorBillUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorBillCreateOrConnectWithoutVendorInput | VendorBillCreateOrConnectWithoutVendorInput[]
    upsert?: VendorBillUpsertWithWhereUniqueWithoutVendorInput | VendorBillUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VendorBillCreateManyVendorInputEnvelope
    set?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    disconnect?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    delete?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    connect?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    update?: VendorBillUpdateWithWhereUniqueWithoutVendorInput | VendorBillUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VendorBillUpdateManyWithWhereWithoutVendorInput | VendorBillUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VendorBillScalarWhereInput | VendorBillScalarWhereInput[]
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutVendorInput, PurchaseOrderUncheckedCreateWithoutVendorInput> | PurchaseOrderCreateWithoutVendorInput[] | PurchaseOrderUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutVendorInput | PurchaseOrderCreateOrConnectWithoutVendorInput[]
    upsert?: PurchaseOrderUpsertWithWhereUniqueWithoutVendorInput | PurchaseOrderUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: PurchaseOrderCreateManyVendorInputEnvelope
    set?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    disconnect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    delete?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    connect?: PurchaseOrderWhereUniqueInput | PurchaseOrderWhereUniqueInput[]
    update?: PurchaseOrderUpdateWithWhereUniqueWithoutVendorInput | PurchaseOrderUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: PurchaseOrderUpdateManyWithWhereWithoutVendorInput | PurchaseOrderUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
  }

  export type VendorBillUncheckedUpdateManyWithoutVendorNestedInput = {
    create?: XOR<VendorBillCreateWithoutVendorInput, VendorBillUncheckedCreateWithoutVendorInput> | VendorBillCreateWithoutVendorInput[] | VendorBillUncheckedCreateWithoutVendorInput[]
    connectOrCreate?: VendorBillCreateOrConnectWithoutVendorInput | VendorBillCreateOrConnectWithoutVendorInput[]
    upsert?: VendorBillUpsertWithWhereUniqueWithoutVendorInput | VendorBillUpsertWithWhereUniqueWithoutVendorInput[]
    createMany?: VendorBillCreateManyVendorInputEnvelope
    set?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    disconnect?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    delete?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    connect?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    update?: VendorBillUpdateWithWhereUniqueWithoutVendorInput | VendorBillUpdateWithWhereUniqueWithoutVendorInput[]
    updateMany?: VendorBillUpdateManyWithWhereWithoutVendorInput | VendorBillUpdateManyWithWhereWithoutVendorInput[]
    deleteMany?: VendorBillScalarWhereInput | VendorBillScalarWhereInput[]
  }

  export type PurchaseRequestCreateNestedOneWithoutPurchase_ordersInput = {
    create?: XOR<PurchaseRequestCreateWithoutPurchase_ordersInput, PurchaseRequestUncheckedCreateWithoutPurchase_ordersInput>
    connectOrCreate?: PurchaseRequestCreateOrConnectWithoutPurchase_ordersInput
    connect?: PurchaseRequestWhereUniqueInput
  }

  export type VendorCreateNestedOneWithoutPurchase_ordersInput = {
    create?: XOR<VendorCreateWithoutPurchase_ordersInput, VendorUncheckedCreateWithoutPurchase_ordersInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPurchase_ordersInput
    connect?: VendorWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutPurchase_ordersInput = {
    create?: XOR<UserCreateWithoutPurchase_ordersInput, UserUncheckedCreateWithoutPurchase_ordersInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchase_ordersInput
    connect?: UserWhereUniqueInput
  }

  export type GRNCreateNestedManyWithoutPurchase_orderInput = {
    create?: XOR<GRNCreateWithoutPurchase_orderInput, GRNUncheckedCreateWithoutPurchase_orderInput> | GRNCreateWithoutPurchase_orderInput[] | GRNUncheckedCreateWithoutPurchase_orderInput[]
    connectOrCreate?: GRNCreateOrConnectWithoutPurchase_orderInput | GRNCreateOrConnectWithoutPurchase_orderInput[]
    createMany?: GRNCreateManyPurchase_orderInputEnvelope
    connect?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
  }

  export type VendorBillCreateNestedManyWithoutPurchase_orderInput = {
    create?: XOR<VendorBillCreateWithoutPurchase_orderInput, VendorBillUncheckedCreateWithoutPurchase_orderInput> | VendorBillCreateWithoutPurchase_orderInput[] | VendorBillUncheckedCreateWithoutPurchase_orderInput[]
    connectOrCreate?: VendorBillCreateOrConnectWithoutPurchase_orderInput | VendorBillCreateOrConnectWithoutPurchase_orderInput[]
    createMany?: VendorBillCreateManyPurchase_orderInputEnvelope
    connect?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
  }

  export type GRNUncheckedCreateNestedManyWithoutPurchase_orderInput = {
    create?: XOR<GRNCreateWithoutPurchase_orderInput, GRNUncheckedCreateWithoutPurchase_orderInput> | GRNCreateWithoutPurchase_orderInput[] | GRNUncheckedCreateWithoutPurchase_orderInput[]
    connectOrCreate?: GRNCreateOrConnectWithoutPurchase_orderInput | GRNCreateOrConnectWithoutPurchase_orderInput[]
    createMany?: GRNCreateManyPurchase_orderInputEnvelope
    connect?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
  }

  export type VendorBillUncheckedCreateNestedManyWithoutPurchase_orderInput = {
    create?: XOR<VendorBillCreateWithoutPurchase_orderInput, VendorBillUncheckedCreateWithoutPurchase_orderInput> | VendorBillCreateWithoutPurchase_orderInput[] | VendorBillUncheckedCreateWithoutPurchase_orderInput[]
    connectOrCreate?: VendorBillCreateOrConnectWithoutPurchase_orderInput | VendorBillCreateOrConnectWithoutPurchase_orderInput[]
    createMany?: VendorBillCreateManyPurchase_orderInputEnvelope
    connect?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
  }

  export type PurchaseRequestUpdateOneWithoutPurchase_ordersNestedInput = {
    create?: XOR<PurchaseRequestCreateWithoutPurchase_ordersInput, PurchaseRequestUncheckedCreateWithoutPurchase_ordersInput>
    connectOrCreate?: PurchaseRequestCreateOrConnectWithoutPurchase_ordersInput
    upsert?: PurchaseRequestUpsertWithoutPurchase_ordersInput
    disconnect?: PurchaseRequestWhereInput | boolean
    delete?: PurchaseRequestWhereInput | boolean
    connect?: PurchaseRequestWhereUniqueInput
    update?: XOR<XOR<PurchaseRequestUpdateToOneWithWhereWithoutPurchase_ordersInput, PurchaseRequestUpdateWithoutPurchase_ordersInput>, PurchaseRequestUncheckedUpdateWithoutPurchase_ordersInput>
  }

  export type VendorUpdateOneRequiredWithoutPurchase_ordersNestedInput = {
    create?: XOR<VendorCreateWithoutPurchase_ordersInput, VendorUncheckedCreateWithoutPurchase_ordersInput>
    connectOrCreate?: VendorCreateOrConnectWithoutPurchase_ordersInput
    upsert?: VendorUpsertWithoutPurchase_ordersInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutPurchase_ordersInput, VendorUpdateWithoutPurchase_ordersInput>, VendorUncheckedUpdateWithoutPurchase_ordersInput>
  }

  export type UserUpdateOneRequiredWithoutPurchase_ordersNestedInput = {
    create?: XOR<UserCreateWithoutPurchase_ordersInput, UserUncheckedCreateWithoutPurchase_ordersInput>
    connectOrCreate?: UserCreateOrConnectWithoutPurchase_ordersInput
    upsert?: UserUpsertWithoutPurchase_ordersInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutPurchase_ordersInput, UserUpdateWithoutPurchase_ordersInput>, UserUncheckedUpdateWithoutPurchase_ordersInput>
  }

  export type GRNUpdateManyWithoutPurchase_orderNestedInput = {
    create?: XOR<GRNCreateWithoutPurchase_orderInput, GRNUncheckedCreateWithoutPurchase_orderInput> | GRNCreateWithoutPurchase_orderInput[] | GRNUncheckedCreateWithoutPurchase_orderInput[]
    connectOrCreate?: GRNCreateOrConnectWithoutPurchase_orderInput | GRNCreateOrConnectWithoutPurchase_orderInput[]
    upsert?: GRNUpsertWithWhereUniqueWithoutPurchase_orderInput | GRNUpsertWithWhereUniqueWithoutPurchase_orderInput[]
    createMany?: GRNCreateManyPurchase_orderInputEnvelope
    set?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
    disconnect?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
    delete?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
    connect?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
    update?: GRNUpdateWithWhereUniqueWithoutPurchase_orderInput | GRNUpdateWithWhereUniqueWithoutPurchase_orderInput[]
    updateMany?: GRNUpdateManyWithWhereWithoutPurchase_orderInput | GRNUpdateManyWithWhereWithoutPurchase_orderInput[]
    deleteMany?: GRNScalarWhereInput | GRNScalarWhereInput[]
  }

  export type VendorBillUpdateManyWithoutPurchase_orderNestedInput = {
    create?: XOR<VendorBillCreateWithoutPurchase_orderInput, VendorBillUncheckedCreateWithoutPurchase_orderInput> | VendorBillCreateWithoutPurchase_orderInput[] | VendorBillUncheckedCreateWithoutPurchase_orderInput[]
    connectOrCreate?: VendorBillCreateOrConnectWithoutPurchase_orderInput | VendorBillCreateOrConnectWithoutPurchase_orderInput[]
    upsert?: VendorBillUpsertWithWhereUniqueWithoutPurchase_orderInput | VendorBillUpsertWithWhereUniqueWithoutPurchase_orderInput[]
    createMany?: VendorBillCreateManyPurchase_orderInputEnvelope
    set?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    disconnect?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    delete?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    connect?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    update?: VendorBillUpdateWithWhereUniqueWithoutPurchase_orderInput | VendorBillUpdateWithWhereUniqueWithoutPurchase_orderInput[]
    updateMany?: VendorBillUpdateManyWithWhereWithoutPurchase_orderInput | VendorBillUpdateManyWithWhereWithoutPurchase_orderInput[]
    deleteMany?: VendorBillScalarWhereInput | VendorBillScalarWhereInput[]
  }

  export type GRNUncheckedUpdateManyWithoutPurchase_orderNestedInput = {
    create?: XOR<GRNCreateWithoutPurchase_orderInput, GRNUncheckedCreateWithoutPurchase_orderInput> | GRNCreateWithoutPurchase_orderInput[] | GRNUncheckedCreateWithoutPurchase_orderInput[]
    connectOrCreate?: GRNCreateOrConnectWithoutPurchase_orderInput | GRNCreateOrConnectWithoutPurchase_orderInput[]
    upsert?: GRNUpsertWithWhereUniqueWithoutPurchase_orderInput | GRNUpsertWithWhereUniqueWithoutPurchase_orderInput[]
    createMany?: GRNCreateManyPurchase_orderInputEnvelope
    set?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
    disconnect?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
    delete?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
    connect?: GRNWhereUniqueInput | GRNWhereUniqueInput[]
    update?: GRNUpdateWithWhereUniqueWithoutPurchase_orderInput | GRNUpdateWithWhereUniqueWithoutPurchase_orderInput[]
    updateMany?: GRNUpdateManyWithWhereWithoutPurchase_orderInput | GRNUpdateManyWithWhereWithoutPurchase_orderInput[]
    deleteMany?: GRNScalarWhereInput | GRNScalarWhereInput[]
  }

  export type VendorBillUncheckedUpdateManyWithoutPurchase_orderNestedInput = {
    create?: XOR<VendorBillCreateWithoutPurchase_orderInput, VendorBillUncheckedCreateWithoutPurchase_orderInput> | VendorBillCreateWithoutPurchase_orderInput[] | VendorBillUncheckedCreateWithoutPurchase_orderInput[]
    connectOrCreate?: VendorBillCreateOrConnectWithoutPurchase_orderInput | VendorBillCreateOrConnectWithoutPurchase_orderInput[]
    upsert?: VendorBillUpsertWithWhereUniqueWithoutPurchase_orderInput | VendorBillUpsertWithWhereUniqueWithoutPurchase_orderInput[]
    createMany?: VendorBillCreateManyPurchase_orderInputEnvelope
    set?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    disconnect?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    delete?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    connect?: VendorBillWhereUniqueInput | VendorBillWhereUniqueInput[]
    update?: VendorBillUpdateWithWhereUniqueWithoutPurchase_orderInput | VendorBillUpdateWithWhereUniqueWithoutPurchase_orderInput[]
    updateMany?: VendorBillUpdateManyWithWhereWithoutPurchase_orderInput | VendorBillUpdateManyWithWhereWithoutPurchase_orderInput[]
    deleteMany?: VendorBillScalarWhereInput | VendorBillScalarWhereInput[]
  }

  export type PurchaseOrderCreateNestedOneWithoutGrnsInput = {
    create?: XOR<PurchaseOrderCreateWithoutGrnsInput, PurchaseOrderUncheckedCreateWithoutGrnsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutGrnsInput
    connect?: PurchaseOrderWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutGrnsInput = {
    create?: XOR<UserCreateWithoutGrnsInput, UserUncheckedCreateWithoutGrnsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGrnsInput
    connect?: UserWhereUniqueInput
  }

  export type PurchaseOrderUpdateOneRequiredWithoutGrnsNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutGrnsInput, PurchaseOrderUncheckedCreateWithoutGrnsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutGrnsInput
    upsert?: PurchaseOrderUpsertWithoutGrnsInput
    connect?: PurchaseOrderWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderUpdateToOneWithWhereWithoutGrnsInput, PurchaseOrderUpdateWithoutGrnsInput>, PurchaseOrderUncheckedUpdateWithoutGrnsInput>
  }

  export type UserUpdateOneRequiredWithoutGrnsNestedInput = {
    create?: XOR<UserCreateWithoutGrnsInput, UserUncheckedCreateWithoutGrnsInput>
    connectOrCreate?: UserCreateOrConnectWithoutGrnsInput
    upsert?: UserUpsertWithoutGrnsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutGrnsInput, UserUpdateWithoutGrnsInput>, UserUncheckedUpdateWithoutGrnsInput>
  }

  export type PurchaseOrderCreateNestedOneWithoutVendor_billsInput = {
    create?: XOR<PurchaseOrderCreateWithoutVendor_billsInput, PurchaseOrderUncheckedCreateWithoutVendor_billsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutVendor_billsInput
    connect?: PurchaseOrderWhereUniqueInput
  }

  export type VendorCreateNestedOneWithoutVendor_billsInput = {
    create?: XOR<VendorCreateWithoutVendor_billsInput, VendorUncheckedCreateWithoutVendor_billsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutVendor_billsInput
    connect?: VendorWhereUniqueInput
  }

  export type VendorPaymentCreateNestedManyWithoutVendor_billInput = {
    create?: XOR<VendorPaymentCreateWithoutVendor_billInput, VendorPaymentUncheckedCreateWithoutVendor_billInput> | VendorPaymentCreateWithoutVendor_billInput[] | VendorPaymentUncheckedCreateWithoutVendor_billInput[]
    connectOrCreate?: VendorPaymentCreateOrConnectWithoutVendor_billInput | VendorPaymentCreateOrConnectWithoutVendor_billInput[]
    createMany?: VendorPaymentCreateManyVendor_billInputEnvelope
    connect?: VendorPaymentWhereUniqueInput | VendorPaymentWhereUniqueInput[]
  }

  export type VendorPaymentUncheckedCreateNestedManyWithoutVendor_billInput = {
    create?: XOR<VendorPaymentCreateWithoutVendor_billInput, VendorPaymentUncheckedCreateWithoutVendor_billInput> | VendorPaymentCreateWithoutVendor_billInput[] | VendorPaymentUncheckedCreateWithoutVendor_billInput[]
    connectOrCreate?: VendorPaymentCreateOrConnectWithoutVendor_billInput | VendorPaymentCreateOrConnectWithoutVendor_billInput[]
    createMany?: VendorPaymentCreateManyVendor_billInputEnvelope
    connect?: VendorPaymentWhereUniqueInput | VendorPaymentWhereUniqueInput[]
  }

  export type PurchaseOrderUpdateOneRequiredWithoutVendor_billsNestedInput = {
    create?: XOR<PurchaseOrderCreateWithoutVendor_billsInput, PurchaseOrderUncheckedCreateWithoutVendor_billsInput>
    connectOrCreate?: PurchaseOrderCreateOrConnectWithoutVendor_billsInput
    upsert?: PurchaseOrderUpsertWithoutVendor_billsInput
    connect?: PurchaseOrderWhereUniqueInput
    update?: XOR<XOR<PurchaseOrderUpdateToOneWithWhereWithoutVendor_billsInput, PurchaseOrderUpdateWithoutVendor_billsInput>, PurchaseOrderUncheckedUpdateWithoutVendor_billsInput>
  }

  export type VendorUpdateOneRequiredWithoutVendor_billsNestedInput = {
    create?: XOR<VendorCreateWithoutVendor_billsInput, VendorUncheckedCreateWithoutVendor_billsInput>
    connectOrCreate?: VendorCreateOrConnectWithoutVendor_billsInput
    upsert?: VendorUpsertWithoutVendor_billsInput
    connect?: VendorWhereUniqueInput
    update?: XOR<XOR<VendorUpdateToOneWithWhereWithoutVendor_billsInput, VendorUpdateWithoutVendor_billsInput>, VendorUncheckedUpdateWithoutVendor_billsInput>
  }

  export type VendorPaymentUpdateManyWithoutVendor_billNestedInput = {
    create?: XOR<VendorPaymentCreateWithoutVendor_billInput, VendorPaymentUncheckedCreateWithoutVendor_billInput> | VendorPaymentCreateWithoutVendor_billInput[] | VendorPaymentUncheckedCreateWithoutVendor_billInput[]
    connectOrCreate?: VendorPaymentCreateOrConnectWithoutVendor_billInput | VendorPaymentCreateOrConnectWithoutVendor_billInput[]
    upsert?: VendorPaymentUpsertWithWhereUniqueWithoutVendor_billInput | VendorPaymentUpsertWithWhereUniqueWithoutVendor_billInput[]
    createMany?: VendorPaymentCreateManyVendor_billInputEnvelope
    set?: VendorPaymentWhereUniqueInput | VendorPaymentWhereUniqueInput[]
    disconnect?: VendorPaymentWhereUniqueInput | VendorPaymentWhereUniqueInput[]
    delete?: VendorPaymentWhereUniqueInput | VendorPaymentWhereUniqueInput[]
    connect?: VendorPaymentWhereUniqueInput | VendorPaymentWhereUniqueInput[]
    update?: VendorPaymentUpdateWithWhereUniqueWithoutVendor_billInput | VendorPaymentUpdateWithWhereUniqueWithoutVendor_billInput[]
    updateMany?: VendorPaymentUpdateManyWithWhereWithoutVendor_billInput | VendorPaymentUpdateManyWithWhereWithoutVendor_billInput[]
    deleteMany?: VendorPaymentScalarWhereInput | VendorPaymentScalarWhereInput[]
  }

  export type VendorPaymentUncheckedUpdateManyWithoutVendor_billNestedInput = {
    create?: XOR<VendorPaymentCreateWithoutVendor_billInput, VendorPaymentUncheckedCreateWithoutVendor_billInput> | VendorPaymentCreateWithoutVendor_billInput[] | VendorPaymentUncheckedCreateWithoutVendor_billInput[]
    connectOrCreate?: VendorPaymentCreateOrConnectWithoutVendor_billInput | VendorPaymentCreateOrConnectWithoutVendor_billInput[]
    upsert?: VendorPaymentUpsertWithWhereUniqueWithoutVendor_billInput | VendorPaymentUpsertWithWhereUniqueWithoutVendor_billInput[]
    createMany?: VendorPaymentCreateManyVendor_billInputEnvelope
    set?: VendorPaymentWhereUniqueInput | VendorPaymentWhereUniqueInput[]
    disconnect?: VendorPaymentWhereUniqueInput | VendorPaymentWhereUniqueInput[]
    delete?: VendorPaymentWhereUniqueInput | VendorPaymentWhereUniqueInput[]
    connect?: VendorPaymentWhereUniqueInput | VendorPaymentWhereUniqueInput[]
    update?: VendorPaymentUpdateWithWhereUniqueWithoutVendor_billInput | VendorPaymentUpdateWithWhereUniqueWithoutVendor_billInput[]
    updateMany?: VendorPaymentUpdateManyWithWhereWithoutVendor_billInput | VendorPaymentUpdateManyWithWhereWithoutVendor_billInput[]
    deleteMany?: VendorPaymentScalarWhereInput | VendorPaymentScalarWhereInput[]
  }

  export type VendorBillCreateNestedOneWithoutVendor_paymentsInput = {
    create?: XOR<VendorBillCreateWithoutVendor_paymentsInput, VendorBillUncheckedCreateWithoutVendor_paymentsInput>
    connectOrCreate?: VendorBillCreateOrConnectWithoutVendor_paymentsInput
    connect?: VendorBillWhereUniqueInput
  }

  export type VendorBillUpdateOneRequiredWithoutVendor_paymentsNestedInput = {
    create?: XOR<VendorBillCreateWithoutVendor_paymentsInput, VendorBillUncheckedCreateWithoutVendor_paymentsInput>
    connectOrCreate?: VendorBillCreateOrConnectWithoutVendor_paymentsInput
    upsert?: VendorBillUpsertWithoutVendor_paymentsInput
    connect?: VendorBillWhereUniqueInput
    update?: XOR<XOR<VendorBillUpdateToOneWithWhereWithoutVendor_paymentsInput, VendorBillUpdateWithoutVendor_paymentsInput>, VendorBillUncheckedUpdateWithoutVendor_paymentsInput>
  }

  export type BankTransactionCreateNestedManyWithoutBank_accountInput = {
    create?: XOR<BankTransactionCreateWithoutBank_accountInput, BankTransactionUncheckedCreateWithoutBank_accountInput> | BankTransactionCreateWithoutBank_accountInput[] | BankTransactionUncheckedCreateWithoutBank_accountInput[]
    connectOrCreate?: BankTransactionCreateOrConnectWithoutBank_accountInput | BankTransactionCreateOrConnectWithoutBank_accountInput[]
    createMany?: BankTransactionCreateManyBank_accountInputEnvelope
    connect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
  }

  export type BankTransactionUncheckedCreateNestedManyWithoutBank_accountInput = {
    create?: XOR<BankTransactionCreateWithoutBank_accountInput, BankTransactionUncheckedCreateWithoutBank_accountInput> | BankTransactionCreateWithoutBank_accountInput[] | BankTransactionUncheckedCreateWithoutBank_accountInput[]
    connectOrCreate?: BankTransactionCreateOrConnectWithoutBank_accountInput | BankTransactionCreateOrConnectWithoutBank_accountInput[]
    createMany?: BankTransactionCreateManyBank_accountInputEnvelope
    connect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
  }

  export type BankTransactionUpdateManyWithoutBank_accountNestedInput = {
    create?: XOR<BankTransactionCreateWithoutBank_accountInput, BankTransactionUncheckedCreateWithoutBank_accountInput> | BankTransactionCreateWithoutBank_accountInput[] | BankTransactionUncheckedCreateWithoutBank_accountInput[]
    connectOrCreate?: BankTransactionCreateOrConnectWithoutBank_accountInput | BankTransactionCreateOrConnectWithoutBank_accountInput[]
    upsert?: BankTransactionUpsertWithWhereUniqueWithoutBank_accountInput | BankTransactionUpsertWithWhereUniqueWithoutBank_accountInput[]
    createMany?: BankTransactionCreateManyBank_accountInputEnvelope
    set?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    disconnect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    delete?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    connect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    update?: BankTransactionUpdateWithWhereUniqueWithoutBank_accountInput | BankTransactionUpdateWithWhereUniqueWithoutBank_accountInput[]
    updateMany?: BankTransactionUpdateManyWithWhereWithoutBank_accountInput | BankTransactionUpdateManyWithWhereWithoutBank_accountInput[]
    deleteMany?: BankTransactionScalarWhereInput | BankTransactionScalarWhereInput[]
  }

  export type BankTransactionUncheckedUpdateManyWithoutBank_accountNestedInput = {
    create?: XOR<BankTransactionCreateWithoutBank_accountInput, BankTransactionUncheckedCreateWithoutBank_accountInput> | BankTransactionCreateWithoutBank_accountInput[] | BankTransactionUncheckedCreateWithoutBank_accountInput[]
    connectOrCreate?: BankTransactionCreateOrConnectWithoutBank_accountInput | BankTransactionCreateOrConnectWithoutBank_accountInput[]
    upsert?: BankTransactionUpsertWithWhereUniqueWithoutBank_accountInput | BankTransactionUpsertWithWhereUniqueWithoutBank_accountInput[]
    createMany?: BankTransactionCreateManyBank_accountInputEnvelope
    set?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    disconnect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    delete?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    connect?: BankTransactionWhereUniqueInput | BankTransactionWhereUniqueInput[]
    update?: BankTransactionUpdateWithWhereUniqueWithoutBank_accountInput | BankTransactionUpdateWithWhereUniqueWithoutBank_accountInput[]
    updateMany?: BankTransactionUpdateManyWithWhereWithoutBank_accountInput | BankTransactionUpdateManyWithWhereWithoutBank_accountInput[]
    deleteMany?: BankTransactionScalarWhereInput | BankTransactionScalarWhereInput[]
  }

  export type BankAccountCreateNestedOneWithoutTransactionsInput = {
    create?: XOR<BankAccountCreateWithoutTransactionsInput, BankAccountUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: BankAccountCreateOrConnectWithoutTransactionsInput
    connect?: BankAccountWhereUniqueInput
  }

  export type BankAccountUpdateOneRequiredWithoutTransactionsNestedInput = {
    create?: XOR<BankAccountCreateWithoutTransactionsInput, BankAccountUncheckedCreateWithoutTransactionsInput>
    connectOrCreate?: BankAccountCreateOrConnectWithoutTransactionsInput
    upsert?: BankAccountUpsertWithoutTransactionsInput
    connect?: BankAccountWhereUniqueInput
    update?: XOR<XOR<BankAccountUpdateToOneWithWhereWithoutTransactionsInput, BankAccountUpdateWithoutTransactionsInput>, BankAccountUncheckedUpdateWithoutTransactionsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedEnumUserRoleFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleFilter<$PrismaModel> | $Enums.UserRole
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumUserRoleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.UserRole | EnumUserRoleFieldRefInput<$PrismaModel>
    in?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    notIn?: $Enums.UserRole[] | ListEnumUserRoleFieldRefInput<$PrismaModel>
    not?: NestedEnumUserRoleWithAggregatesFilter<$PrismaModel> | $Enums.UserRole
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumUserRoleFilter<$PrismaModel>
    _max?: NestedEnumUserRoleFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumProjectStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusFilter<$PrismaModel> | $Enums.ProjectStatus
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ProjectStatus | EnumProjectStatusFieldRefInput<$PrismaModel>
    in?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.ProjectStatus[] | ListEnumProjectStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumProjectStatusWithAggregatesFilter<$PrismaModel> | $Enums.ProjectStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumProjectStatusFilter<$PrismaModel>
    _max?: NestedEnumProjectStatusFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumFileTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeFilter<$PrismaModel> | $Enums.FileType
  }

  export type NestedBigIntFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntFilter<$PrismaModel> | bigint | number
  }

  export type NestedEnumFileTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeWithAggregatesFilter<$PrismaModel> | $Enums.FileType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileTypeFilter<$PrismaModel>
    _max?: NestedEnumFileTypeFilter<$PrismaModel>
  }

  export type NestedBigIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    in?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    notIn?: bigint[] | number[] | ListBigIntFieldRefInput<$PrismaModel>
    lt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    lte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gt?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    gte?: bigint | number | BigIntFieldRefInput<$PrismaModel>
    not?: NestedBigIntWithAggregatesFilter<$PrismaModel> | bigint | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedBigIntFilter<$PrismaModel>
    _min?: NestedBigIntFilter<$PrismaModel>
    _max?: NestedBigIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedEnumSupportStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.SupportStatus | EnumSupportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SupportStatus[] | ListEnumSupportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SupportStatus[] | ListEnumSupportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSupportStatusFilter<$PrismaModel> | $Enums.SupportStatus
  }

  export type NestedEnumPriorityLevelFilter<$PrismaModel = never> = {
    equals?: $Enums.PriorityLevel | EnumPriorityLevelFieldRefInput<$PrismaModel>
    in?: $Enums.PriorityLevel[] | ListEnumPriorityLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PriorityLevel[] | ListEnumPriorityLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityLevelFilter<$PrismaModel> | $Enums.PriorityLevel
  }

  export type NestedEnumSupportStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.SupportStatus | EnumSupportStatusFieldRefInput<$PrismaModel>
    in?: $Enums.SupportStatus[] | ListEnumSupportStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.SupportStatus[] | ListEnumSupportStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumSupportStatusWithAggregatesFilter<$PrismaModel> | $Enums.SupportStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumSupportStatusFilter<$PrismaModel>
    _max?: NestedEnumSupportStatusFilter<$PrismaModel>
  }

  export type NestedEnumPriorityLevelWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PriorityLevel | EnumPriorityLevelFieldRefInput<$PrismaModel>
    in?: $Enums.PriorityLevel[] | ListEnumPriorityLevelFieldRefInput<$PrismaModel>
    notIn?: $Enums.PriorityLevel[] | ListEnumPriorityLevelFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityLevelWithAggregatesFilter<$PrismaModel> | $Enums.PriorityLevel
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityLevelFilter<$PrismaModel>
    _max?: NestedEnumPriorityLevelFilter<$PrismaModel>
  }

  export type NestedEnumMeetingStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MeetingStatus | EnumMeetingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MeetingStatus[] | ListEnumMeetingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeetingStatus[] | ListEnumMeetingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMeetingStatusFilter<$PrismaModel> | $Enums.MeetingStatus
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedEnumMeetingStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MeetingStatus | EnumMeetingStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MeetingStatus[] | ListEnumMeetingStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MeetingStatus[] | ListEnumMeetingStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMeetingStatusWithAggregatesFilter<$PrismaModel> | $Enums.MeetingStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMeetingStatusFilter<$PrismaModel>
    _max?: NestedEnumMeetingStatusFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumInvoiceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusFilter<$PrismaModel> | $Enums.InvoiceStatus
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InvoiceStatus | EnumInvoiceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.InvoiceStatus[] | ListEnumInvoiceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumInvoiceStatusWithAggregatesFilter<$PrismaModel> | $Enums.InvoiceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInvoiceStatusFilter<$PrismaModel>
    _max?: NestedEnumInvoiceStatusFilter<$PrismaModel>
  }

  export type NestedEnumMemberStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberStatus | EnumMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberStatusFilter<$PrismaModel> | $Enums.MemberStatus
  }

  export type NestedEnumMemberStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.MemberStatus | EnumMemberStatusFieldRefInput<$PrismaModel>
    in?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.MemberStatus[] | ListEnumMemberStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumMemberStatusWithAggregatesFilter<$PrismaModel> | $Enums.MemberStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumMemberStatusFilter<$PrismaModel>
    _max?: NestedEnumMemberStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }
  export type NestedJsonFilter<$PrismaModel = never> =
    | PatchUndefined<
        Either<Required<NestedJsonFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    mode?: QueryMode | EnumQueryModeFieldRefInput<$PrismaModel>
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeFilter<$PrismaModel> | $Enums.TransactionType
  }

  export type NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TransactionType | EnumTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.TransactionType[] | ListEnumTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.TransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumTransactionTypeFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumInventoryTransactionTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryTransactionType | EnumInventoryTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryTransactionType[] | ListEnumInventoryTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryTransactionType[] | ListEnumInventoryTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryTransactionTypeFilter<$PrismaModel> | $Enums.InventoryTransactionType
  }

  export type NestedEnumInventoryTransactionTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.InventoryTransactionType | EnumInventoryTransactionTypeFieldRefInput<$PrismaModel>
    in?: $Enums.InventoryTransactionType[] | ListEnumInventoryTransactionTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.InventoryTransactionType[] | ListEnumInventoryTransactionTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumInventoryTransactionTypeWithAggregatesFilter<$PrismaModel> | $Enums.InventoryTransactionType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumInventoryTransactionTypeFilter<$PrismaModel>
    _max?: NestedEnumInventoryTransactionTypeFilter<$PrismaModel>
  }

  export type NestedEnumPurchaseStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseStatus | EnumPurchaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseStatusFilter<$PrismaModel> | $Enums.PurchaseStatus
  }

  export type NestedEnumPurchaseStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PurchaseStatus | EnumPurchaseStatusFieldRefInput<$PrismaModel>
    in?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.PurchaseStatus[] | ListEnumPurchaseStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumPurchaseStatusWithAggregatesFilter<$PrismaModel> | $Enums.PurchaseStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPurchaseStatusFilter<$PrismaModel>
    _max?: NestedEnumPurchaseStatusFilter<$PrismaModel>
  }

  export type ProjectCreateWithoutClientInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.ProjectStatus
    github_link?: string | null
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    actual_cost?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    test_asset_url?: string | null
    deployment_url?: string | null
    live_preview_type?: string | null
    live_preview_url?: string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectCreatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    files?: ProjectFileCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateCreateNestedManyWithoutProjectInput
    support_requests?: SupportRequestCreateNestedManyWithoutProjectInput
    meeting_requests?: MeetingRequestCreateNestedManyWithoutProjectInput
    invoices?: InvoiceCreateNestedManyWithoutProjectInput
    inventory_logs?: InventoryTransactionCreateNestedManyWithoutProjectInput
    purchase_requests?: PurchaseRequestCreateNestedManyWithoutProjectInput
    attendance?: AttendanceCreateNestedManyWithoutProjectInput
    labour_allocations?: LabourAllocationCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutClientInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.ProjectStatus
    github_link?: string | null
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    actual_cost?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    test_asset_url?: string | null
    deployment_url?: string | null
    live_preview_type?: string | null
    live_preview_url?: string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectCreatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    files?: ProjectFileUncheckedCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput
    support_requests?: SupportRequestUncheckedCreateNestedManyWithoutProjectInput
    meeting_requests?: MeetingRequestUncheckedCreateNestedManyWithoutProjectInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutProjectInput
    inventory_logs?: InventoryTransactionUncheckedCreateNestedManyWithoutProjectInput
    purchase_requests?: PurchaseRequestUncheckedCreateNestedManyWithoutProjectInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutProjectInput
    labour_allocations?: LabourAllocationUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutClientInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput>
  }

  export type ProjectCreateManyClientInputEnvelope = {
    data: ProjectCreateManyClientInput | ProjectCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type ProjectFileCreateWithoutUploaderInput = {
    id?: string
    file_name: string
    file_url: string
    file_type?: $Enums.FileType
    file_size: bigint | number
    created_at?: Date | string
    project: ProjectCreateNestedOneWithoutFilesInput
  }

  export type ProjectFileUncheckedCreateWithoutUploaderInput = {
    id?: string
    project_id: string
    file_name: string
    file_url: string
    file_type?: $Enums.FileType
    file_size: bigint | number
    created_at?: Date | string
  }

  export type ProjectFileCreateOrConnectWithoutUploaderInput = {
    where: ProjectFileWhereUniqueInput
    create: XOR<ProjectFileCreateWithoutUploaderInput, ProjectFileUncheckedCreateWithoutUploaderInput>
  }

  export type ProjectFileCreateManyUploaderInputEnvelope = {
    data: ProjectFileCreateManyUploaderInput | ProjectFileCreateManyUploaderInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpdateCreateWithoutAuthorInput = {
    id?: string
    update_text: string
    created_at?: Date | string
    project: ProjectCreateNestedOneWithoutUpdatesInput
  }

  export type ProjectUpdateUncheckedCreateWithoutAuthorInput = {
    id?: string
    project_id: string
    update_text: string
    created_at?: Date | string
  }

  export type ProjectUpdateCreateOrConnectWithoutAuthorInput = {
    where: ProjectUpdateWhereUniqueInput
    create: XOR<ProjectUpdateCreateWithoutAuthorInput, ProjectUpdateUncheckedCreateWithoutAuthorInput>
  }

  export type ProjectUpdateCreateManyAuthorInputEnvelope = {
    data: ProjectUpdateCreateManyAuthorInput | ProjectUpdateCreateManyAuthorInput[]
    skipDuplicates?: boolean
  }

  export type SupportRequestCreateWithoutClientInput = {
    id?: string
    subject: string
    description: string
    status?: $Enums.SupportStatus
    priority?: $Enums.PriorityLevel
    created_at?: Date | string
    updated_at?: Date | string
    project?: ProjectCreateNestedOneWithoutSupport_requestsInput
    messages?: SupportMessageCreateNestedManyWithoutRequestInput
  }

  export type SupportRequestUncheckedCreateWithoutClientInput = {
    id?: string
    project_id?: string | null
    subject: string
    description: string
    status?: $Enums.SupportStatus
    priority?: $Enums.PriorityLevel
    created_at?: Date | string
    updated_at?: Date | string
    messages?: SupportMessageUncheckedCreateNestedManyWithoutRequestInput
  }

  export type SupportRequestCreateOrConnectWithoutClientInput = {
    where: SupportRequestWhereUniqueInput
    create: XOR<SupportRequestCreateWithoutClientInput, SupportRequestUncheckedCreateWithoutClientInput>
  }

  export type SupportRequestCreateManyClientInputEnvelope = {
    data: SupportRequestCreateManyClientInput | SupportRequestCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type SupportMessageCreateWithoutSenderInput = {
    id?: string
    message: string
    created_at?: Date | string
    request: SupportRequestCreateNestedOneWithoutMessagesInput
  }

  export type SupportMessageUncheckedCreateWithoutSenderInput = {
    id?: string
    support_request_id: string
    message: string
    created_at?: Date | string
  }

  export type SupportMessageCreateOrConnectWithoutSenderInput = {
    where: SupportMessageWhereUniqueInput
    create: XOR<SupportMessageCreateWithoutSenderInput, SupportMessageUncheckedCreateWithoutSenderInput>
  }

  export type SupportMessageCreateManySenderInputEnvelope = {
    data: SupportMessageCreateManySenderInput | SupportMessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type MeetingRequestCreateWithoutClientInput = {
    id?: string
    requested_date: Date | string
    duration_minutes?: number
    purpose: string
    status?: $Enums.MeetingStatus
    meeting_link?: string | null
    admin_notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project?: ProjectCreateNestedOneWithoutMeeting_requestsInput
  }

  export type MeetingRequestUncheckedCreateWithoutClientInput = {
    id?: string
    project_id?: string | null
    requested_date: Date | string
    duration_minutes?: number
    purpose: string
    status?: $Enums.MeetingStatus
    meeting_link?: string | null
    admin_notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MeetingRequestCreateOrConnectWithoutClientInput = {
    where: MeetingRequestWhereUniqueInput
    create: XOR<MeetingRequestCreateWithoutClientInput, MeetingRequestUncheckedCreateWithoutClientInput>
  }

  export type MeetingRequestCreateManyClientInputEnvelope = {
    data: MeetingRequestCreateManyClientInput | MeetingRequestCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutClientInput = {
    id?: string
    invoice_number: string
    amount: Decimal | DecimalJsLike | number | string
    due_date: Date | string
    status?: $Enums.InvoiceStatus
    payment_qr_url?: string | null
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    paid_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: ProjectCreateNestedOneWithoutInvoicesInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutClientInput = {
    id?: string
    project_id: string
    invoice_number: string
    amount: Decimal | DecimalJsLike | number | string
    due_date: Date | string
    status?: $Enums.InvoiceStatus
    payment_qr_url?: string | null
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    paid_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutClientInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput>
  }

  export type InvoiceCreateManyClientInputEnvelope = {
    data: InvoiceCreateManyClientInput | InvoiceCreateManyClientInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type?: $Enums.NotificationType
    link?: string | null
    read?: boolean
    created_at?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    message: string
    type?: $Enums.NotificationType
    link?: string | null
    read?: boolean
    created_at?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TransactionCreateWithoutCreatorInput = {
    id?: string
    type: $Enums.TransactionType
    category: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    date: Date | string
    description?: string | null
    notes?: string | null
    payment_method?: string | null
    reference_number?: string | null
    attachment_url?: string | null
    tax_rate_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TransactionUncheckedCreateWithoutCreatorInput = {
    id?: string
    type: $Enums.TransactionType
    category: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    date: Date | string
    description?: string | null
    notes?: string | null
    payment_method?: string | null
    reference_number?: string | null
    attachment_url?: string | null
    tax_rate_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type TransactionCreateOrConnectWithoutCreatorInput = {
    where: TransactionWhereUniqueInput
    create: XOR<TransactionCreateWithoutCreatorInput, TransactionUncheckedCreateWithoutCreatorInput>
  }

  export type TransactionCreateManyCreatorInputEnvelope = {
    data: TransactionCreateManyCreatorInput | TransactionCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type InventoryTransactionCreateWithoutUserInput = {
    id?: string
    type: $Enums.InventoryTransactionType
    quantity: number
    date?: Date | string
    reference_no?: string | null
    notes?: string | null
    created_at?: Date | string
    item: InventoryItemCreateNestedOneWithoutTransactionsInput
    project?: ProjectCreateNestedOneWithoutInventory_logsInput
  }

  export type InventoryTransactionUncheckedCreateWithoutUserInput = {
    id?: string
    item_id: string
    project_id?: string | null
    type: $Enums.InventoryTransactionType
    quantity: number
    date?: Date | string
    reference_no?: string | null
    notes?: string | null
    created_at?: Date | string
  }

  export type InventoryTransactionCreateOrConnectWithoutUserInput = {
    where: InventoryTransactionWhereUniqueInput
    create: XOR<InventoryTransactionCreateWithoutUserInput, InventoryTransactionUncheckedCreateWithoutUserInput>
  }

  export type InventoryTransactionCreateManyUserInputEnvelope = {
    data: InventoryTransactionCreateManyUserInput | InventoryTransactionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseRequestCreateWithoutRequesterInput = {
    id?: string
    item_name: string
    quantity: number
    unit: string
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    priority?: $Enums.PriorityLevel
    status?: $Enums.PurchaseStatus
    needed_by?: Date | string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project?: ProjectCreateNestedOneWithoutPurchase_requestsInput
    purchase_orders?: PurchaseOrderCreateNestedManyWithoutPurchase_requestInput
  }

  export type PurchaseRequestUncheckedCreateWithoutRequesterInput = {
    id?: string
    project_id?: string | null
    item_name: string
    quantity: number
    unit: string
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    priority?: $Enums.PriorityLevel
    status?: $Enums.PurchaseStatus
    needed_by?: Date | string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    purchase_orders?: PurchaseOrderUncheckedCreateNestedManyWithoutPurchase_requestInput
  }

  export type PurchaseRequestCreateOrConnectWithoutRequesterInput = {
    where: PurchaseRequestWhereUniqueInput
    create: XOR<PurchaseRequestCreateWithoutRequesterInput, PurchaseRequestUncheckedCreateWithoutRequesterInput>
  }

  export type PurchaseRequestCreateManyRequesterInputEnvelope = {
    data: PurchaseRequestCreateManyRequesterInput | PurchaseRequestCreateManyRequesterInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderCreateWithoutCreatorInput = {
    id?: string
    po_number: string
    total_amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.PurchaseStatus
    created_at?: Date | string
    updated_at?: Date | string
    purchase_request?: PurchaseRequestCreateNestedOneWithoutPurchase_ordersInput
    vendor: VendorCreateNestedOneWithoutPurchase_ordersInput
    grns?: GRNCreateNestedManyWithoutPurchase_orderInput
    vendor_bills?: VendorBillCreateNestedManyWithoutPurchase_orderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutCreatorInput = {
    id?: string
    po_number: string
    purchase_request_id?: string | null
    vendor_id: string
    total_amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.PurchaseStatus
    created_at?: Date | string
    updated_at?: Date | string
    grns?: GRNUncheckedCreateNestedManyWithoutPurchase_orderInput
    vendor_bills?: VendorBillUncheckedCreateNestedManyWithoutPurchase_orderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutCreatorInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutCreatorInput, PurchaseOrderUncheckedCreateWithoutCreatorInput>
  }

  export type PurchaseOrderCreateManyCreatorInputEnvelope = {
    data: PurchaseOrderCreateManyCreatorInput | PurchaseOrderCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type GRNCreateWithoutReceiverInput = {
    id?: string
    grn_number: string
    received_date?: Date | string
    notes?: string | null
    created_at?: Date | string
    purchase_order: PurchaseOrderCreateNestedOneWithoutGrnsInput
  }

  export type GRNUncheckedCreateWithoutReceiverInput = {
    id?: string
    grn_number: string
    purchase_order_id: string
    received_date?: Date | string
    notes?: string | null
    created_at?: Date | string
  }

  export type GRNCreateOrConnectWithoutReceiverInput = {
    where: GRNWhereUniqueInput
    create: XOR<GRNCreateWithoutReceiverInput, GRNUncheckedCreateWithoutReceiverInput>
  }

  export type GRNCreateManyReceiverInputEnvelope = {
    data: GRNCreateManyReceiverInput | GRNCreateManyReceiverInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithWhereUniqueWithoutClientInput = {
    where: ProjectWhereUniqueInput
    update: XOR<ProjectUpdateWithoutClientInput, ProjectUncheckedUpdateWithoutClientInput>
    create: XOR<ProjectCreateWithoutClientInput, ProjectUncheckedCreateWithoutClientInput>
  }

  export type ProjectUpdateWithWhereUniqueWithoutClientInput = {
    where: ProjectWhereUniqueInput
    data: XOR<ProjectUpdateWithoutClientInput, ProjectUncheckedUpdateWithoutClientInput>
  }

  export type ProjectUpdateManyWithWhereWithoutClientInput = {
    where: ProjectScalarWhereInput
    data: XOR<ProjectUpdateManyMutationInput, ProjectUncheckedUpdateManyWithoutClientInput>
  }

  export type ProjectScalarWhereInput = {
    AND?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    OR?: ProjectScalarWhereInput[]
    NOT?: ProjectScalarWhereInput | ProjectScalarWhereInput[]
    id?: StringFilter<"Project"> | string
    client_id?: StringFilter<"Project"> | string
    title?: StringFilter<"Project"> | string
    description?: StringFilter<"Project"> | string
    status?: EnumProjectStatusFilter<"Project"> | $Enums.ProjectStatus
    github_link?: StringNullableFilter<"Project"> | string | null
    estimated_cost?: DecimalNullableFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
    actual_cost?: DecimalNullableFilter<"Project"> | Decimal | DecimalJsLike | number | string | null
    deadline?: DateTimeNullableFilter<"Project"> | Date | string | null
    test_asset_url?: StringNullableFilter<"Project"> | string | null
    deployment_url?: StringNullableFilter<"Project"> | string | null
    live_preview_type?: StringNullableFilter<"Project"> | string | null
    live_preview_url?: StringNullableFilter<"Project"> | string | null
    technical_config?: JsonNullableFilter<"Project">
    tickets?: JsonNullableFilter<"Project">
    notes?: StringNullableListFilter<"Project">
    labour_data?: JsonNullableFilter<"Project">
    inventory_data?: JsonNullableFilter<"Project">
    resources_data?: JsonNullableFilter<"Project">
    design_data?: JsonNullableFilter<"Project">
    expenses_data?: JsonNullableFilter<"Project">
    timeline_data?: JsonNullableFilter<"Project">
    is_featured?: BoolFilter<"Project"> | boolean
    created_at?: DateTimeFilter<"Project"> | Date | string
    updated_at?: DateTimeFilter<"Project"> | Date | string
  }

  export type ProjectFileUpsertWithWhereUniqueWithoutUploaderInput = {
    where: ProjectFileWhereUniqueInput
    update: XOR<ProjectFileUpdateWithoutUploaderInput, ProjectFileUncheckedUpdateWithoutUploaderInput>
    create: XOR<ProjectFileCreateWithoutUploaderInput, ProjectFileUncheckedCreateWithoutUploaderInput>
  }

  export type ProjectFileUpdateWithWhereUniqueWithoutUploaderInput = {
    where: ProjectFileWhereUniqueInput
    data: XOR<ProjectFileUpdateWithoutUploaderInput, ProjectFileUncheckedUpdateWithoutUploaderInput>
  }

  export type ProjectFileUpdateManyWithWhereWithoutUploaderInput = {
    where: ProjectFileScalarWhereInput
    data: XOR<ProjectFileUpdateManyMutationInput, ProjectFileUncheckedUpdateManyWithoutUploaderInput>
  }

  export type ProjectFileScalarWhereInput = {
    AND?: ProjectFileScalarWhereInput | ProjectFileScalarWhereInput[]
    OR?: ProjectFileScalarWhereInput[]
    NOT?: ProjectFileScalarWhereInput | ProjectFileScalarWhereInput[]
    id?: StringFilter<"ProjectFile"> | string
    project_id?: StringFilter<"ProjectFile"> | string
    file_name?: StringFilter<"ProjectFile"> | string
    file_url?: StringFilter<"ProjectFile"> | string
    file_type?: EnumFileTypeFilter<"ProjectFile"> | $Enums.FileType
    file_size?: BigIntFilter<"ProjectFile"> | bigint | number
    uploaded_by?: StringFilter<"ProjectFile"> | string
    created_at?: DateTimeFilter<"ProjectFile"> | Date | string
  }

  export type ProjectUpdateUpsertWithWhereUniqueWithoutAuthorInput = {
    where: ProjectUpdateWhereUniqueInput
    update: XOR<ProjectUpdateUpdateWithoutAuthorInput, ProjectUpdateUncheckedUpdateWithoutAuthorInput>
    create: XOR<ProjectUpdateCreateWithoutAuthorInput, ProjectUpdateUncheckedCreateWithoutAuthorInput>
  }

  export type ProjectUpdateUpdateWithWhereUniqueWithoutAuthorInput = {
    where: ProjectUpdateWhereUniqueInput
    data: XOR<ProjectUpdateUpdateWithoutAuthorInput, ProjectUpdateUncheckedUpdateWithoutAuthorInput>
  }

  export type ProjectUpdateUpdateManyWithWhereWithoutAuthorInput = {
    where: ProjectUpdateScalarWhereInput
    data: XOR<ProjectUpdateUpdateManyMutationInput, ProjectUpdateUncheckedUpdateManyWithoutAuthorInput>
  }

  export type ProjectUpdateScalarWhereInput = {
    AND?: ProjectUpdateScalarWhereInput | ProjectUpdateScalarWhereInput[]
    OR?: ProjectUpdateScalarWhereInput[]
    NOT?: ProjectUpdateScalarWhereInput | ProjectUpdateScalarWhereInput[]
    id?: StringFilter<"ProjectUpdate"> | string
    project_id?: StringFilter<"ProjectUpdate"> | string
    update_text?: StringFilter<"ProjectUpdate"> | string
    created_by?: StringFilter<"ProjectUpdate"> | string
    created_at?: DateTimeFilter<"ProjectUpdate"> | Date | string
  }

  export type SupportRequestUpsertWithWhereUniqueWithoutClientInput = {
    where: SupportRequestWhereUniqueInput
    update: XOR<SupportRequestUpdateWithoutClientInput, SupportRequestUncheckedUpdateWithoutClientInput>
    create: XOR<SupportRequestCreateWithoutClientInput, SupportRequestUncheckedCreateWithoutClientInput>
  }

  export type SupportRequestUpdateWithWhereUniqueWithoutClientInput = {
    where: SupportRequestWhereUniqueInput
    data: XOR<SupportRequestUpdateWithoutClientInput, SupportRequestUncheckedUpdateWithoutClientInput>
  }

  export type SupportRequestUpdateManyWithWhereWithoutClientInput = {
    where: SupportRequestScalarWhereInput
    data: XOR<SupportRequestUpdateManyMutationInput, SupportRequestUncheckedUpdateManyWithoutClientInput>
  }

  export type SupportRequestScalarWhereInput = {
    AND?: SupportRequestScalarWhereInput | SupportRequestScalarWhereInput[]
    OR?: SupportRequestScalarWhereInput[]
    NOT?: SupportRequestScalarWhereInput | SupportRequestScalarWhereInput[]
    id?: StringFilter<"SupportRequest"> | string
    project_id?: StringNullableFilter<"SupportRequest"> | string | null
    client_id?: StringFilter<"SupportRequest"> | string
    subject?: StringFilter<"SupportRequest"> | string
    description?: StringFilter<"SupportRequest"> | string
    status?: EnumSupportStatusFilter<"SupportRequest"> | $Enums.SupportStatus
    priority?: EnumPriorityLevelFilter<"SupportRequest"> | $Enums.PriorityLevel
    created_at?: DateTimeFilter<"SupportRequest"> | Date | string
    updated_at?: DateTimeFilter<"SupportRequest"> | Date | string
  }

  export type SupportMessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: SupportMessageWhereUniqueInput
    update: XOR<SupportMessageUpdateWithoutSenderInput, SupportMessageUncheckedUpdateWithoutSenderInput>
    create: XOR<SupportMessageCreateWithoutSenderInput, SupportMessageUncheckedCreateWithoutSenderInput>
  }

  export type SupportMessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: SupportMessageWhereUniqueInput
    data: XOR<SupportMessageUpdateWithoutSenderInput, SupportMessageUncheckedUpdateWithoutSenderInput>
  }

  export type SupportMessageUpdateManyWithWhereWithoutSenderInput = {
    where: SupportMessageScalarWhereInput
    data: XOR<SupportMessageUpdateManyMutationInput, SupportMessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type SupportMessageScalarWhereInput = {
    AND?: SupportMessageScalarWhereInput | SupportMessageScalarWhereInput[]
    OR?: SupportMessageScalarWhereInput[]
    NOT?: SupportMessageScalarWhereInput | SupportMessageScalarWhereInput[]
    id?: StringFilter<"SupportMessage"> | string
    support_request_id?: StringFilter<"SupportMessage"> | string
    user_id?: StringFilter<"SupportMessage"> | string
    message?: StringFilter<"SupportMessage"> | string
    created_at?: DateTimeFilter<"SupportMessage"> | Date | string
  }

  export type MeetingRequestUpsertWithWhereUniqueWithoutClientInput = {
    where: MeetingRequestWhereUniqueInput
    update: XOR<MeetingRequestUpdateWithoutClientInput, MeetingRequestUncheckedUpdateWithoutClientInput>
    create: XOR<MeetingRequestCreateWithoutClientInput, MeetingRequestUncheckedCreateWithoutClientInput>
  }

  export type MeetingRequestUpdateWithWhereUniqueWithoutClientInput = {
    where: MeetingRequestWhereUniqueInput
    data: XOR<MeetingRequestUpdateWithoutClientInput, MeetingRequestUncheckedUpdateWithoutClientInput>
  }

  export type MeetingRequestUpdateManyWithWhereWithoutClientInput = {
    where: MeetingRequestScalarWhereInput
    data: XOR<MeetingRequestUpdateManyMutationInput, MeetingRequestUncheckedUpdateManyWithoutClientInput>
  }

  export type MeetingRequestScalarWhereInput = {
    AND?: MeetingRequestScalarWhereInput | MeetingRequestScalarWhereInput[]
    OR?: MeetingRequestScalarWhereInput[]
    NOT?: MeetingRequestScalarWhereInput | MeetingRequestScalarWhereInput[]
    id?: StringFilter<"MeetingRequest"> | string
    project_id?: StringNullableFilter<"MeetingRequest"> | string | null
    client_id?: StringFilter<"MeetingRequest"> | string
    requested_date?: DateTimeFilter<"MeetingRequest"> | Date | string
    duration_minutes?: IntFilter<"MeetingRequest"> | number
    purpose?: StringFilter<"MeetingRequest"> | string
    status?: EnumMeetingStatusFilter<"MeetingRequest"> | $Enums.MeetingStatus
    meeting_link?: StringNullableFilter<"MeetingRequest"> | string | null
    admin_notes?: StringNullableFilter<"MeetingRequest"> | string | null
    created_at?: DateTimeFilter<"MeetingRequest"> | Date | string
    updated_at?: DateTimeFilter<"MeetingRequest"> | Date | string
  }

  export type InvoiceUpsertWithWhereUniqueWithoutClientInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutClientInput, InvoiceUncheckedUpdateWithoutClientInput>
    create: XOR<InvoiceCreateWithoutClientInput, InvoiceUncheckedCreateWithoutClientInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutClientInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutClientInput, InvoiceUncheckedUpdateWithoutClientInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutClientInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutClientInput>
  }

  export type InvoiceScalarWhereInput = {
    AND?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    OR?: InvoiceScalarWhereInput[]
    NOT?: InvoiceScalarWhereInput | InvoiceScalarWhereInput[]
    id?: StringFilter<"Invoice"> | string
    project_id?: StringFilter<"Invoice"> | string
    client_id?: StringFilter<"Invoice"> | string
    invoice_number?: StringFilter<"Invoice"> | string
    amount?: DecimalFilter<"Invoice"> | Decimal | DecimalJsLike | number | string
    due_date?: DateTimeFilter<"Invoice"> | Date | string
    status?: EnumInvoiceStatusFilter<"Invoice"> | $Enums.InvoiceStatus
    payment_qr_url?: StringNullableFilter<"Invoice"> | string | null
    bank_details?: JsonNullableFilter<"Invoice">
    paid_at?: DateTimeNullableFilter<"Invoice"> | Date | string | null
    created_at?: DateTimeFilter<"Invoice"> | Date | string
    updated_at?: DateTimeFilter<"Invoice"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    user_id?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    link?: StringNullableFilter<"Notification"> | string | null
    read?: BoolFilter<"Notification"> | boolean
    created_at?: DateTimeFilter<"Notification"> | Date | string
  }

  export type TransactionUpsertWithWhereUniqueWithoutCreatorInput = {
    where: TransactionWhereUniqueInput
    update: XOR<TransactionUpdateWithoutCreatorInput, TransactionUncheckedUpdateWithoutCreatorInput>
    create: XOR<TransactionCreateWithoutCreatorInput, TransactionUncheckedCreateWithoutCreatorInput>
  }

  export type TransactionUpdateWithWhereUniqueWithoutCreatorInput = {
    where: TransactionWhereUniqueInput
    data: XOR<TransactionUpdateWithoutCreatorInput, TransactionUncheckedUpdateWithoutCreatorInput>
  }

  export type TransactionUpdateManyWithWhereWithoutCreatorInput = {
    where: TransactionScalarWhereInput
    data: XOR<TransactionUpdateManyMutationInput, TransactionUncheckedUpdateManyWithoutCreatorInput>
  }

  export type TransactionScalarWhereInput = {
    AND?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    OR?: TransactionScalarWhereInput[]
    NOT?: TransactionScalarWhereInput | TransactionScalarWhereInput[]
    id?: StringFilter<"Transaction"> | string
    type?: EnumTransactionTypeFilter<"Transaction"> | $Enums.TransactionType
    category?: StringFilter<"Transaction"> | string
    amount?: DecimalFilter<"Transaction"> | Decimal | DecimalJsLike | number | string
    currency?: StringFilter<"Transaction"> | string
    exchange_rate?: DecimalNullableFilter<"Transaction"> | Decimal | DecimalJsLike | number | string | null
    date?: DateTimeFilter<"Transaction"> | Date | string
    description?: StringNullableFilter<"Transaction"> | string | null
    notes?: StringNullableFilter<"Transaction"> | string | null
    payment_method?: StringNullableFilter<"Transaction"> | string | null
    reference_number?: StringNullableFilter<"Transaction"> | string | null
    attachment_url?: StringNullableFilter<"Transaction"> | string | null
    tax_rate_id?: StringNullableFilter<"Transaction"> | string | null
    created_by?: StringFilter<"Transaction"> | string
    created_at?: DateTimeFilter<"Transaction"> | Date | string
    updated_at?: DateTimeFilter<"Transaction"> | Date | string
  }

  export type InventoryTransactionUpsertWithWhereUniqueWithoutUserInput = {
    where: InventoryTransactionWhereUniqueInput
    update: XOR<InventoryTransactionUpdateWithoutUserInput, InventoryTransactionUncheckedUpdateWithoutUserInput>
    create: XOR<InventoryTransactionCreateWithoutUserInput, InventoryTransactionUncheckedCreateWithoutUserInput>
  }

  export type InventoryTransactionUpdateWithWhereUniqueWithoutUserInput = {
    where: InventoryTransactionWhereUniqueInput
    data: XOR<InventoryTransactionUpdateWithoutUserInput, InventoryTransactionUncheckedUpdateWithoutUserInput>
  }

  export type InventoryTransactionUpdateManyWithWhereWithoutUserInput = {
    where: InventoryTransactionScalarWhereInput
    data: XOR<InventoryTransactionUpdateManyMutationInput, InventoryTransactionUncheckedUpdateManyWithoutUserInput>
  }

  export type InventoryTransactionScalarWhereInput = {
    AND?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
    OR?: InventoryTransactionScalarWhereInput[]
    NOT?: InventoryTransactionScalarWhereInput | InventoryTransactionScalarWhereInput[]
    id?: StringFilter<"InventoryTransaction"> | string
    item_id?: StringFilter<"InventoryTransaction"> | string
    project_id?: StringNullableFilter<"InventoryTransaction"> | string | null
    type?: EnumInventoryTransactionTypeFilter<"InventoryTransaction"> | $Enums.InventoryTransactionType
    quantity?: FloatFilter<"InventoryTransaction"> | number
    date?: DateTimeFilter<"InventoryTransaction"> | Date | string
    reference_no?: StringNullableFilter<"InventoryTransaction"> | string | null
    notes?: StringNullableFilter<"InventoryTransaction"> | string | null
    created_by?: StringFilter<"InventoryTransaction"> | string
    created_at?: DateTimeFilter<"InventoryTransaction"> | Date | string
  }

  export type PurchaseRequestUpsertWithWhereUniqueWithoutRequesterInput = {
    where: PurchaseRequestWhereUniqueInput
    update: XOR<PurchaseRequestUpdateWithoutRequesterInput, PurchaseRequestUncheckedUpdateWithoutRequesterInput>
    create: XOR<PurchaseRequestCreateWithoutRequesterInput, PurchaseRequestUncheckedCreateWithoutRequesterInput>
  }

  export type PurchaseRequestUpdateWithWhereUniqueWithoutRequesterInput = {
    where: PurchaseRequestWhereUniqueInput
    data: XOR<PurchaseRequestUpdateWithoutRequesterInput, PurchaseRequestUncheckedUpdateWithoutRequesterInput>
  }

  export type PurchaseRequestUpdateManyWithWhereWithoutRequesterInput = {
    where: PurchaseRequestScalarWhereInput
    data: XOR<PurchaseRequestUpdateManyMutationInput, PurchaseRequestUncheckedUpdateManyWithoutRequesterInput>
  }

  export type PurchaseRequestScalarWhereInput = {
    AND?: PurchaseRequestScalarWhereInput | PurchaseRequestScalarWhereInput[]
    OR?: PurchaseRequestScalarWhereInput[]
    NOT?: PurchaseRequestScalarWhereInput | PurchaseRequestScalarWhereInput[]
    id?: StringFilter<"PurchaseRequest"> | string
    project_id?: StringNullableFilter<"PurchaseRequest"> | string | null
    item_name?: StringFilter<"PurchaseRequest"> | string
    quantity?: FloatFilter<"PurchaseRequest"> | number
    unit?: StringFilter<"PurchaseRequest"> | string
    estimated_cost?: DecimalNullableFilter<"PurchaseRequest"> | Decimal | DecimalJsLike | number | string | null
    priority?: EnumPriorityLevelFilter<"PurchaseRequest"> | $Enums.PriorityLevel
    status?: EnumPurchaseStatusFilter<"PurchaseRequest"> | $Enums.PurchaseStatus
    requested_by?: StringFilter<"PurchaseRequest"> | string
    needed_by?: DateTimeNullableFilter<"PurchaseRequest"> | Date | string | null
    notes?: StringNullableFilter<"PurchaseRequest"> | string | null
    created_at?: DateTimeFilter<"PurchaseRequest"> | Date | string
    updated_at?: DateTimeFilter<"PurchaseRequest"> | Date | string
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutCreatorInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutCreatorInput, PurchaseOrderUncheckedUpdateWithoutCreatorInput>
    create: XOR<PurchaseOrderCreateWithoutCreatorInput, PurchaseOrderUncheckedCreateWithoutCreatorInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutCreatorInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutCreatorInput, PurchaseOrderUncheckedUpdateWithoutCreatorInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutCreatorInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutCreatorInput>
  }

  export type PurchaseOrderScalarWhereInput = {
    AND?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    OR?: PurchaseOrderScalarWhereInput[]
    NOT?: PurchaseOrderScalarWhereInput | PurchaseOrderScalarWhereInput[]
    id?: StringFilter<"PurchaseOrder"> | string
    po_number?: StringFilter<"PurchaseOrder"> | string
    purchase_request_id?: StringNullableFilter<"PurchaseOrder"> | string | null
    vendor_id?: StringFilter<"PurchaseOrder"> | string
    total_amount?: DecimalFilter<"PurchaseOrder"> | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFilter<"PurchaseOrder"> | $Enums.PurchaseStatus
    created_by?: StringFilter<"PurchaseOrder"> | string
    created_at?: DateTimeFilter<"PurchaseOrder"> | Date | string
    updated_at?: DateTimeFilter<"PurchaseOrder"> | Date | string
  }

  export type GRNUpsertWithWhereUniqueWithoutReceiverInput = {
    where: GRNWhereUniqueInput
    update: XOR<GRNUpdateWithoutReceiverInput, GRNUncheckedUpdateWithoutReceiverInput>
    create: XOR<GRNCreateWithoutReceiverInput, GRNUncheckedCreateWithoutReceiverInput>
  }

  export type GRNUpdateWithWhereUniqueWithoutReceiverInput = {
    where: GRNWhereUniqueInput
    data: XOR<GRNUpdateWithoutReceiverInput, GRNUncheckedUpdateWithoutReceiverInput>
  }

  export type GRNUpdateManyWithWhereWithoutReceiverInput = {
    where: GRNScalarWhereInput
    data: XOR<GRNUpdateManyMutationInput, GRNUncheckedUpdateManyWithoutReceiverInput>
  }

  export type GRNScalarWhereInput = {
    AND?: GRNScalarWhereInput | GRNScalarWhereInput[]
    OR?: GRNScalarWhereInput[]
    NOT?: GRNScalarWhereInput | GRNScalarWhereInput[]
    id?: StringFilter<"GRN"> | string
    grn_number?: StringFilter<"GRN"> | string
    purchase_order_id?: StringFilter<"GRN"> | string
    received_date?: DateTimeFilter<"GRN"> | Date | string
    received_by?: StringFilter<"GRN"> | string
    notes?: StringNullableFilter<"GRN"> | string | null
    created_at?: DateTimeFilter<"GRN"> | Date | string
  }

  export type UserCreateWithoutProjectsInput = {
    id?: string
    email: string
    password?: string | null
    full_name: string
    role?: $Enums.UserRole
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project_files?: ProjectFileCreateNestedManyWithoutUploaderInput
    project_updates?: ProjectUpdateCreateNestedManyWithoutAuthorInput
    support_requests?: SupportRequestCreateNestedManyWithoutClientInput
    support_messages?: SupportMessageCreateNestedManyWithoutSenderInput
    meeting_requests?: MeetingRequestCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    inventory_logs?: InventoryTransactionCreateNestedManyWithoutUserInput
    purchase_requests?: PurchaseRequestCreateNestedManyWithoutRequesterInput
    purchase_orders?: PurchaseOrderCreateNestedManyWithoutCreatorInput
    grns?: GRNCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutProjectsInput = {
    id?: string
    email: string
    password?: string | null
    full_name: string
    role?: $Enums.UserRole
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project_files?: ProjectFileUncheckedCreateNestedManyWithoutUploaderInput
    project_updates?: ProjectUpdateUncheckedCreateNestedManyWithoutAuthorInput
    support_requests?: SupportRequestUncheckedCreateNestedManyWithoutClientInput
    support_messages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
    meeting_requests?: MeetingRequestUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    inventory_logs?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    purchase_requests?: PurchaseRequestUncheckedCreateNestedManyWithoutRequesterInput
    purchase_orders?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatorInput
    grns?: GRNUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutProjectsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
  }

  export type ProjectFileCreateWithoutProjectInput = {
    id?: string
    file_name: string
    file_url: string
    file_type?: $Enums.FileType
    file_size: bigint | number
    created_at?: Date | string
    uploader: UserCreateNestedOneWithoutProject_filesInput
  }

  export type ProjectFileUncheckedCreateWithoutProjectInput = {
    id?: string
    file_name: string
    file_url: string
    file_type?: $Enums.FileType
    file_size: bigint | number
    uploaded_by: string
    created_at?: Date | string
  }

  export type ProjectFileCreateOrConnectWithoutProjectInput = {
    where: ProjectFileWhereUniqueInput
    create: XOR<ProjectFileCreateWithoutProjectInput, ProjectFileUncheckedCreateWithoutProjectInput>
  }

  export type ProjectFileCreateManyProjectInputEnvelope = {
    data: ProjectFileCreateManyProjectInput | ProjectFileCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpdateCreateWithoutProjectInput = {
    id?: string
    update_text: string
    created_at?: Date | string
    author: UserCreateNestedOneWithoutProject_updatesInput
  }

  export type ProjectUpdateUncheckedCreateWithoutProjectInput = {
    id?: string
    update_text: string
    created_by: string
    created_at?: Date | string
  }

  export type ProjectUpdateCreateOrConnectWithoutProjectInput = {
    where: ProjectUpdateWhereUniqueInput
    create: XOR<ProjectUpdateCreateWithoutProjectInput, ProjectUpdateUncheckedCreateWithoutProjectInput>
  }

  export type ProjectUpdateCreateManyProjectInputEnvelope = {
    data: ProjectUpdateCreateManyProjectInput | ProjectUpdateCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type SupportRequestCreateWithoutProjectInput = {
    id?: string
    subject: string
    description: string
    status?: $Enums.SupportStatus
    priority?: $Enums.PriorityLevel
    created_at?: Date | string
    updated_at?: Date | string
    client: UserCreateNestedOneWithoutSupport_requestsInput
    messages?: SupportMessageCreateNestedManyWithoutRequestInput
  }

  export type SupportRequestUncheckedCreateWithoutProjectInput = {
    id?: string
    client_id: string
    subject: string
    description: string
    status?: $Enums.SupportStatus
    priority?: $Enums.PriorityLevel
    created_at?: Date | string
    updated_at?: Date | string
    messages?: SupportMessageUncheckedCreateNestedManyWithoutRequestInput
  }

  export type SupportRequestCreateOrConnectWithoutProjectInput = {
    where: SupportRequestWhereUniqueInput
    create: XOR<SupportRequestCreateWithoutProjectInput, SupportRequestUncheckedCreateWithoutProjectInput>
  }

  export type SupportRequestCreateManyProjectInputEnvelope = {
    data: SupportRequestCreateManyProjectInput | SupportRequestCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type MeetingRequestCreateWithoutProjectInput = {
    id?: string
    requested_date: Date | string
    duration_minutes?: number
    purpose: string
    status?: $Enums.MeetingStatus
    meeting_link?: string | null
    admin_notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    client: UserCreateNestedOneWithoutMeeting_requestsInput
  }

  export type MeetingRequestUncheckedCreateWithoutProjectInput = {
    id?: string
    client_id: string
    requested_date: Date | string
    duration_minutes?: number
    purpose: string
    status?: $Enums.MeetingStatus
    meeting_link?: string | null
    admin_notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MeetingRequestCreateOrConnectWithoutProjectInput = {
    where: MeetingRequestWhereUniqueInput
    create: XOR<MeetingRequestCreateWithoutProjectInput, MeetingRequestUncheckedCreateWithoutProjectInput>
  }

  export type MeetingRequestCreateManyProjectInputEnvelope = {
    data: MeetingRequestCreateManyProjectInput | MeetingRequestCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type InvoiceCreateWithoutProjectInput = {
    id?: string
    invoice_number: string
    amount: Decimal | DecimalJsLike | number | string
    due_date: Date | string
    status?: $Enums.InvoiceStatus
    payment_qr_url?: string | null
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    paid_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    client: UserCreateNestedOneWithoutInvoicesInput
    payments?: PaymentCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceUncheckedCreateWithoutProjectInput = {
    id?: string
    client_id: string
    invoice_number: string
    amount: Decimal | DecimalJsLike | number | string
    due_date: Date | string
    status?: $Enums.InvoiceStatus
    payment_qr_url?: string | null
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    paid_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    payments?: PaymentUncheckedCreateNestedManyWithoutInvoiceInput
  }

  export type InvoiceCreateOrConnectWithoutProjectInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutProjectInput, InvoiceUncheckedCreateWithoutProjectInput>
  }

  export type InvoiceCreateManyProjectInputEnvelope = {
    data: InvoiceCreateManyProjectInput | InvoiceCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type InventoryTransactionCreateWithoutProjectInput = {
    id?: string
    type: $Enums.InventoryTransactionType
    quantity: number
    date?: Date | string
    reference_no?: string | null
    notes?: string | null
    created_at?: Date | string
    item: InventoryItemCreateNestedOneWithoutTransactionsInput
    user: UserCreateNestedOneWithoutInventory_logsInput
  }

  export type InventoryTransactionUncheckedCreateWithoutProjectInput = {
    id?: string
    item_id: string
    type: $Enums.InventoryTransactionType
    quantity: number
    date?: Date | string
    reference_no?: string | null
    notes?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type InventoryTransactionCreateOrConnectWithoutProjectInput = {
    where: InventoryTransactionWhereUniqueInput
    create: XOR<InventoryTransactionCreateWithoutProjectInput, InventoryTransactionUncheckedCreateWithoutProjectInput>
  }

  export type InventoryTransactionCreateManyProjectInputEnvelope = {
    data: InventoryTransactionCreateManyProjectInput | InventoryTransactionCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseRequestCreateWithoutProjectInput = {
    id?: string
    item_name: string
    quantity: number
    unit: string
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    priority?: $Enums.PriorityLevel
    status?: $Enums.PurchaseStatus
    needed_by?: Date | string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    requester: UserCreateNestedOneWithoutPurchase_requestsInput
    purchase_orders?: PurchaseOrderCreateNestedManyWithoutPurchase_requestInput
  }

  export type PurchaseRequestUncheckedCreateWithoutProjectInput = {
    id?: string
    item_name: string
    quantity: number
    unit: string
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    priority?: $Enums.PriorityLevel
    status?: $Enums.PurchaseStatus
    requested_by: string
    needed_by?: Date | string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    purchase_orders?: PurchaseOrderUncheckedCreateNestedManyWithoutPurchase_requestInput
  }

  export type PurchaseRequestCreateOrConnectWithoutProjectInput = {
    where: PurchaseRequestWhereUniqueInput
    create: XOR<PurchaseRequestCreateWithoutProjectInput, PurchaseRequestUncheckedCreateWithoutProjectInput>
  }

  export type PurchaseRequestCreateManyProjectInputEnvelope = {
    data: PurchaseRequestCreateManyProjectInput | PurchaseRequestCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceCreateWithoutProjectInput = {
    id?: string
    date: Date | string
    status: string
    overtime_hours?: number
    check_in?: Date | string | null
    check_out?: Date | string | null
    created_at?: Date | string
    employee: EmployeeCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateWithoutProjectInput = {
    id?: string
    employee_id: string
    date: Date | string
    status: string
    overtime_hours?: number
    check_in?: Date | string | null
    check_out?: Date | string | null
    created_at?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutProjectInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutProjectInput, AttendanceUncheckedCreateWithoutProjectInput>
  }

  export type AttendanceCreateManyProjectInputEnvelope = {
    data: AttendanceCreateManyProjectInput | AttendanceCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type LabourAllocationCreateWithoutProjectInput = {
    id?: string
    start_date: Date | string
    end_date?: Date | string | null
    status: string
    created_at?: Date | string
    employee: EmployeeCreateNestedOneWithoutAllocationsInput
  }

  export type LabourAllocationUncheckedCreateWithoutProjectInput = {
    id?: string
    employee_id: string
    start_date: Date | string
    end_date?: Date | string | null
    status: string
    created_at?: Date | string
  }

  export type LabourAllocationCreateOrConnectWithoutProjectInput = {
    where: LabourAllocationWhereUniqueInput
    create: XOR<LabourAllocationCreateWithoutProjectInput, LabourAllocationUncheckedCreateWithoutProjectInput>
  }

  export type LabourAllocationCreateManyProjectInputEnvelope = {
    data: LabourAllocationCreateManyProjectInput | LabourAllocationCreateManyProjectInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutProjectsInput = {
    update: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
    create: XOR<UserCreateWithoutProjectsInput, UserUncheckedCreateWithoutProjectsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProjectsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProjectsInput, UserUncheckedUpdateWithoutProjectsInput>
  }

  export type UserUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project_files?: ProjectFileUpdateManyWithoutUploaderNestedInput
    project_updates?: ProjectUpdateUpdateManyWithoutAuthorNestedInput
    support_requests?: SupportRequestUpdateManyWithoutClientNestedInput
    support_messages?: SupportMessageUpdateManyWithoutSenderNestedInput
    meeting_requests?: MeetingRequestUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    inventory_logs?: InventoryTransactionUpdateManyWithoutUserNestedInput
    purchase_requests?: PurchaseRequestUpdateManyWithoutRequesterNestedInput
    purchase_orders?: PurchaseOrderUpdateManyWithoutCreatorNestedInput
    grns?: GRNUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project_files?: ProjectFileUncheckedUpdateManyWithoutUploaderNestedInput
    project_updates?: ProjectUpdateUncheckedUpdateManyWithoutAuthorNestedInput
    support_requests?: SupportRequestUncheckedUpdateManyWithoutClientNestedInput
    support_messages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
    meeting_requests?: MeetingRequestUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    inventory_logs?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    purchase_requests?: PurchaseRequestUncheckedUpdateManyWithoutRequesterNestedInput
    purchase_orders?: PurchaseOrderUncheckedUpdateManyWithoutCreatorNestedInput
    grns?: GRNUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type ProjectFileUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectFileWhereUniqueInput
    update: XOR<ProjectFileUpdateWithoutProjectInput, ProjectFileUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectFileCreateWithoutProjectInput, ProjectFileUncheckedCreateWithoutProjectInput>
  }

  export type ProjectFileUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectFileWhereUniqueInput
    data: XOR<ProjectFileUpdateWithoutProjectInput, ProjectFileUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectFileUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectFileScalarWhereInput
    data: XOR<ProjectFileUpdateManyMutationInput, ProjectFileUncheckedUpdateManyWithoutProjectInput>
  }

  export type ProjectUpdateUpsertWithWhereUniqueWithoutProjectInput = {
    where: ProjectUpdateWhereUniqueInput
    update: XOR<ProjectUpdateUpdateWithoutProjectInput, ProjectUpdateUncheckedUpdateWithoutProjectInput>
    create: XOR<ProjectUpdateCreateWithoutProjectInput, ProjectUpdateUncheckedCreateWithoutProjectInput>
  }

  export type ProjectUpdateUpdateWithWhereUniqueWithoutProjectInput = {
    where: ProjectUpdateWhereUniqueInput
    data: XOR<ProjectUpdateUpdateWithoutProjectInput, ProjectUpdateUncheckedUpdateWithoutProjectInput>
  }

  export type ProjectUpdateUpdateManyWithWhereWithoutProjectInput = {
    where: ProjectUpdateScalarWhereInput
    data: XOR<ProjectUpdateUpdateManyMutationInput, ProjectUpdateUncheckedUpdateManyWithoutProjectInput>
  }

  export type SupportRequestUpsertWithWhereUniqueWithoutProjectInput = {
    where: SupportRequestWhereUniqueInput
    update: XOR<SupportRequestUpdateWithoutProjectInput, SupportRequestUncheckedUpdateWithoutProjectInput>
    create: XOR<SupportRequestCreateWithoutProjectInput, SupportRequestUncheckedCreateWithoutProjectInput>
  }

  export type SupportRequestUpdateWithWhereUniqueWithoutProjectInput = {
    where: SupportRequestWhereUniqueInput
    data: XOR<SupportRequestUpdateWithoutProjectInput, SupportRequestUncheckedUpdateWithoutProjectInput>
  }

  export type SupportRequestUpdateManyWithWhereWithoutProjectInput = {
    where: SupportRequestScalarWhereInput
    data: XOR<SupportRequestUpdateManyMutationInput, SupportRequestUncheckedUpdateManyWithoutProjectInput>
  }

  export type MeetingRequestUpsertWithWhereUniqueWithoutProjectInput = {
    where: MeetingRequestWhereUniqueInput
    update: XOR<MeetingRequestUpdateWithoutProjectInput, MeetingRequestUncheckedUpdateWithoutProjectInput>
    create: XOR<MeetingRequestCreateWithoutProjectInput, MeetingRequestUncheckedCreateWithoutProjectInput>
  }

  export type MeetingRequestUpdateWithWhereUniqueWithoutProjectInput = {
    where: MeetingRequestWhereUniqueInput
    data: XOR<MeetingRequestUpdateWithoutProjectInput, MeetingRequestUncheckedUpdateWithoutProjectInput>
  }

  export type MeetingRequestUpdateManyWithWhereWithoutProjectInput = {
    where: MeetingRequestScalarWhereInput
    data: XOR<MeetingRequestUpdateManyMutationInput, MeetingRequestUncheckedUpdateManyWithoutProjectInput>
  }

  export type InvoiceUpsertWithWhereUniqueWithoutProjectInput = {
    where: InvoiceWhereUniqueInput
    update: XOR<InvoiceUpdateWithoutProjectInput, InvoiceUncheckedUpdateWithoutProjectInput>
    create: XOR<InvoiceCreateWithoutProjectInput, InvoiceUncheckedCreateWithoutProjectInput>
  }

  export type InvoiceUpdateWithWhereUniqueWithoutProjectInput = {
    where: InvoiceWhereUniqueInput
    data: XOR<InvoiceUpdateWithoutProjectInput, InvoiceUncheckedUpdateWithoutProjectInput>
  }

  export type InvoiceUpdateManyWithWhereWithoutProjectInput = {
    where: InvoiceScalarWhereInput
    data: XOR<InvoiceUpdateManyMutationInput, InvoiceUncheckedUpdateManyWithoutProjectInput>
  }

  export type InventoryTransactionUpsertWithWhereUniqueWithoutProjectInput = {
    where: InventoryTransactionWhereUniqueInput
    update: XOR<InventoryTransactionUpdateWithoutProjectInput, InventoryTransactionUncheckedUpdateWithoutProjectInput>
    create: XOR<InventoryTransactionCreateWithoutProjectInput, InventoryTransactionUncheckedCreateWithoutProjectInput>
  }

  export type InventoryTransactionUpdateWithWhereUniqueWithoutProjectInput = {
    where: InventoryTransactionWhereUniqueInput
    data: XOR<InventoryTransactionUpdateWithoutProjectInput, InventoryTransactionUncheckedUpdateWithoutProjectInput>
  }

  export type InventoryTransactionUpdateManyWithWhereWithoutProjectInput = {
    where: InventoryTransactionScalarWhereInput
    data: XOR<InventoryTransactionUpdateManyMutationInput, InventoryTransactionUncheckedUpdateManyWithoutProjectInput>
  }

  export type PurchaseRequestUpsertWithWhereUniqueWithoutProjectInput = {
    where: PurchaseRequestWhereUniqueInput
    update: XOR<PurchaseRequestUpdateWithoutProjectInput, PurchaseRequestUncheckedUpdateWithoutProjectInput>
    create: XOR<PurchaseRequestCreateWithoutProjectInput, PurchaseRequestUncheckedCreateWithoutProjectInput>
  }

  export type PurchaseRequestUpdateWithWhereUniqueWithoutProjectInput = {
    where: PurchaseRequestWhereUniqueInput
    data: XOR<PurchaseRequestUpdateWithoutProjectInput, PurchaseRequestUncheckedUpdateWithoutProjectInput>
  }

  export type PurchaseRequestUpdateManyWithWhereWithoutProjectInput = {
    where: PurchaseRequestScalarWhereInput
    data: XOR<PurchaseRequestUpdateManyMutationInput, PurchaseRequestUncheckedUpdateManyWithoutProjectInput>
  }

  export type AttendanceUpsertWithWhereUniqueWithoutProjectInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutProjectInput, AttendanceUncheckedUpdateWithoutProjectInput>
    create: XOR<AttendanceCreateWithoutProjectInput, AttendanceUncheckedCreateWithoutProjectInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutProjectInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutProjectInput, AttendanceUncheckedUpdateWithoutProjectInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutProjectInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutProjectInput>
  }

  export type AttendanceScalarWhereInput = {
    AND?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    OR?: AttendanceScalarWhereInput[]
    NOT?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    id?: StringFilter<"Attendance"> | string
    employee_id?: StringFilter<"Attendance"> | string
    date?: DateTimeFilter<"Attendance"> | Date | string
    status?: StringFilter<"Attendance"> | string
    overtime_hours?: FloatFilter<"Attendance"> | number
    project_id?: StringNullableFilter<"Attendance"> | string | null
    check_in?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    check_out?: DateTimeNullableFilter<"Attendance"> | Date | string | null
    created_at?: DateTimeFilter<"Attendance"> | Date | string
  }

  export type LabourAllocationUpsertWithWhereUniqueWithoutProjectInput = {
    where: LabourAllocationWhereUniqueInput
    update: XOR<LabourAllocationUpdateWithoutProjectInput, LabourAllocationUncheckedUpdateWithoutProjectInput>
    create: XOR<LabourAllocationCreateWithoutProjectInput, LabourAllocationUncheckedCreateWithoutProjectInput>
  }

  export type LabourAllocationUpdateWithWhereUniqueWithoutProjectInput = {
    where: LabourAllocationWhereUniqueInput
    data: XOR<LabourAllocationUpdateWithoutProjectInput, LabourAllocationUncheckedUpdateWithoutProjectInput>
  }

  export type LabourAllocationUpdateManyWithWhereWithoutProjectInput = {
    where: LabourAllocationScalarWhereInput
    data: XOR<LabourAllocationUpdateManyMutationInput, LabourAllocationUncheckedUpdateManyWithoutProjectInput>
  }

  export type LabourAllocationScalarWhereInput = {
    AND?: LabourAllocationScalarWhereInput | LabourAllocationScalarWhereInput[]
    OR?: LabourAllocationScalarWhereInput[]
    NOT?: LabourAllocationScalarWhereInput | LabourAllocationScalarWhereInput[]
    id?: StringFilter<"LabourAllocation"> | string
    employee_id?: StringFilter<"LabourAllocation"> | string
    project_id?: StringFilter<"LabourAllocation"> | string
    start_date?: DateTimeFilter<"LabourAllocation"> | Date | string
    end_date?: DateTimeNullableFilter<"LabourAllocation"> | Date | string | null
    status?: StringFilter<"LabourAllocation"> | string
    created_at?: DateTimeFilter<"LabourAllocation"> | Date | string
  }

  export type ProjectCreateWithoutFilesInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.ProjectStatus
    github_link?: string | null
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    actual_cost?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    test_asset_url?: string | null
    deployment_url?: string | null
    live_preview_type?: string | null
    live_preview_url?: string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectCreatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    client: UserCreateNestedOneWithoutProjectsInput
    updates?: ProjectUpdateCreateNestedManyWithoutProjectInput
    support_requests?: SupportRequestCreateNestedManyWithoutProjectInput
    meeting_requests?: MeetingRequestCreateNestedManyWithoutProjectInput
    invoices?: InvoiceCreateNestedManyWithoutProjectInput
    inventory_logs?: InventoryTransactionCreateNestedManyWithoutProjectInput
    purchase_requests?: PurchaseRequestCreateNestedManyWithoutProjectInput
    attendance?: AttendanceCreateNestedManyWithoutProjectInput
    labour_allocations?: LabourAllocationCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutFilesInput = {
    id?: string
    client_id: string
    title: string
    description: string
    status?: $Enums.ProjectStatus
    github_link?: string | null
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    actual_cost?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    test_asset_url?: string | null
    deployment_url?: string | null
    live_preview_type?: string | null
    live_preview_url?: string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectCreatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    updates?: ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput
    support_requests?: SupportRequestUncheckedCreateNestedManyWithoutProjectInput
    meeting_requests?: MeetingRequestUncheckedCreateNestedManyWithoutProjectInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutProjectInput
    inventory_logs?: InventoryTransactionUncheckedCreateNestedManyWithoutProjectInput
    purchase_requests?: PurchaseRequestUncheckedCreateNestedManyWithoutProjectInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutProjectInput
    labour_allocations?: LabourAllocationUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutFilesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutFilesInput, ProjectUncheckedCreateWithoutFilesInput>
  }

  export type UserCreateWithoutProject_filesInput = {
    id?: string
    email: string
    password?: string | null
    full_name: string
    role?: $Enums.UserRole
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    projects?: ProjectCreateNestedManyWithoutClientInput
    project_updates?: ProjectUpdateCreateNestedManyWithoutAuthorInput
    support_requests?: SupportRequestCreateNestedManyWithoutClientInput
    support_messages?: SupportMessageCreateNestedManyWithoutSenderInput
    meeting_requests?: MeetingRequestCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    inventory_logs?: InventoryTransactionCreateNestedManyWithoutUserInput
    purchase_requests?: PurchaseRequestCreateNestedManyWithoutRequesterInput
    purchase_orders?: PurchaseOrderCreateNestedManyWithoutCreatorInput
    grns?: GRNCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutProject_filesInput = {
    id?: string
    email: string
    password?: string | null
    full_name: string
    role?: $Enums.UserRole
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    project_updates?: ProjectUpdateUncheckedCreateNestedManyWithoutAuthorInput
    support_requests?: SupportRequestUncheckedCreateNestedManyWithoutClientInput
    support_messages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
    meeting_requests?: MeetingRequestUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    inventory_logs?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    purchase_requests?: PurchaseRequestUncheckedCreateNestedManyWithoutRequesterInput
    purchase_orders?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatorInput
    grns?: GRNUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutProject_filesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProject_filesInput, UserUncheckedCreateWithoutProject_filesInput>
  }

  export type ProjectUpsertWithoutFilesInput = {
    update: XOR<ProjectUpdateWithoutFilesInput, ProjectUncheckedUpdateWithoutFilesInput>
    create: XOR<ProjectCreateWithoutFilesInput, ProjectUncheckedCreateWithoutFilesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutFilesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutFilesInput, ProjectUncheckedUpdateWithoutFilesInput>
  }

  export type ProjectUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    github_link?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actual_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_asset_url?: NullableStringFieldUpdateOperationsInput | string | null
    deployment_url?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_type?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_url?: NullableStringFieldUpdateOperationsInput | string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectUpdatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: UserUpdateOneRequiredWithoutProjectsNestedInput
    updates?: ProjectUpdateUpdateManyWithoutProjectNestedInput
    support_requests?: SupportRequestUpdateManyWithoutProjectNestedInput
    meeting_requests?: MeetingRequestUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUpdateManyWithoutProjectNestedInput
    inventory_logs?: InventoryTransactionUpdateManyWithoutProjectNestedInput
    purchase_requests?: PurchaseRequestUpdateManyWithoutProjectNestedInput
    attendance?: AttendanceUpdateManyWithoutProjectNestedInput
    labour_allocations?: LabourAllocationUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    github_link?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actual_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_asset_url?: NullableStringFieldUpdateOperationsInput | string | null
    deployment_url?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_type?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_url?: NullableStringFieldUpdateOperationsInput | string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectUpdatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updates?: ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput
    support_requests?: SupportRequestUncheckedUpdateManyWithoutProjectNestedInput
    meeting_requests?: MeetingRequestUncheckedUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutProjectNestedInput
    inventory_logs?: InventoryTransactionUncheckedUpdateManyWithoutProjectNestedInput
    purchase_requests?: PurchaseRequestUncheckedUpdateManyWithoutProjectNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutProjectNestedInput
    labour_allocations?: LabourAllocationUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutProject_filesInput = {
    update: XOR<UserUpdateWithoutProject_filesInput, UserUncheckedUpdateWithoutProject_filesInput>
    create: XOR<UserCreateWithoutProject_filesInput, UserUncheckedCreateWithoutProject_filesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProject_filesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProject_filesInput, UserUncheckedUpdateWithoutProject_filesInput>
  }

  export type UserUpdateWithoutProject_filesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutClientNestedInput
    project_updates?: ProjectUpdateUpdateManyWithoutAuthorNestedInput
    support_requests?: SupportRequestUpdateManyWithoutClientNestedInput
    support_messages?: SupportMessageUpdateManyWithoutSenderNestedInput
    meeting_requests?: MeetingRequestUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    inventory_logs?: InventoryTransactionUpdateManyWithoutUserNestedInput
    purchase_requests?: PurchaseRequestUpdateManyWithoutRequesterNestedInput
    purchase_orders?: PurchaseOrderUpdateManyWithoutCreatorNestedInput
    grns?: GRNUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutProject_filesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    project_updates?: ProjectUpdateUncheckedUpdateManyWithoutAuthorNestedInput
    support_requests?: SupportRequestUncheckedUpdateManyWithoutClientNestedInput
    support_messages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
    meeting_requests?: MeetingRequestUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    inventory_logs?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    purchase_requests?: PurchaseRequestUncheckedUpdateManyWithoutRequesterNestedInput
    purchase_orders?: PurchaseOrderUncheckedUpdateManyWithoutCreatorNestedInput
    grns?: GRNUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type ProjectCreateWithoutUpdatesInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.ProjectStatus
    github_link?: string | null
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    actual_cost?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    test_asset_url?: string | null
    deployment_url?: string | null
    live_preview_type?: string | null
    live_preview_url?: string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectCreatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    client: UserCreateNestedOneWithoutProjectsInput
    files?: ProjectFileCreateNestedManyWithoutProjectInput
    support_requests?: SupportRequestCreateNestedManyWithoutProjectInput
    meeting_requests?: MeetingRequestCreateNestedManyWithoutProjectInput
    invoices?: InvoiceCreateNestedManyWithoutProjectInput
    inventory_logs?: InventoryTransactionCreateNestedManyWithoutProjectInput
    purchase_requests?: PurchaseRequestCreateNestedManyWithoutProjectInput
    attendance?: AttendanceCreateNestedManyWithoutProjectInput
    labour_allocations?: LabourAllocationCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutUpdatesInput = {
    id?: string
    client_id: string
    title: string
    description: string
    status?: $Enums.ProjectStatus
    github_link?: string | null
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    actual_cost?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    test_asset_url?: string | null
    deployment_url?: string | null
    live_preview_type?: string | null
    live_preview_url?: string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectCreatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    files?: ProjectFileUncheckedCreateNestedManyWithoutProjectInput
    support_requests?: SupportRequestUncheckedCreateNestedManyWithoutProjectInput
    meeting_requests?: MeetingRequestUncheckedCreateNestedManyWithoutProjectInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutProjectInput
    inventory_logs?: InventoryTransactionUncheckedCreateNestedManyWithoutProjectInput
    purchase_requests?: PurchaseRequestUncheckedCreateNestedManyWithoutProjectInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutProjectInput
    labour_allocations?: LabourAllocationUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutUpdatesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutUpdatesInput, ProjectUncheckedCreateWithoutUpdatesInput>
  }

  export type UserCreateWithoutProject_updatesInput = {
    id?: string
    email: string
    password?: string | null
    full_name: string
    role?: $Enums.UserRole
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    projects?: ProjectCreateNestedManyWithoutClientInput
    project_files?: ProjectFileCreateNestedManyWithoutUploaderInput
    support_requests?: SupportRequestCreateNestedManyWithoutClientInput
    support_messages?: SupportMessageCreateNestedManyWithoutSenderInput
    meeting_requests?: MeetingRequestCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    inventory_logs?: InventoryTransactionCreateNestedManyWithoutUserInput
    purchase_requests?: PurchaseRequestCreateNestedManyWithoutRequesterInput
    purchase_orders?: PurchaseOrderCreateNestedManyWithoutCreatorInput
    grns?: GRNCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutProject_updatesInput = {
    id?: string
    email: string
    password?: string | null
    full_name: string
    role?: $Enums.UserRole
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    project_files?: ProjectFileUncheckedCreateNestedManyWithoutUploaderInput
    support_requests?: SupportRequestUncheckedCreateNestedManyWithoutClientInput
    support_messages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
    meeting_requests?: MeetingRequestUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    inventory_logs?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    purchase_requests?: PurchaseRequestUncheckedCreateNestedManyWithoutRequesterInput
    purchase_orders?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatorInput
    grns?: GRNUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutProject_updatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutProject_updatesInput, UserUncheckedCreateWithoutProject_updatesInput>
  }

  export type ProjectUpsertWithoutUpdatesInput = {
    update: XOR<ProjectUpdateWithoutUpdatesInput, ProjectUncheckedUpdateWithoutUpdatesInput>
    create: XOR<ProjectCreateWithoutUpdatesInput, ProjectUncheckedCreateWithoutUpdatesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutUpdatesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutUpdatesInput, ProjectUncheckedUpdateWithoutUpdatesInput>
  }

  export type ProjectUpdateWithoutUpdatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    github_link?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actual_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_asset_url?: NullableStringFieldUpdateOperationsInput | string | null
    deployment_url?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_type?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_url?: NullableStringFieldUpdateOperationsInput | string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectUpdatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: UserUpdateOneRequiredWithoutProjectsNestedInput
    files?: ProjectFileUpdateManyWithoutProjectNestedInput
    support_requests?: SupportRequestUpdateManyWithoutProjectNestedInput
    meeting_requests?: MeetingRequestUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUpdateManyWithoutProjectNestedInput
    inventory_logs?: InventoryTransactionUpdateManyWithoutProjectNestedInput
    purchase_requests?: PurchaseRequestUpdateManyWithoutProjectNestedInput
    attendance?: AttendanceUpdateManyWithoutProjectNestedInput
    labour_allocations?: LabourAllocationUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutUpdatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    github_link?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actual_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_asset_url?: NullableStringFieldUpdateOperationsInput | string | null
    deployment_url?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_type?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_url?: NullableStringFieldUpdateOperationsInput | string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectUpdatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: ProjectFileUncheckedUpdateManyWithoutProjectNestedInput
    support_requests?: SupportRequestUncheckedUpdateManyWithoutProjectNestedInput
    meeting_requests?: MeetingRequestUncheckedUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutProjectNestedInput
    inventory_logs?: InventoryTransactionUncheckedUpdateManyWithoutProjectNestedInput
    purchase_requests?: PurchaseRequestUncheckedUpdateManyWithoutProjectNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutProjectNestedInput
    labour_allocations?: LabourAllocationUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutProject_updatesInput = {
    update: XOR<UserUpdateWithoutProject_updatesInput, UserUncheckedUpdateWithoutProject_updatesInput>
    create: XOR<UserCreateWithoutProject_updatesInput, UserUncheckedCreateWithoutProject_updatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutProject_updatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutProject_updatesInput, UserUncheckedUpdateWithoutProject_updatesInput>
  }

  export type UserUpdateWithoutProject_updatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutClientNestedInput
    project_files?: ProjectFileUpdateManyWithoutUploaderNestedInput
    support_requests?: SupportRequestUpdateManyWithoutClientNestedInput
    support_messages?: SupportMessageUpdateManyWithoutSenderNestedInput
    meeting_requests?: MeetingRequestUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    inventory_logs?: InventoryTransactionUpdateManyWithoutUserNestedInput
    purchase_requests?: PurchaseRequestUpdateManyWithoutRequesterNestedInput
    purchase_orders?: PurchaseOrderUpdateManyWithoutCreatorNestedInput
    grns?: GRNUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutProject_updatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    project_files?: ProjectFileUncheckedUpdateManyWithoutUploaderNestedInput
    support_requests?: SupportRequestUncheckedUpdateManyWithoutClientNestedInput
    support_messages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
    meeting_requests?: MeetingRequestUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    inventory_logs?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    purchase_requests?: PurchaseRequestUncheckedUpdateManyWithoutRequesterNestedInput
    purchase_orders?: PurchaseOrderUncheckedUpdateManyWithoutCreatorNestedInput
    grns?: GRNUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type ProjectCreateWithoutSupport_requestsInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.ProjectStatus
    github_link?: string | null
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    actual_cost?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    test_asset_url?: string | null
    deployment_url?: string | null
    live_preview_type?: string | null
    live_preview_url?: string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectCreatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    client: UserCreateNestedOneWithoutProjectsInput
    files?: ProjectFileCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateCreateNestedManyWithoutProjectInput
    meeting_requests?: MeetingRequestCreateNestedManyWithoutProjectInput
    invoices?: InvoiceCreateNestedManyWithoutProjectInput
    inventory_logs?: InventoryTransactionCreateNestedManyWithoutProjectInput
    purchase_requests?: PurchaseRequestCreateNestedManyWithoutProjectInput
    attendance?: AttendanceCreateNestedManyWithoutProjectInput
    labour_allocations?: LabourAllocationCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutSupport_requestsInput = {
    id?: string
    client_id: string
    title: string
    description: string
    status?: $Enums.ProjectStatus
    github_link?: string | null
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    actual_cost?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    test_asset_url?: string | null
    deployment_url?: string | null
    live_preview_type?: string | null
    live_preview_url?: string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectCreatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    files?: ProjectFileUncheckedCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput
    meeting_requests?: MeetingRequestUncheckedCreateNestedManyWithoutProjectInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutProjectInput
    inventory_logs?: InventoryTransactionUncheckedCreateNestedManyWithoutProjectInput
    purchase_requests?: PurchaseRequestUncheckedCreateNestedManyWithoutProjectInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutProjectInput
    labour_allocations?: LabourAllocationUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutSupport_requestsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutSupport_requestsInput, ProjectUncheckedCreateWithoutSupport_requestsInput>
  }

  export type UserCreateWithoutSupport_requestsInput = {
    id?: string
    email: string
    password?: string | null
    full_name: string
    role?: $Enums.UserRole
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    projects?: ProjectCreateNestedManyWithoutClientInput
    project_files?: ProjectFileCreateNestedManyWithoutUploaderInput
    project_updates?: ProjectUpdateCreateNestedManyWithoutAuthorInput
    support_messages?: SupportMessageCreateNestedManyWithoutSenderInput
    meeting_requests?: MeetingRequestCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    inventory_logs?: InventoryTransactionCreateNestedManyWithoutUserInput
    purchase_requests?: PurchaseRequestCreateNestedManyWithoutRequesterInput
    purchase_orders?: PurchaseOrderCreateNestedManyWithoutCreatorInput
    grns?: GRNCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutSupport_requestsInput = {
    id?: string
    email: string
    password?: string | null
    full_name: string
    role?: $Enums.UserRole
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    project_files?: ProjectFileUncheckedCreateNestedManyWithoutUploaderInput
    project_updates?: ProjectUpdateUncheckedCreateNestedManyWithoutAuthorInput
    support_messages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
    meeting_requests?: MeetingRequestUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    inventory_logs?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    purchase_requests?: PurchaseRequestUncheckedCreateNestedManyWithoutRequesterInput
    purchase_orders?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatorInput
    grns?: GRNUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutSupport_requestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSupport_requestsInput, UserUncheckedCreateWithoutSupport_requestsInput>
  }

  export type SupportMessageCreateWithoutRequestInput = {
    id?: string
    message: string
    created_at?: Date | string
    sender: UserCreateNestedOneWithoutSupport_messagesInput
  }

  export type SupportMessageUncheckedCreateWithoutRequestInput = {
    id?: string
    user_id: string
    message: string
    created_at?: Date | string
  }

  export type SupportMessageCreateOrConnectWithoutRequestInput = {
    where: SupportMessageWhereUniqueInput
    create: XOR<SupportMessageCreateWithoutRequestInput, SupportMessageUncheckedCreateWithoutRequestInput>
  }

  export type SupportMessageCreateManyRequestInputEnvelope = {
    data: SupportMessageCreateManyRequestInput | SupportMessageCreateManyRequestInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutSupport_requestsInput = {
    update: XOR<ProjectUpdateWithoutSupport_requestsInput, ProjectUncheckedUpdateWithoutSupport_requestsInput>
    create: XOR<ProjectCreateWithoutSupport_requestsInput, ProjectUncheckedCreateWithoutSupport_requestsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutSupport_requestsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutSupport_requestsInput, ProjectUncheckedUpdateWithoutSupport_requestsInput>
  }

  export type ProjectUpdateWithoutSupport_requestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    github_link?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actual_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_asset_url?: NullableStringFieldUpdateOperationsInput | string | null
    deployment_url?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_type?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_url?: NullableStringFieldUpdateOperationsInput | string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectUpdatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: UserUpdateOneRequiredWithoutProjectsNestedInput
    files?: ProjectFileUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUpdateManyWithoutProjectNestedInput
    meeting_requests?: MeetingRequestUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUpdateManyWithoutProjectNestedInput
    inventory_logs?: InventoryTransactionUpdateManyWithoutProjectNestedInput
    purchase_requests?: PurchaseRequestUpdateManyWithoutProjectNestedInput
    attendance?: AttendanceUpdateManyWithoutProjectNestedInput
    labour_allocations?: LabourAllocationUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutSupport_requestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    github_link?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actual_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_asset_url?: NullableStringFieldUpdateOperationsInput | string | null
    deployment_url?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_type?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_url?: NullableStringFieldUpdateOperationsInput | string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectUpdatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: ProjectFileUncheckedUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput
    meeting_requests?: MeetingRequestUncheckedUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutProjectNestedInput
    inventory_logs?: InventoryTransactionUncheckedUpdateManyWithoutProjectNestedInput
    purchase_requests?: PurchaseRequestUncheckedUpdateManyWithoutProjectNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutProjectNestedInput
    labour_allocations?: LabourAllocationUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutSupport_requestsInput = {
    update: XOR<UserUpdateWithoutSupport_requestsInput, UserUncheckedUpdateWithoutSupport_requestsInput>
    create: XOR<UserCreateWithoutSupport_requestsInput, UserUncheckedCreateWithoutSupport_requestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSupport_requestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSupport_requestsInput, UserUncheckedUpdateWithoutSupport_requestsInput>
  }

  export type UserUpdateWithoutSupport_requestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutClientNestedInput
    project_files?: ProjectFileUpdateManyWithoutUploaderNestedInput
    project_updates?: ProjectUpdateUpdateManyWithoutAuthorNestedInput
    support_messages?: SupportMessageUpdateManyWithoutSenderNestedInput
    meeting_requests?: MeetingRequestUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    inventory_logs?: InventoryTransactionUpdateManyWithoutUserNestedInput
    purchase_requests?: PurchaseRequestUpdateManyWithoutRequesterNestedInput
    purchase_orders?: PurchaseOrderUpdateManyWithoutCreatorNestedInput
    grns?: GRNUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutSupport_requestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    project_files?: ProjectFileUncheckedUpdateManyWithoutUploaderNestedInput
    project_updates?: ProjectUpdateUncheckedUpdateManyWithoutAuthorNestedInput
    support_messages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
    meeting_requests?: MeetingRequestUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    inventory_logs?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    purchase_requests?: PurchaseRequestUncheckedUpdateManyWithoutRequesterNestedInput
    purchase_orders?: PurchaseOrderUncheckedUpdateManyWithoutCreatorNestedInput
    grns?: GRNUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type SupportMessageUpsertWithWhereUniqueWithoutRequestInput = {
    where: SupportMessageWhereUniqueInput
    update: XOR<SupportMessageUpdateWithoutRequestInput, SupportMessageUncheckedUpdateWithoutRequestInput>
    create: XOR<SupportMessageCreateWithoutRequestInput, SupportMessageUncheckedCreateWithoutRequestInput>
  }

  export type SupportMessageUpdateWithWhereUniqueWithoutRequestInput = {
    where: SupportMessageWhereUniqueInput
    data: XOR<SupportMessageUpdateWithoutRequestInput, SupportMessageUncheckedUpdateWithoutRequestInput>
  }

  export type SupportMessageUpdateManyWithWhereWithoutRequestInput = {
    where: SupportMessageScalarWhereInput
    data: XOR<SupportMessageUpdateManyMutationInput, SupportMessageUncheckedUpdateManyWithoutRequestInput>
  }

  export type SupportRequestCreateWithoutMessagesInput = {
    id?: string
    subject: string
    description: string
    status?: $Enums.SupportStatus
    priority?: $Enums.PriorityLevel
    created_at?: Date | string
    updated_at?: Date | string
    project?: ProjectCreateNestedOneWithoutSupport_requestsInput
    client: UserCreateNestedOneWithoutSupport_requestsInput
  }

  export type SupportRequestUncheckedCreateWithoutMessagesInput = {
    id?: string
    project_id?: string | null
    client_id: string
    subject: string
    description: string
    status?: $Enums.SupportStatus
    priority?: $Enums.PriorityLevel
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SupportRequestCreateOrConnectWithoutMessagesInput = {
    where: SupportRequestWhereUniqueInput
    create: XOR<SupportRequestCreateWithoutMessagesInput, SupportRequestUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutSupport_messagesInput = {
    id?: string
    email: string
    password?: string | null
    full_name: string
    role?: $Enums.UserRole
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    projects?: ProjectCreateNestedManyWithoutClientInput
    project_files?: ProjectFileCreateNestedManyWithoutUploaderInput
    project_updates?: ProjectUpdateCreateNestedManyWithoutAuthorInput
    support_requests?: SupportRequestCreateNestedManyWithoutClientInput
    meeting_requests?: MeetingRequestCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    inventory_logs?: InventoryTransactionCreateNestedManyWithoutUserInput
    purchase_requests?: PurchaseRequestCreateNestedManyWithoutRequesterInput
    purchase_orders?: PurchaseOrderCreateNestedManyWithoutCreatorInput
    grns?: GRNCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutSupport_messagesInput = {
    id?: string
    email: string
    password?: string | null
    full_name: string
    role?: $Enums.UserRole
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    project_files?: ProjectFileUncheckedCreateNestedManyWithoutUploaderInput
    project_updates?: ProjectUpdateUncheckedCreateNestedManyWithoutAuthorInput
    support_requests?: SupportRequestUncheckedCreateNestedManyWithoutClientInput
    meeting_requests?: MeetingRequestUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    inventory_logs?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    purchase_requests?: PurchaseRequestUncheckedCreateNestedManyWithoutRequesterInput
    purchase_orders?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatorInput
    grns?: GRNUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutSupport_messagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSupport_messagesInput, UserUncheckedCreateWithoutSupport_messagesInput>
  }

  export type SupportRequestUpsertWithoutMessagesInput = {
    update: XOR<SupportRequestUpdateWithoutMessagesInput, SupportRequestUncheckedUpdateWithoutMessagesInput>
    create: XOR<SupportRequestCreateWithoutMessagesInput, SupportRequestUncheckedCreateWithoutMessagesInput>
    where?: SupportRequestWhereInput
  }

  export type SupportRequestUpdateToOneWithWhereWithoutMessagesInput = {
    where?: SupportRequestWhereInput
    data: XOR<SupportRequestUpdateWithoutMessagesInput, SupportRequestUncheckedUpdateWithoutMessagesInput>
  }

  export type SupportRequestUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSupportStatusFieldUpdateOperationsInput | $Enums.SupportStatus
    priority?: EnumPriorityLevelFieldUpdateOperationsInput | $Enums.PriorityLevel
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutSupport_requestsNestedInput
    client?: UserUpdateOneRequiredWithoutSupport_requestsNestedInput
  }

  export type SupportRequestUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: NullableStringFieldUpdateOperationsInput | string | null
    client_id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSupportStatusFieldUpdateOperationsInput | $Enums.SupportStatus
    priority?: EnumPriorityLevelFieldUpdateOperationsInput | $Enums.PriorityLevel
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUpsertWithoutSupport_messagesInput = {
    update: XOR<UserUpdateWithoutSupport_messagesInput, UserUncheckedUpdateWithoutSupport_messagesInput>
    create: XOR<UserCreateWithoutSupport_messagesInput, UserUncheckedCreateWithoutSupport_messagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSupport_messagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSupport_messagesInput, UserUncheckedUpdateWithoutSupport_messagesInput>
  }

  export type UserUpdateWithoutSupport_messagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutClientNestedInput
    project_files?: ProjectFileUpdateManyWithoutUploaderNestedInput
    project_updates?: ProjectUpdateUpdateManyWithoutAuthorNestedInput
    support_requests?: SupportRequestUpdateManyWithoutClientNestedInput
    meeting_requests?: MeetingRequestUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    inventory_logs?: InventoryTransactionUpdateManyWithoutUserNestedInput
    purchase_requests?: PurchaseRequestUpdateManyWithoutRequesterNestedInput
    purchase_orders?: PurchaseOrderUpdateManyWithoutCreatorNestedInput
    grns?: GRNUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutSupport_messagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    project_files?: ProjectFileUncheckedUpdateManyWithoutUploaderNestedInput
    project_updates?: ProjectUpdateUncheckedUpdateManyWithoutAuthorNestedInput
    support_requests?: SupportRequestUncheckedUpdateManyWithoutClientNestedInput
    meeting_requests?: MeetingRequestUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    inventory_logs?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    purchase_requests?: PurchaseRequestUncheckedUpdateManyWithoutRequesterNestedInput
    purchase_orders?: PurchaseOrderUncheckedUpdateManyWithoutCreatorNestedInput
    grns?: GRNUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type ProjectCreateWithoutMeeting_requestsInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.ProjectStatus
    github_link?: string | null
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    actual_cost?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    test_asset_url?: string | null
    deployment_url?: string | null
    live_preview_type?: string | null
    live_preview_url?: string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectCreatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    client: UserCreateNestedOneWithoutProjectsInput
    files?: ProjectFileCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateCreateNestedManyWithoutProjectInput
    support_requests?: SupportRequestCreateNestedManyWithoutProjectInput
    invoices?: InvoiceCreateNestedManyWithoutProjectInput
    inventory_logs?: InventoryTransactionCreateNestedManyWithoutProjectInput
    purchase_requests?: PurchaseRequestCreateNestedManyWithoutProjectInput
    attendance?: AttendanceCreateNestedManyWithoutProjectInput
    labour_allocations?: LabourAllocationCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutMeeting_requestsInput = {
    id?: string
    client_id: string
    title: string
    description: string
    status?: $Enums.ProjectStatus
    github_link?: string | null
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    actual_cost?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    test_asset_url?: string | null
    deployment_url?: string | null
    live_preview_type?: string | null
    live_preview_url?: string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectCreatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    files?: ProjectFileUncheckedCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput
    support_requests?: SupportRequestUncheckedCreateNestedManyWithoutProjectInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutProjectInput
    inventory_logs?: InventoryTransactionUncheckedCreateNestedManyWithoutProjectInput
    purchase_requests?: PurchaseRequestUncheckedCreateNestedManyWithoutProjectInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutProjectInput
    labour_allocations?: LabourAllocationUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutMeeting_requestsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutMeeting_requestsInput, ProjectUncheckedCreateWithoutMeeting_requestsInput>
  }

  export type UserCreateWithoutMeeting_requestsInput = {
    id?: string
    email: string
    password?: string | null
    full_name: string
    role?: $Enums.UserRole
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    projects?: ProjectCreateNestedManyWithoutClientInput
    project_files?: ProjectFileCreateNestedManyWithoutUploaderInput
    project_updates?: ProjectUpdateCreateNestedManyWithoutAuthorInput
    support_requests?: SupportRequestCreateNestedManyWithoutClientInput
    support_messages?: SupportMessageCreateNestedManyWithoutSenderInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    inventory_logs?: InventoryTransactionCreateNestedManyWithoutUserInput
    purchase_requests?: PurchaseRequestCreateNestedManyWithoutRequesterInput
    purchase_orders?: PurchaseOrderCreateNestedManyWithoutCreatorInput
    grns?: GRNCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutMeeting_requestsInput = {
    id?: string
    email: string
    password?: string | null
    full_name: string
    role?: $Enums.UserRole
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    project_files?: ProjectFileUncheckedCreateNestedManyWithoutUploaderInput
    project_updates?: ProjectUpdateUncheckedCreateNestedManyWithoutAuthorInput
    support_requests?: SupportRequestUncheckedCreateNestedManyWithoutClientInput
    support_messages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    inventory_logs?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    purchase_requests?: PurchaseRequestUncheckedCreateNestedManyWithoutRequesterInput
    purchase_orders?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatorInput
    grns?: GRNUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutMeeting_requestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutMeeting_requestsInput, UserUncheckedCreateWithoutMeeting_requestsInput>
  }

  export type ProjectUpsertWithoutMeeting_requestsInput = {
    update: XOR<ProjectUpdateWithoutMeeting_requestsInput, ProjectUncheckedUpdateWithoutMeeting_requestsInput>
    create: XOR<ProjectCreateWithoutMeeting_requestsInput, ProjectUncheckedCreateWithoutMeeting_requestsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutMeeting_requestsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutMeeting_requestsInput, ProjectUncheckedUpdateWithoutMeeting_requestsInput>
  }

  export type ProjectUpdateWithoutMeeting_requestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    github_link?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actual_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_asset_url?: NullableStringFieldUpdateOperationsInput | string | null
    deployment_url?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_type?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_url?: NullableStringFieldUpdateOperationsInput | string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectUpdatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: UserUpdateOneRequiredWithoutProjectsNestedInput
    files?: ProjectFileUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUpdateManyWithoutProjectNestedInput
    support_requests?: SupportRequestUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUpdateManyWithoutProjectNestedInput
    inventory_logs?: InventoryTransactionUpdateManyWithoutProjectNestedInput
    purchase_requests?: PurchaseRequestUpdateManyWithoutProjectNestedInput
    attendance?: AttendanceUpdateManyWithoutProjectNestedInput
    labour_allocations?: LabourAllocationUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutMeeting_requestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    github_link?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actual_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_asset_url?: NullableStringFieldUpdateOperationsInput | string | null
    deployment_url?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_type?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_url?: NullableStringFieldUpdateOperationsInput | string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectUpdatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: ProjectFileUncheckedUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput
    support_requests?: SupportRequestUncheckedUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutProjectNestedInput
    inventory_logs?: InventoryTransactionUncheckedUpdateManyWithoutProjectNestedInput
    purchase_requests?: PurchaseRequestUncheckedUpdateManyWithoutProjectNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutProjectNestedInput
    labour_allocations?: LabourAllocationUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutMeeting_requestsInput = {
    update: XOR<UserUpdateWithoutMeeting_requestsInput, UserUncheckedUpdateWithoutMeeting_requestsInput>
    create: XOR<UserCreateWithoutMeeting_requestsInput, UserUncheckedCreateWithoutMeeting_requestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutMeeting_requestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutMeeting_requestsInput, UserUncheckedUpdateWithoutMeeting_requestsInput>
  }

  export type UserUpdateWithoutMeeting_requestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutClientNestedInput
    project_files?: ProjectFileUpdateManyWithoutUploaderNestedInput
    project_updates?: ProjectUpdateUpdateManyWithoutAuthorNestedInput
    support_requests?: SupportRequestUpdateManyWithoutClientNestedInput
    support_messages?: SupportMessageUpdateManyWithoutSenderNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    inventory_logs?: InventoryTransactionUpdateManyWithoutUserNestedInput
    purchase_requests?: PurchaseRequestUpdateManyWithoutRequesterNestedInput
    purchase_orders?: PurchaseOrderUpdateManyWithoutCreatorNestedInput
    grns?: GRNUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutMeeting_requestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    project_files?: ProjectFileUncheckedUpdateManyWithoutUploaderNestedInput
    project_updates?: ProjectUpdateUncheckedUpdateManyWithoutAuthorNestedInput
    support_requests?: SupportRequestUncheckedUpdateManyWithoutClientNestedInput
    support_messages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    inventory_logs?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    purchase_requests?: PurchaseRequestUncheckedUpdateManyWithoutRequesterNestedInput
    purchase_orders?: PurchaseOrderUncheckedUpdateManyWithoutCreatorNestedInput
    grns?: GRNUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type ProjectCreateWithoutInvoicesInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.ProjectStatus
    github_link?: string | null
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    actual_cost?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    test_asset_url?: string | null
    deployment_url?: string | null
    live_preview_type?: string | null
    live_preview_url?: string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectCreatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    client: UserCreateNestedOneWithoutProjectsInput
    files?: ProjectFileCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateCreateNestedManyWithoutProjectInput
    support_requests?: SupportRequestCreateNestedManyWithoutProjectInput
    meeting_requests?: MeetingRequestCreateNestedManyWithoutProjectInput
    inventory_logs?: InventoryTransactionCreateNestedManyWithoutProjectInput
    purchase_requests?: PurchaseRequestCreateNestedManyWithoutProjectInput
    attendance?: AttendanceCreateNestedManyWithoutProjectInput
    labour_allocations?: LabourAllocationCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutInvoicesInput = {
    id?: string
    client_id: string
    title: string
    description: string
    status?: $Enums.ProjectStatus
    github_link?: string | null
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    actual_cost?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    test_asset_url?: string | null
    deployment_url?: string | null
    live_preview_type?: string | null
    live_preview_url?: string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectCreatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    files?: ProjectFileUncheckedCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput
    support_requests?: SupportRequestUncheckedCreateNestedManyWithoutProjectInput
    meeting_requests?: MeetingRequestUncheckedCreateNestedManyWithoutProjectInput
    inventory_logs?: InventoryTransactionUncheckedCreateNestedManyWithoutProjectInput
    purchase_requests?: PurchaseRequestUncheckedCreateNestedManyWithoutProjectInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutProjectInput
    labour_allocations?: LabourAllocationUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutInvoicesInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutInvoicesInput, ProjectUncheckedCreateWithoutInvoicesInput>
  }

  export type UserCreateWithoutInvoicesInput = {
    id?: string
    email: string
    password?: string | null
    full_name: string
    role?: $Enums.UserRole
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    projects?: ProjectCreateNestedManyWithoutClientInput
    project_files?: ProjectFileCreateNestedManyWithoutUploaderInput
    project_updates?: ProjectUpdateCreateNestedManyWithoutAuthorInput
    support_requests?: SupportRequestCreateNestedManyWithoutClientInput
    support_messages?: SupportMessageCreateNestedManyWithoutSenderInput
    meeting_requests?: MeetingRequestCreateNestedManyWithoutClientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    inventory_logs?: InventoryTransactionCreateNestedManyWithoutUserInput
    purchase_requests?: PurchaseRequestCreateNestedManyWithoutRequesterInput
    purchase_orders?: PurchaseOrderCreateNestedManyWithoutCreatorInput
    grns?: GRNCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutInvoicesInput = {
    id?: string
    email: string
    password?: string | null
    full_name: string
    role?: $Enums.UserRole
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    project_files?: ProjectFileUncheckedCreateNestedManyWithoutUploaderInput
    project_updates?: ProjectUpdateUncheckedCreateNestedManyWithoutAuthorInput
    support_requests?: SupportRequestUncheckedCreateNestedManyWithoutClientInput
    support_messages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
    meeting_requests?: MeetingRequestUncheckedCreateNestedManyWithoutClientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    inventory_logs?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    purchase_requests?: PurchaseRequestUncheckedCreateNestedManyWithoutRequesterInput
    purchase_orders?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatorInput
    grns?: GRNUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutInvoicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
  }

  export type PaymentCreateWithoutInvoiceInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    payment_method: string
    transaction_id?: string | null
    payment_date?: Date | string
    notes?: string | null
    created_at?: Date | string
  }

  export type PaymentUncheckedCreateWithoutInvoiceInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    payment_method: string
    transaction_id?: string | null
    payment_date?: Date | string
    notes?: string | null
    created_at?: Date | string
  }

  export type PaymentCreateOrConnectWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentCreateManyInvoiceInputEnvelope = {
    data: PaymentCreateManyInvoiceInput | PaymentCreateManyInvoiceInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutInvoicesInput = {
    update: XOR<ProjectUpdateWithoutInvoicesInput, ProjectUncheckedUpdateWithoutInvoicesInput>
    create: XOR<ProjectCreateWithoutInvoicesInput, ProjectUncheckedCreateWithoutInvoicesInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutInvoicesInput, ProjectUncheckedUpdateWithoutInvoicesInput>
  }

  export type ProjectUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    github_link?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actual_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_asset_url?: NullableStringFieldUpdateOperationsInput | string | null
    deployment_url?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_type?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_url?: NullableStringFieldUpdateOperationsInput | string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectUpdatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: UserUpdateOneRequiredWithoutProjectsNestedInput
    files?: ProjectFileUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUpdateManyWithoutProjectNestedInput
    support_requests?: SupportRequestUpdateManyWithoutProjectNestedInput
    meeting_requests?: MeetingRequestUpdateManyWithoutProjectNestedInput
    inventory_logs?: InventoryTransactionUpdateManyWithoutProjectNestedInput
    purchase_requests?: PurchaseRequestUpdateManyWithoutProjectNestedInput
    attendance?: AttendanceUpdateManyWithoutProjectNestedInput
    labour_allocations?: LabourAllocationUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    github_link?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actual_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_asset_url?: NullableStringFieldUpdateOperationsInput | string | null
    deployment_url?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_type?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_url?: NullableStringFieldUpdateOperationsInput | string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectUpdatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: ProjectFileUncheckedUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput
    support_requests?: SupportRequestUncheckedUpdateManyWithoutProjectNestedInput
    meeting_requests?: MeetingRequestUncheckedUpdateManyWithoutProjectNestedInput
    inventory_logs?: InventoryTransactionUncheckedUpdateManyWithoutProjectNestedInput
    purchase_requests?: PurchaseRequestUncheckedUpdateManyWithoutProjectNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutProjectNestedInput
    labour_allocations?: LabourAllocationUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutInvoicesInput = {
    update: XOR<UserUpdateWithoutInvoicesInput, UserUncheckedUpdateWithoutInvoicesInput>
    create: XOR<UserCreateWithoutInvoicesInput, UserUncheckedCreateWithoutInvoicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInvoicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInvoicesInput, UserUncheckedUpdateWithoutInvoicesInput>
  }

  export type UserUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutClientNestedInput
    project_files?: ProjectFileUpdateManyWithoutUploaderNestedInput
    project_updates?: ProjectUpdateUpdateManyWithoutAuthorNestedInput
    support_requests?: SupportRequestUpdateManyWithoutClientNestedInput
    support_messages?: SupportMessageUpdateManyWithoutSenderNestedInput
    meeting_requests?: MeetingRequestUpdateManyWithoutClientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    inventory_logs?: InventoryTransactionUpdateManyWithoutUserNestedInput
    purchase_requests?: PurchaseRequestUpdateManyWithoutRequesterNestedInput
    purchase_orders?: PurchaseOrderUpdateManyWithoutCreatorNestedInput
    grns?: GRNUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutInvoicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    project_files?: ProjectFileUncheckedUpdateManyWithoutUploaderNestedInput
    project_updates?: ProjectUpdateUncheckedUpdateManyWithoutAuthorNestedInput
    support_requests?: SupportRequestUncheckedUpdateManyWithoutClientNestedInput
    support_messages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
    meeting_requests?: MeetingRequestUncheckedUpdateManyWithoutClientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    inventory_logs?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    purchase_requests?: PurchaseRequestUncheckedUpdateManyWithoutRequesterNestedInput
    purchase_orders?: PurchaseOrderUncheckedUpdateManyWithoutCreatorNestedInput
    grns?: GRNUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type PaymentUpsertWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
    create: XOR<PaymentCreateWithoutInvoiceInput, PaymentUncheckedCreateWithoutInvoiceInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutInvoiceInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutInvoiceInput, PaymentUncheckedUpdateWithoutInvoiceInput>
  }

  export type PaymentUpdateManyWithWhereWithoutInvoiceInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutInvoiceInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    invoice_id?: StringFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    payment_method?: StringFilter<"Payment"> | string
    transaction_id?: StringNullableFilter<"Payment"> | string | null
    payment_date?: DateTimeFilter<"Payment"> | Date | string
    notes?: StringNullableFilter<"Payment"> | string | null
    created_at?: DateTimeFilter<"Payment"> | Date | string
  }

  export type InvoiceCreateWithoutPaymentsInput = {
    id?: string
    invoice_number: string
    amount: Decimal | DecimalJsLike | number | string
    due_date: Date | string
    status?: $Enums.InvoiceStatus
    payment_qr_url?: string | null
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    paid_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
    project: ProjectCreateNestedOneWithoutInvoicesInput
    client: UserCreateNestedOneWithoutInvoicesInput
  }

  export type InvoiceUncheckedCreateWithoutPaymentsInput = {
    id?: string
    project_id: string
    client_id: string
    invoice_number: string
    amount: Decimal | DecimalJsLike | number | string
    due_date: Date | string
    status?: $Enums.InvoiceStatus
    payment_qr_url?: string | null
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    paid_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InvoiceCreateOrConnectWithoutPaymentsInput = {
    where: InvoiceWhereUniqueInput
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
  }

  export type InvoiceUpsertWithoutPaymentsInput = {
    update: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
    create: XOR<InvoiceCreateWithoutPaymentsInput, InvoiceUncheckedCreateWithoutPaymentsInput>
    where?: InvoiceWhereInput
  }

  export type InvoiceUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: InvoiceWhereInput
    data: XOR<InvoiceUpdateWithoutPaymentsInput, InvoiceUncheckedUpdateWithoutPaymentsInput>
  }

  export type InvoiceUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    payment_qr_url?: NullableStringFieldUpdateOperationsInput | string | null
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutInvoicesNestedInput
    client?: UserUpdateOneRequiredWithoutInvoicesNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    payment_qr_url?: NullableStringFieldUpdateOperationsInput | string | null
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateWithoutEmployeeInput = {
    id?: string
    date: Date | string
    status: string
    overtime_hours?: number
    check_in?: Date | string | null
    check_out?: Date | string | null
    created_at?: Date | string
    project?: ProjectCreateNestedOneWithoutAttendanceInput
  }

  export type AttendanceUncheckedCreateWithoutEmployeeInput = {
    id?: string
    date: Date | string
    status: string
    overtime_hours?: number
    project_id?: string | null
    check_in?: Date | string | null
    check_out?: Date | string | null
    created_at?: Date | string
  }

  export type AttendanceCreateOrConnectWithoutEmployeeInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutEmployeeInput, AttendanceUncheckedCreateWithoutEmployeeInput>
  }

  export type AttendanceCreateManyEmployeeInputEnvelope = {
    data: AttendanceCreateManyEmployeeInput | AttendanceCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type LabourAllocationCreateWithoutEmployeeInput = {
    id?: string
    start_date: Date | string
    end_date?: Date | string | null
    status: string
    created_at?: Date | string
    project: ProjectCreateNestedOneWithoutLabour_allocationsInput
  }

  export type LabourAllocationUncheckedCreateWithoutEmployeeInput = {
    id?: string
    project_id: string
    start_date: Date | string
    end_date?: Date | string | null
    status: string
    created_at?: Date | string
  }

  export type LabourAllocationCreateOrConnectWithoutEmployeeInput = {
    where: LabourAllocationWhereUniqueInput
    create: XOR<LabourAllocationCreateWithoutEmployeeInput, LabourAllocationUncheckedCreateWithoutEmployeeInput>
  }

  export type LabourAllocationCreateManyEmployeeInputEnvelope = {
    data: LabourAllocationCreateManyEmployeeInput | LabourAllocationCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type PayrollLineCreateWithoutEmployeeInput = {
    id?: string
    basic_pay: Decimal | DecimalJsLike | number | string
    overtime_pay: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    total_pay: Decimal | DecimalJsLike | number | string
    status: string
    payroll: PayrollCreateNestedOneWithoutLinesInput
  }

  export type PayrollLineUncheckedCreateWithoutEmployeeInput = {
    id?: string
    payroll_id: string
    basic_pay: Decimal | DecimalJsLike | number | string
    overtime_pay: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    total_pay: Decimal | DecimalJsLike | number | string
    status: string
  }

  export type PayrollLineCreateOrConnectWithoutEmployeeInput = {
    where: PayrollLineWhereUniqueInput
    create: XOR<PayrollLineCreateWithoutEmployeeInput, PayrollLineUncheckedCreateWithoutEmployeeInput>
  }

  export type PayrollLineCreateManyEmployeeInputEnvelope = {
    data: PayrollLineCreateManyEmployeeInput | PayrollLineCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutEmployeeInput, AttendanceUncheckedUpdateWithoutEmployeeInput>
    create: XOR<AttendanceCreateWithoutEmployeeInput, AttendanceUncheckedCreateWithoutEmployeeInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutEmployeeInput, AttendanceUncheckedUpdateWithoutEmployeeInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutEmployeeInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type LabourAllocationUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: LabourAllocationWhereUniqueInput
    update: XOR<LabourAllocationUpdateWithoutEmployeeInput, LabourAllocationUncheckedUpdateWithoutEmployeeInput>
    create: XOR<LabourAllocationCreateWithoutEmployeeInput, LabourAllocationUncheckedCreateWithoutEmployeeInput>
  }

  export type LabourAllocationUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: LabourAllocationWhereUniqueInput
    data: XOR<LabourAllocationUpdateWithoutEmployeeInput, LabourAllocationUncheckedUpdateWithoutEmployeeInput>
  }

  export type LabourAllocationUpdateManyWithWhereWithoutEmployeeInput = {
    where: LabourAllocationScalarWhereInput
    data: XOR<LabourAllocationUpdateManyMutationInput, LabourAllocationUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type PayrollLineUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: PayrollLineWhereUniqueInput
    update: XOR<PayrollLineUpdateWithoutEmployeeInput, PayrollLineUncheckedUpdateWithoutEmployeeInput>
    create: XOR<PayrollLineCreateWithoutEmployeeInput, PayrollLineUncheckedCreateWithoutEmployeeInput>
  }

  export type PayrollLineUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: PayrollLineWhereUniqueInput
    data: XOR<PayrollLineUpdateWithoutEmployeeInput, PayrollLineUncheckedUpdateWithoutEmployeeInput>
  }

  export type PayrollLineUpdateManyWithWhereWithoutEmployeeInput = {
    where: PayrollLineScalarWhereInput
    data: XOR<PayrollLineUpdateManyMutationInput, PayrollLineUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type PayrollLineScalarWhereInput = {
    AND?: PayrollLineScalarWhereInput | PayrollLineScalarWhereInput[]
    OR?: PayrollLineScalarWhereInput[]
    NOT?: PayrollLineScalarWhereInput | PayrollLineScalarWhereInput[]
    id?: StringFilter<"PayrollLine"> | string
    payroll_id?: StringFilter<"PayrollLine"> | string
    employee_id?: StringFilter<"PayrollLine"> | string
    basic_pay?: DecimalFilter<"PayrollLine"> | Decimal | DecimalJsLike | number | string
    overtime_pay?: DecimalFilter<"PayrollLine"> | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFilter<"PayrollLine"> | Decimal | DecimalJsLike | number | string
    total_pay?: DecimalFilter<"PayrollLine"> | Decimal | DecimalJsLike | number | string
    status?: StringFilter<"PayrollLine"> | string
  }

  export type EmployeeCreateWithoutAttendanceInput = {
    id?: string
    employee_id: string
    name: string
    role: string
    skill_type: string
    employment_type: string
    department?: string | null
    joining_date: Date | string
    basic_salary?: Decimal | DecimalJsLike | number | string
    overtime_rate?: Decimal | DecimalJsLike | number | string
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.MemberStatus
    created_at?: Date | string
    updated_at?: Date | string
    allocations?: LabourAllocationCreateNestedManyWithoutEmployeeInput
    payroll_items?: PayrollLineCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutAttendanceInput = {
    id?: string
    employee_id: string
    name: string
    role: string
    skill_type: string
    employment_type: string
    department?: string | null
    joining_date: Date | string
    basic_salary?: Decimal | DecimalJsLike | number | string
    overtime_rate?: Decimal | DecimalJsLike | number | string
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.MemberStatus
    created_at?: Date | string
    updated_at?: Date | string
    allocations?: LabourAllocationUncheckedCreateNestedManyWithoutEmployeeInput
    payroll_items?: PayrollLineUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutAttendanceInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutAttendanceInput, EmployeeUncheckedCreateWithoutAttendanceInput>
  }

  export type ProjectCreateWithoutAttendanceInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.ProjectStatus
    github_link?: string | null
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    actual_cost?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    test_asset_url?: string | null
    deployment_url?: string | null
    live_preview_type?: string | null
    live_preview_url?: string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectCreatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    client: UserCreateNestedOneWithoutProjectsInput
    files?: ProjectFileCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateCreateNestedManyWithoutProjectInput
    support_requests?: SupportRequestCreateNestedManyWithoutProjectInput
    meeting_requests?: MeetingRequestCreateNestedManyWithoutProjectInput
    invoices?: InvoiceCreateNestedManyWithoutProjectInput
    inventory_logs?: InventoryTransactionCreateNestedManyWithoutProjectInput
    purchase_requests?: PurchaseRequestCreateNestedManyWithoutProjectInput
    labour_allocations?: LabourAllocationCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutAttendanceInput = {
    id?: string
    client_id: string
    title: string
    description: string
    status?: $Enums.ProjectStatus
    github_link?: string | null
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    actual_cost?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    test_asset_url?: string | null
    deployment_url?: string | null
    live_preview_type?: string | null
    live_preview_url?: string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectCreatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    files?: ProjectFileUncheckedCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput
    support_requests?: SupportRequestUncheckedCreateNestedManyWithoutProjectInput
    meeting_requests?: MeetingRequestUncheckedCreateNestedManyWithoutProjectInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutProjectInput
    inventory_logs?: InventoryTransactionUncheckedCreateNestedManyWithoutProjectInput
    purchase_requests?: PurchaseRequestUncheckedCreateNestedManyWithoutProjectInput
    labour_allocations?: LabourAllocationUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutAttendanceInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutAttendanceInput, ProjectUncheckedCreateWithoutAttendanceInput>
  }

  export type EmployeeUpsertWithoutAttendanceInput = {
    update: XOR<EmployeeUpdateWithoutAttendanceInput, EmployeeUncheckedUpdateWithoutAttendanceInput>
    create: XOR<EmployeeCreateWithoutAttendanceInput, EmployeeUncheckedCreateWithoutAttendanceInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutAttendanceInput, EmployeeUncheckedUpdateWithoutAttendanceInput>
  }

  export type EmployeeUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    skill_type?: StringFieldUpdateOperationsInput | string
    employment_type?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    joining_date?: DateTimeFieldUpdateOperationsInput | Date | string
    basic_salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtime_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    allocations?: LabourAllocationUpdateManyWithoutEmployeeNestedInput
    payroll_items?: PayrollLineUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    skill_type?: StringFieldUpdateOperationsInput | string
    employment_type?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    joining_date?: DateTimeFieldUpdateOperationsInput | Date | string
    basic_salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtime_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    allocations?: LabourAllocationUncheckedUpdateManyWithoutEmployeeNestedInput
    payroll_items?: PayrollLineUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type ProjectUpsertWithoutAttendanceInput = {
    update: XOR<ProjectUpdateWithoutAttendanceInput, ProjectUncheckedUpdateWithoutAttendanceInput>
    create: XOR<ProjectCreateWithoutAttendanceInput, ProjectUncheckedCreateWithoutAttendanceInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutAttendanceInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutAttendanceInput, ProjectUncheckedUpdateWithoutAttendanceInput>
  }

  export type ProjectUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    github_link?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actual_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_asset_url?: NullableStringFieldUpdateOperationsInput | string | null
    deployment_url?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_type?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_url?: NullableStringFieldUpdateOperationsInput | string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectUpdatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: UserUpdateOneRequiredWithoutProjectsNestedInput
    files?: ProjectFileUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUpdateManyWithoutProjectNestedInput
    support_requests?: SupportRequestUpdateManyWithoutProjectNestedInput
    meeting_requests?: MeetingRequestUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUpdateManyWithoutProjectNestedInput
    inventory_logs?: InventoryTransactionUpdateManyWithoutProjectNestedInput
    purchase_requests?: PurchaseRequestUpdateManyWithoutProjectNestedInput
    labour_allocations?: LabourAllocationUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutAttendanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    github_link?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actual_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_asset_url?: NullableStringFieldUpdateOperationsInput | string | null
    deployment_url?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_type?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_url?: NullableStringFieldUpdateOperationsInput | string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectUpdatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: ProjectFileUncheckedUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput
    support_requests?: SupportRequestUncheckedUpdateManyWithoutProjectNestedInput
    meeting_requests?: MeetingRequestUncheckedUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutProjectNestedInput
    inventory_logs?: InventoryTransactionUncheckedUpdateManyWithoutProjectNestedInput
    purchase_requests?: PurchaseRequestUncheckedUpdateManyWithoutProjectNestedInput
    labour_allocations?: LabourAllocationUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type EmployeeCreateWithoutAllocationsInput = {
    id?: string
    employee_id: string
    name: string
    role: string
    skill_type: string
    employment_type: string
    department?: string | null
    joining_date: Date | string
    basic_salary?: Decimal | DecimalJsLike | number | string
    overtime_rate?: Decimal | DecimalJsLike | number | string
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.MemberStatus
    created_at?: Date | string
    updated_at?: Date | string
    attendance?: AttendanceCreateNestedManyWithoutEmployeeInput
    payroll_items?: PayrollLineCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutAllocationsInput = {
    id?: string
    employee_id: string
    name: string
    role: string
    skill_type: string
    employment_type: string
    department?: string | null
    joining_date: Date | string
    basic_salary?: Decimal | DecimalJsLike | number | string
    overtime_rate?: Decimal | DecimalJsLike | number | string
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.MemberStatus
    created_at?: Date | string
    updated_at?: Date | string
    attendance?: AttendanceUncheckedCreateNestedManyWithoutEmployeeInput
    payroll_items?: PayrollLineUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutAllocationsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutAllocationsInput, EmployeeUncheckedCreateWithoutAllocationsInput>
  }

  export type ProjectCreateWithoutLabour_allocationsInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.ProjectStatus
    github_link?: string | null
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    actual_cost?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    test_asset_url?: string | null
    deployment_url?: string | null
    live_preview_type?: string | null
    live_preview_url?: string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectCreatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    client: UserCreateNestedOneWithoutProjectsInput
    files?: ProjectFileCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateCreateNestedManyWithoutProjectInput
    support_requests?: SupportRequestCreateNestedManyWithoutProjectInput
    meeting_requests?: MeetingRequestCreateNestedManyWithoutProjectInput
    invoices?: InvoiceCreateNestedManyWithoutProjectInput
    inventory_logs?: InventoryTransactionCreateNestedManyWithoutProjectInput
    purchase_requests?: PurchaseRequestCreateNestedManyWithoutProjectInput
    attendance?: AttendanceCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutLabour_allocationsInput = {
    id?: string
    client_id: string
    title: string
    description: string
    status?: $Enums.ProjectStatus
    github_link?: string | null
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    actual_cost?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    test_asset_url?: string | null
    deployment_url?: string | null
    live_preview_type?: string | null
    live_preview_url?: string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectCreatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    files?: ProjectFileUncheckedCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput
    support_requests?: SupportRequestUncheckedCreateNestedManyWithoutProjectInput
    meeting_requests?: MeetingRequestUncheckedCreateNestedManyWithoutProjectInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutProjectInput
    inventory_logs?: InventoryTransactionUncheckedCreateNestedManyWithoutProjectInput
    purchase_requests?: PurchaseRequestUncheckedCreateNestedManyWithoutProjectInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutLabour_allocationsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutLabour_allocationsInput, ProjectUncheckedCreateWithoutLabour_allocationsInput>
  }

  export type EmployeeUpsertWithoutAllocationsInput = {
    update: XOR<EmployeeUpdateWithoutAllocationsInput, EmployeeUncheckedUpdateWithoutAllocationsInput>
    create: XOR<EmployeeCreateWithoutAllocationsInput, EmployeeUncheckedCreateWithoutAllocationsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutAllocationsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutAllocationsInput, EmployeeUncheckedUpdateWithoutAllocationsInput>
  }

  export type EmployeeUpdateWithoutAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    skill_type?: StringFieldUpdateOperationsInput | string
    employment_type?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    joining_date?: DateTimeFieldUpdateOperationsInput | Date | string
    basic_salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtime_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: AttendanceUpdateManyWithoutEmployeeNestedInput
    payroll_items?: PayrollLineUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutAllocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    skill_type?: StringFieldUpdateOperationsInput | string
    employment_type?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    joining_date?: DateTimeFieldUpdateOperationsInput | Date | string
    basic_salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtime_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: AttendanceUncheckedUpdateManyWithoutEmployeeNestedInput
    payroll_items?: PayrollLineUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type ProjectUpsertWithoutLabour_allocationsInput = {
    update: XOR<ProjectUpdateWithoutLabour_allocationsInput, ProjectUncheckedUpdateWithoutLabour_allocationsInput>
    create: XOR<ProjectCreateWithoutLabour_allocationsInput, ProjectUncheckedCreateWithoutLabour_allocationsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutLabour_allocationsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutLabour_allocationsInput, ProjectUncheckedUpdateWithoutLabour_allocationsInput>
  }

  export type ProjectUpdateWithoutLabour_allocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    github_link?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actual_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_asset_url?: NullableStringFieldUpdateOperationsInput | string | null
    deployment_url?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_type?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_url?: NullableStringFieldUpdateOperationsInput | string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectUpdatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: UserUpdateOneRequiredWithoutProjectsNestedInput
    files?: ProjectFileUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUpdateManyWithoutProjectNestedInput
    support_requests?: SupportRequestUpdateManyWithoutProjectNestedInput
    meeting_requests?: MeetingRequestUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUpdateManyWithoutProjectNestedInput
    inventory_logs?: InventoryTransactionUpdateManyWithoutProjectNestedInput
    purchase_requests?: PurchaseRequestUpdateManyWithoutProjectNestedInput
    attendance?: AttendanceUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutLabour_allocationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    github_link?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actual_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_asset_url?: NullableStringFieldUpdateOperationsInput | string | null
    deployment_url?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_type?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_url?: NullableStringFieldUpdateOperationsInput | string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectUpdatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: ProjectFileUncheckedUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput
    support_requests?: SupportRequestUncheckedUpdateManyWithoutProjectNestedInput
    meeting_requests?: MeetingRequestUncheckedUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutProjectNestedInput
    inventory_logs?: InventoryTransactionUncheckedUpdateManyWithoutProjectNestedInput
    purchase_requests?: PurchaseRequestUncheckedUpdateManyWithoutProjectNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type PayrollLineCreateWithoutPayrollInput = {
    id?: string
    basic_pay: Decimal | DecimalJsLike | number | string
    overtime_pay: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    total_pay: Decimal | DecimalJsLike | number | string
    status: string
    employee: EmployeeCreateNestedOneWithoutPayroll_itemsInput
  }

  export type PayrollLineUncheckedCreateWithoutPayrollInput = {
    id?: string
    employee_id: string
    basic_pay: Decimal | DecimalJsLike | number | string
    overtime_pay: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    total_pay: Decimal | DecimalJsLike | number | string
    status: string
  }

  export type PayrollLineCreateOrConnectWithoutPayrollInput = {
    where: PayrollLineWhereUniqueInput
    create: XOR<PayrollLineCreateWithoutPayrollInput, PayrollLineUncheckedCreateWithoutPayrollInput>
  }

  export type PayrollLineCreateManyPayrollInputEnvelope = {
    data: PayrollLineCreateManyPayrollInput | PayrollLineCreateManyPayrollInput[]
    skipDuplicates?: boolean
  }

  export type PayrollLineUpsertWithWhereUniqueWithoutPayrollInput = {
    where: PayrollLineWhereUniqueInput
    update: XOR<PayrollLineUpdateWithoutPayrollInput, PayrollLineUncheckedUpdateWithoutPayrollInput>
    create: XOR<PayrollLineCreateWithoutPayrollInput, PayrollLineUncheckedCreateWithoutPayrollInput>
  }

  export type PayrollLineUpdateWithWhereUniqueWithoutPayrollInput = {
    where: PayrollLineWhereUniqueInput
    data: XOR<PayrollLineUpdateWithoutPayrollInput, PayrollLineUncheckedUpdateWithoutPayrollInput>
  }

  export type PayrollLineUpdateManyWithWhereWithoutPayrollInput = {
    where: PayrollLineScalarWhereInput
    data: XOR<PayrollLineUpdateManyMutationInput, PayrollLineUncheckedUpdateManyWithoutPayrollInput>
  }

  export type PayrollCreateWithoutLinesInput = {
    id?: string
    month: string
    status: string
    total_amount: Decimal | DecimalJsLike | number | string
    approved_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PayrollUncheckedCreateWithoutLinesInput = {
    id?: string
    month: string
    status: string
    total_amount: Decimal | DecimalJsLike | number | string
    approved_by?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PayrollCreateOrConnectWithoutLinesInput = {
    where: PayrollWhereUniqueInput
    create: XOR<PayrollCreateWithoutLinesInput, PayrollUncheckedCreateWithoutLinesInput>
  }

  export type EmployeeCreateWithoutPayroll_itemsInput = {
    id?: string
    employee_id: string
    name: string
    role: string
    skill_type: string
    employment_type: string
    department?: string | null
    joining_date: Date | string
    basic_salary?: Decimal | DecimalJsLike | number | string
    overtime_rate?: Decimal | DecimalJsLike | number | string
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.MemberStatus
    created_at?: Date | string
    updated_at?: Date | string
    attendance?: AttendanceCreateNestedManyWithoutEmployeeInput
    allocations?: LabourAllocationCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutPayroll_itemsInput = {
    id?: string
    employee_id: string
    name: string
    role: string
    skill_type: string
    employment_type: string
    department?: string | null
    joining_date: Date | string
    basic_salary?: Decimal | DecimalJsLike | number | string
    overtime_rate?: Decimal | DecimalJsLike | number | string
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    status?: $Enums.MemberStatus
    created_at?: Date | string
    updated_at?: Date | string
    attendance?: AttendanceUncheckedCreateNestedManyWithoutEmployeeInput
    allocations?: LabourAllocationUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutPayroll_itemsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutPayroll_itemsInput, EmployeeUncheckedCreateWithoutPayroll_itemsInput>
  }

  export type PayrollUpsertWithoutLinesInput = {
    update: XOR<PayrollUpdateWithoutLinesInput, PayrollUncheckedUpdateWithoutLinesInput>
    create: XOR<PayrollCreateWithoutLinesInput, PayrollUncheckedCreateWithoutLinesInput>
    where?: PayrollWhereInput
  }

  export type PayrollUpdateToOneWithWhereWithoutLinesInput = {
    where?: PayrollWhereInput
    data: XOR<PayrollUpdateWithoutLinesInput, PayrollUncheckedUpdateWithoutLinesInput>
  }

  export type PayrollUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollUncheckedUpdateWithoutLinesInput = {
    id?: StringFieldUpdateOperationsInput | string
    month?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    approved_by?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUpsertWithoutPayroll_itemsInput = {
    update: XOR<EmployeeUpdateWithoutPayroll_itemsInput, EmployeeUncheckedUpdateWithoutPayroll_itemsInput>
    create: XOR<EmployeeCreateWithoutPayroll_itemsInput, EmployeeUncheckedCreateWithoutPayroll_itemsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutPayroll_itemsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutPayroll_itemsInput, EmployeeUncheckedUpdateWithoutPayroll_itemsInput>
  }

  export type EmployeeUpdateWithoutPayroll_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    skill_type?: StringFieldUpdateOperationsInput | string
    employment_type?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    joining_date?: DateTimeFieldUpdateOperationsInput | Date | string
    basic_salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtime_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: AttendanceUpdateManyWithoutEmployeeNestedInput
    allocations?: LabourAllocationUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutPayroll_itemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    skill_type?: StringFieldUpdateOperationsInput | string
    employment_type?: StringFieldUpdateOperationsInput | string
    department?: NullableStringFieldUpdateOperationsInput | string | null
    joining_date?: DateTimeFieldUpdateOperationsInput | Date | string
    basic_salary?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtime_rate?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    status?: EnumMemberStatusFieldUpdateOperationsInput | $Enums.MemberStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    attendance?: AttendanceUncheckedUpdateManyWithoutEmployeeNestedInput
    allocations?: LabourAllocationUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password?: string | null
    full_name: string
    role?: $Enums.UserRole
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    projects?: ProjectCreateNestedManyWithoutClientInput
    project_files?: ProjectFileCreateNestedManyWithoutUploaderInput
    project_updates?: ProjectUpdateCreateNestedManyWithoutAuthorInput
    support_requests?: SupportRequestCreateNestedManyWithoutClientInput
    support_messages?: SupportMessageCreateNestedManyWithoutSenderInput
    meeting_requests?: MeetingRequestCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    inventory_logs?: InventoryTransactionCreateNestedManyWithoutUserInput
    purchase_requests?: PurchaseRequestCreateNestedManyWithoutRequesterInput
    purchase_orders?: PurchaseOrderCreateNestedManyWithoutCreatorInput
    grns?: GRNCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    email: string
    password?: string | null
    full_name: string
    role?: $Enums.UserRole
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    project_files?: ProjectFileUncheckedCreateNestedManyWithoutUploaderInput
    project_updates?: ProjectUpdateUncheckedCreateNestedManyWithoutAuthorInput
    support_requests?: SupportRequestUncheckedCreateNestedManyWithoutClientInput
    support_messages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
    meeting_requests?: MeetingRequestUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    inventory_logs?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    purchase_requests?: PurchaseRequestUncheckedCreateNestedManyWithoutRequesterInput
    purchase_orders?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatorInput
    grns?: GRNUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutClientNestedInput
    project_files?: ProjectFileUpdateManyWithoutUploaderNestedInput
    project_updates?: ProjectUpdateUpdateManyWithoutAuthorNestedInput
    support_requests?: SupportRequestUpdateManyWithoutClientNestedInput
    support_messages?: SupportMessageUpdateManyWithoutSenderNestedInput
    meeting_requests?: MeetingRequestUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    inventory_logs?: InventoryTransactionUpdateManyWithoutUserNestedInput
    purchase_requests?: PurchaseRequestUpdateManyWithoutRequesterNestedInput
    purchase_orders?: PurchaseOrderUpdateManyWithoutCreatorNestedInput
    grns?: GRNUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    project_files?: ProjectFileUncheckedUpdateManyWithoutUploaderNestedInput
    project_updates?: ProjectUpdateUncheckedUpdateManyWithoutAuthorNestedInput
    support_requests?: SupportRequestUncheckedUpdateManyWithoutClientNestedInput
    support_messages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
    meeting_requests?: MeetingRequestUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    inventory_logs?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    purchase_requests?: PurchaseRequestUncheckedUpdateManyWithoutRequesterNestedInput
    purchase_orders?: PurchaseOrderUncheckedUpdateManyWithoutCreatorNestedInput
    grns?: GRNUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type UserCreateWithoutTransactionsInput = {
    id?: string
    email: string
    password?: string | null
    full_name: string
    role?: $Enums.UserRole
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    projects?: ProjectCreateNestedManyWithoutClientInput
    project_files?: ProjectFileCreateNestedManyWithoutUploaderInput
    project_updates?: ProjectUpdateCreateNestedManyWithoutAuthorInput
    support_requests?: SupportRequestCreateNestedManyWithoutClientInput
    support_messages?: SupportMessageCreateNestedManyWithoutSenderInput
    meeting_requests?: MeetingRequestCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    inventory_logs?: InventoryTransactionCreateNestedManyWithoutUserInput
    purchase_requests?: PurchaseRequestCreateNestedManyWithoutRequesterInput
    purchase_orders?: PurchaseOrderCreateNestedManyWithoutCreatorInput
    grns?: GRNCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutTransactionsInput = {
    id?: string
    email: string
    password?: string | null
    full_name: string
    role?: $Enums.UserRole
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    project_files?: ProjectFileUncheckedCreateNestedManyWithoutUploaderInput
    project_updates?: ProjectUpdateUncheckedCreateNestedManyWithoutAuthorInput
    support_requests?: SupportRequestUncheckedCreateNestedManyWithoutClientInput
    support_messages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
    meeting_requests?: MeetingRequestUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    inventory_logs?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    purchase_requests?: PurchaseRequestUncheckedCreateNestedManyWithoutRequesterInput
    purchase_orders?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatorInput
    grns?: GRNUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutTransactionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
  }

  export type UserUpsertWithoutTransactionsInput = {
    update: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
    create: XOR<UserCreateWithoutTransactionsInput, UserUncheckedCreateWithoutTransactionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTransactionsInput, UserUncheckedUpdateWithoutTransactionsInput>
  }

  export type UserUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutClientNestedInput
    project_files?: ProjectFileUpdateManyWithoutUploaderNestedInput
    project_updates?: ProjectUpdateUpdateManyWithoutAuthorNestedInput
    support_requests?: SupportRequestUpdateManyWithoutClientNestedInput
    support_messages?: SupportMessageUpdateManyWithoutSenderNestedInput
    meeting_requests?: MeetingRequestUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    inventory_logs?: InventoryTransactionUpdateManyWithoutUserNestedInput
    purchase_requests?: PurchaseRequestUpdateManyWithoutRequesterNestedInput
    purchase_orders?: PurchaseOrderUpdateManyWithoutCreatorNestedInput
    grns?: GRNUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    project_files?: ProjectFileUncheckedUpdateManyWithoutUploaderNestedInput
    project_updates?: ProjectUpdateUncheckedUpdateManyWithoutAuthorNestedInput
    support_requests?: SupportRequestUncheckedUpdateManyWithoutClientNestedInput
    support_messages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
    meeting_requests?: MeetingRequestUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    inventory_logs?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    purchase_requests?: PurchaseRequestUncheckedUpdateManyWithoutRequesterNestedInput
    purchase_orders?: PurchaseOrderUncheckedUpdateManyWithoutCreatorNestedInput
    grns?: GRNUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type InventoryTransactionCreateWithoutItemInput = {
    id?: string
    type: $Enums.InventoryTransactionType
    quantity: number
    date?: Date | string
    reference_no?: string | null
    notes?: string | null
    created_at?: Date | string
    project?: ProjectCreateNestedOneWithoutInventory_logsInput
    user: UserCreateNestedOneWithoutInventory_logsInput
  }

  export type InventoryTransactionUncheckedCreateWithoutItemInput = {
    id?: string
    project_id?: string | null
    type: $Enums.InventoryTransactionType
    quantity: number
    date?: Date | string
    reference_no?: string | null
    notes?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type InventoryTransactionCreateOrConnectWithoutItemInput = {
    where: InventoryTransactionWhereUniqueInput
    create: XOR<InventoryTransactionCreateWithoutItemInput, InventoryTransactionUncheckedCreateWithoutItemInput>
  }

  export type InventoryTransactionCreateManyItemInputEnvelope = {
    data: InventoryTransactionCreateManyItemInput | InventoryTransactionCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type InventoryTransactionUpsertWithWhereUniqueWithoutItemInput = {
    where: InventoryTransactionWhereUniqueInput
    update: XOR<InventoryTransactionUpdateWithoutItemInput, InventoryTransactionUncheckedUpdateWithoutItemInput>
    create: XOR<InventoryTransactionCreateWithoutItemInput, InventoryTransactionUncheckedCreateWithoutItemInput>
  }

  export type InventoryTransactionUpdateWithWhereUniqueWithoutItemInput = {
    where: InventoryTransactionWhereUniqueInput
    data: XOR<InventoryTransactionUpdateWithoutItemInput, InventoryTransactionUncheckedUpdateWithoutItemInput>
  }

  export type InventoryTransactionUpdateManyWithWhereWithoutItemInput = {
    where: InventoryTransactionScalarWhereInput
    data: XOR<InventoryTransactionUpdateManyMutationInput, InventoryTransactionUncheckedUpdateManyWithoutItemInput>
  }

  export type InventoryItemCreateWithoutTransactionsInput = {
    id?: string
    code: string
    name: string
    category: string
    unit: string
    current_stock?: number
    min_stock?: number | null
    cost_price?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InventoryItemUncheckedCreateWithoutTransactionsInput = {
    id?: string
    code: string
    name: string
    category: string
    unit: string
    current_stock?: number
    min_stock?: number | null
    cost_price?: Decimal | DecimalJsLike | number | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InventoryItemCreateOrConnectWithoutTransactionsInput = {
    where: InventoryItemWhereUniqueInput
    create: XOR<InventoryItemCreateWithoutTransactionsInput, InventoryItemUncheckedCreateWithoutTransactionsInput>
  }

  export type ProjectCreateWithoutInventory_logsInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.ProjectStatus
    github_link?: string | null
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    actual_cost?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    test_asset_url?: string | null
    deployment_url?: string | null
    live_preview_type?: string | null
    live_preview_url?: string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectCreatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    client: UserCreateNestedOneWithoutProjectsInput
    files?: ProjectFileCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateCreateNestedManyWithoutProjectInput
    support_requests?: SupportRequestCreateNestedManyWithoutProjectInput
    meeting_requests?: MeetingRequestCreateNestedManyWithoutProjectInput
    invoices?: InvoiceCreateNestedManyWithoutProjectInput
    purchase_requests?: PurchaseRequestCreateNestedManyWithoutProjectInput
    attendance?: AttendanceCreateNestedManyWithoutProjectInput
    labour_allocations?: LabourAllocationCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutInventory_logsInput = {
    id?: string
    client_id: string
    title: string
    description: string
    status?: $Enums.ProjectStatus
    github_link?: string | null
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    actual_cost?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    test_asset_url?: string | null
    deployment_url?: string | null
    live_preview_type?: string | null
    live_preview_url?: string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectCreatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    files?: ProjectFileUncheckedCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput
    support_requests?: SupportRequestUncheckedCreateNestedManyWithoutProjectInput
    meeting_requests?: MeetingRequestUncheckedCreateNestedManyWithoutProjectInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutProjectInput
    purchase_requests?: PurchaseRequestUncheckedCreateNestedManyWithoutProjectInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutProjectInput
    labour_allocations?: LabourAllocationUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutInventory_logsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutInventory_logsInput, ProjectUncheckedCreateWithoutInventory_logsInput>
  }

  export type UserCreateWithoutInventory_logsInput = {
    id?: string
    email: string
    password?: string | null
    full_name: string
    role?: $Enums.UserRole
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    projects?: ProjectCreateNestedManyWithoutClientInput
    project_files?: ProjectFileCreateNestedManyWithoutUploaderInput
    project_updates?: ProjectUpdateCreateNestedManyWithoutAuthorInput
    support_requests?: SupportRequestCreateNestedManyWithoutClientInput
    support_messages?: SupportMessageCreateNestedManyWithoutSenderInput
    meeting_requests?: MeetingRequestCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    purchase_requests?: PurchaseRequestCreateNestedManyWithoutRequesterInput
    purchase_orders?: PurchaseOrderCreateNestedManyWithoutCreatorInput
    grns?: GRNCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutInventory_logsInput = {
    id?: string
    email: string
    password?: string | null
    full_name: string
    role?: $Enums.UserRole
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    project_files?: ProjectFileUncheckedCreateNestedManyWithoutUploaderInput
    project_updates?: ProjectUpdateUncheckedCreateNestedManyWithoutAuthorInput
    support_requests?: SupportRequestUncheckedCreateNestedManyWithoutClientInput
    support_messages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
    meeting_requests?: MeetingRequestUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    purchase_requests?: PurchaseRequestUncheckedCreateNestedManyWithoutRequesterInput
    purchase_orders?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatorInput
    grns?: GRNUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutInventory_logsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInventory_logsInput, UserUncheckedCreateWithoutInventory_logsInput>
  }

  export type InventoryItemUpsertWithoutTransactionsInput = {
    update: XOR<InventoryItemUpdateWithoutTransactionsInput, InventoryItemUncheckedUpdateWithoutTransactionsInput>
    create: XOR<InventoryItemCreateWithoutTransactionsInput, InventoryItemUncheckedCreateWithoutTransactionsInput>
    where?: InventoryItemWhereInput
  }

  export type InventoryItemUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: InventoryItemWhereInput
    data: XOR<InventoryItemUpdateWithoutTransactionsInput, InventoryItemUncheckedUpdateWithoutTransactionsInput>
  }

  export type InventoryItemUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    current_stock?: FloatFieldUpdateOperationsInput | number
    min_stock?: NullableFloatFieldUpdateOperationsInput | number | null
    cost_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryItemUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    category?: StringFieldUpdateOperationsInput | string
    unit?: StringFieldUpdateOperationsInput | string
    current_stock?: FloatFieldUpdateOperationsInput | number
    min_stock?: NullableFloatFieldUpdateOperationsInput | number | null
    cost_price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpsertWithoutInventory_logsInput = {
    update: XOR<ProjectUpdateWithoutInventory_logsInput, ProjectUncheckedUpdateWithoutInventory_logsInput>
    create: XOR<ProjectCreateWithoutInventory_logsInput, ProjectUncheckedCreateWithoutInventory_logsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutInventory_logsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutInventory_logsInput, ProjectUncheckedUpdateWithoutInventory_logsInput>
  }

  export type ProjectUpdateWithoutInventory_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    github_link?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actual_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_asset_url?: NullableStringFieldUpdateOperationsInput | string | null
    deployment_url?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_type?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_url?: NullableStringFieldUpdateOperationsInput | string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectUpdatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: UserUpdateOneRequiredWithoutProjectsNestedInput
    files?: ProjectFileUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUpdateManyWithoutProjectNestedInput
    support_requests?: SupportRequestUpdateManyWithoutProjectNestedInput
    meeting_requests?: MeetingRequestUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUpdateManyWithoutProjectNestedInput
    purchase_requests?: PurchaseRequestUpdateManyWithoutProjectNestedInput
    attendance?: AttendanceUpdateManyWithoutProjectNestedInput
    labour_allocations?: LabourAllocationUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutInventory_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    github_link?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actual_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_asset_url?: NullableStringFieldUpdateOperationsInput | string | null
    deployment_url?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_type?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_url?: NullableStringFieldUpdateOperationsInput | string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectUpdatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: ProjectFileUncheckedUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput
    support_requests?: SupportRequestUncheckedUpdateManyWithoutProjectNestedInput
    meeting_requests?: MeetingRequestUncheckedUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutProjectNestedInput
    purchase_requests?: PurchaseRequestUncheckedUpdateManyWithoutProjectNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutProjectNestedInput
    labour_allocations?: LabourAllocationUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutInventory_logsInput = {
    update: XOR<UserUpdateWithoutInventory_logsInput, UserUncheckedUpdateWithoutInventory_logsInput>
    create: XOR<UserCreateWithoutInventory_logsInput, UserUncheckedCreateWithoutInventory_logsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInventory_logsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInventory_logsInput, UserUncheckedUpdateWithoutInventory_logsInput>
  }

  export type UserUpdateWithoutInventory_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutClientNestedInput
    project_files?: ProjectFileUpdateManyWithoutUploaderNestedInput
    project_updates?: ProjectUpdateUpdateManyWithoutAuthorNestedInput
    support_requests?: SupportRequestUpdateManyWithoutClientNestedInput
    support_messages?: SupportMessageUpdateManyWithoutSenderNestedInput
    meeting_requests?: MeetingRequestUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    purchase_requests?: PurchaseRequestUpdateManyWithoutRequesterNestedInput
    purchase_orders?: PurchaseOrderUpdateManyWithoutCreatorNestedInput
    grns?: GRNUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutInventory_logsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    project_files?: ProjectFileUncheckedUpdateManyWithoutUploaderNestedInput
    project_updates?: ProjectUpdateUncheckedUpdateManyWithoutAuthorNestedInput
    support_requests?: SupportRequestUncheckedUpdateManyWithoutClientNestedInput
    support_messages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
    meeting_requests?: MeetingRequestUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    purchase_requests?: PurchaseRequestUncheckedUpdateManyWithoutRequesterNestedInput
    purchase_orders?: PurchaseOrderUncheckedUpdateManyWithoutCreatorNestedInput
    grns?: GRNUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type ProjectCreateWithoutPurchase_requestsInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.ProjectStatus
    github_link?: string | null
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    actual_cost?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    test_asset_url?: string | null
    deployment_url?: string | null
    live_preview_type?: string | null
    live_preview_url?: string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectCreatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    client: UserCreateNestedOneWithoutProjectsInput
    files?: ProjectFileCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateCreateNestedManyWithoutProjectInput
    support_requests?: SupportRequestCreateNestedManyWithoutProjectInput
    meeting_requests?: MeetingRequestCreateNestedManyWithoutProjectInput
    invoices?: InvoiceCreateNestedManyWithoutProjectInput
    inventory_logs?: InventoryTransactionCreateNestedManyWithoutProjectInput
    attendance?: AttendanceCreateNestedManyWithoutProjectInput
    labour_allocations?: LabourAllocationCreateNestedManyWithoutProjectInput
  }

  export type ProjectUncheckedCreateWithoutPurchase_requestsInput = {
    id?: string
    client_id: string
    title: string
    description: string
    status?: $Enums.ProjectStatus
    github_link?: string | null
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    actual_cost?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    test_asset_url?: string | null
    deployment_url?: string | null
    live_preview_type?: string | null
    live_preview_url?: string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectCreatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
    files?: ProjectFileUncheckedCreateNestedManyWithoutProjectInput
    updates?: ProjectUpdateUncheckedCreateNestedManyWithoutProjectInput
    support_requests?: SupportRequestUncheckedCreateNestedManyWithoutProjectInput
    meeting_requests?: MeetingRequestUncheckedCreateNestedManyWithoutProjectInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutProjectInput
    inventory_logs?: InventoryTransactionUncheckedCreateNestedManyWithoutProjectInput
    attendance?: AttendanceUncheckedCreateNestedManyWithoutProjectInput
    labour_allocations?: LabourAllocationUncheckedCreateNestedManyWithoutProjectInput
  }

  export type ProjectCreateOrConnectWithoutPurchase_requestsInput = {
    where: ProjectWhereUniqueInput
    create: XOR<ProjectCreateWithoutPurchase_requestsInput, ProjectUncheckedCreateWithoutPurchase_requestsInput>
  }

  export type UserCreateWithoutPurchase_requestsInput = {
    id?: string
    email: string
    password?: string | null
    full_name: string
    role?: $Enums.UserRole
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    projects?: ProjectCreateNestedManyWithoutClientInput
    project_files?: ProjectFileCreateNestedManyWithoutUploaderInput
    project_updates?: ProjectUpdateCreateNestedManyWithoutAuthorInput
    support_requests?: SupportRequestCreateNestedManyWithoutClientInput
    support_messages?: SupportMessageCreateNestedManyWithoutSenderInput
    meeting_requests?: MeetingRequestCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    inventory_logs?: InventoryTransactionCreateNestedManyWithoutUserInput
    purchase_orders?: PurchaseOrderCreateNestedManyWithoutCreatorInput
    grns?: GRNCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutPurchase_requestsInput = {
    id?: string
    email: string
    password?: string | null
    full_name: string
    role?: $Enums.UserRole
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    project_files?: ProjectFileUncheckedCreateNestedManyWithoutUploaderInput
    project_updates?: ProjectUpdateUncheckedCreateNestedManyWithoutAuthorInput
    support_requests?: SupportRequestUncheckedCreateNestedManyWithoutClientInput
    support_messages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
    meeting_requests?: MeetingRequestUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    inventory_logs?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    purchase_orders?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatorInput
    grns?: GRNUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutPurchase_requestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPurchase_requestsInput, UserUncheckedCreateWithoutPurchase_requestsInput>
  }

  export type PurchaseOrderCreateWithoutPurchase_requestInput = {
    id?: string
    po_number: string
    total_amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.PurchaseStatus
    created_at?: Date | string
    updated_at?: Date | string
    vendor: VendorCreateNestedOneWithoutPurchase_ordersInput
    creator: UserCreateNestedOneWithoutPurchase_ordersInput
    grns?: GRNCreateNestedManyWithoutPurchase_orderInput
    vendor_bills?: VendorBillCreateNestedManyWithoutPurchase_orderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutPurchase_requestInput = {
    id?: string
    po_number: string
    vendor_id: string
    total_amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.PurchaseStatus
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    grns?: GRNUncheckedCreateNestedManyWithoutPurchase_orderInput
    vendor_bills?: VendorBillUncheckedCreateNestedManyWithoutPurchase_orderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutPurchase_requestInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutPurchase_requestInput, PurchaseOrderUncheckedCreateWithoutPurchase_requestInput>
  }

  export type PurchaseOrderCreateManyPurchase_requestInputEnvelope = {
    data: PurchaseOrderCreateManyPurchase_requestInput | PurchaseOrderCreateManyPurchase_requestInput[]
    skipDuplicates?: boolean
  }

  export type ProjectUpsertWithoutPurchase_requestsInput = {
    update: XOR<ProjectUpdateWithoutPurchase_requestsInput, ProjectUncheckedUpdateWithoutPurchase_requestsInput>
    create: XOR<ProjectCreateWithoutPurchase_requestsInput, ProjectUncheckedCreateWithoutPurchase_requestsInput>
    where?: ProjectWhereInput
  }

  export type ProjectUpdateToOneWithWhereWithoutPurchase_requestsInput = {
    where?: ProjectWhereInput
    data: XOR<ProjectUpdateWithoutPurchase_requestsInput, ProjectUncheckedUpdateWithoutPurchase_requestsInput>
  }

  export type ProjectUpdateWithoutPurchase_requestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    github_link?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actual_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_asset_url?: NullableStringFieldUpdateOperationsInput | string | null
    deployment_url?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_type?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_url?: NullableStringFieldUpdateOperationsInput | string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectUpdatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: UserUpdateOneRequiredWithoutProjectsNestedInput
    files?: ProjectFileUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUpdateManyWithoutProjectNestedInput
    support_requests?: SupportRequestUpdateManyWithoutProjectNestedInput
    meeting_requests?: MeetingRequestUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUpdateManyWithoutProjectNestedInput
    inventory_logs?: InventoryTransactionUpdateManyWithoutProjectNestedInput
    attendance?: AttendanceUpdateManyWithoutProjectNestedInput
    labour_allocations?: LabourAllocationUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutPurchase_requestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    github_link?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actual_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_asset_url?: NullableStringFieldUpdateOperationsInput | string | null
    deployment_url?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_type?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_url?: NullableStringFieldUpdateOperationsInput | string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectUpdatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: ProjectFileUncheckedUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput
    support_requests?: SupportRequestUncheckedUpdateManyWithoutProjectNestedInput
    meeting_requests?: MeetingRequestUncheckedUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutProjectNestedInput
    inventory_logs?: InventoryTransactionUncheckedUpdateManyWithoutProjectNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutProjectNestedInput
    labour_allocations?: LabourAllocationUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type UserUpsertWithoutPurchase_requestsInput = {
    update: XOR<UserUpdateWithoutPurchase_requestsInput, UserUncheckedUpdateWithoutPurchase_requestsInput>
    create: XOR<UserCreateWithoutPurchase_requestsInput, UserUncheckedCreateWithoutPurchase_requestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPurchase_requestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPurchase_requestsInput, UserUncheckedUpdateWithoutPurchase_requestsInput>
  }

  export type UserUpdateWithoutPurchase_requestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutClientNestedInput
    project_files?: ProjectFileUpdateManyWithoutUploaderNestedInput
    project_updates?: ProjectUpdateUpdateManyWithoutAuthorNestedInput
    support_requests?: SupportRequestUpdateManyWithoutClientNestedInput
    support_messages?: SupportMessageUpdateManyWithoutSenderNestedInput
    meeting_requests?: MeetingRequestUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    inventory_logs?: InventoryTransactionUpdateManyWithoutUserNestedInput
    purchase_orders?: PurchaseOrderUpdateManyWithoutCreatorNestedInput
    grns?: GRNUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutPurchase_requestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    project_files?: ProjectFileUncheckedUpdateManyWithoutUploaderNestedInput
    project_updates?: ProjectUpdateUncheckedUpdateManyWithoutAuthorNestedInput
    support_requests?: SupportRequestUncheckedUpdateManyWithoutClientNestedInput
    support_messages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
    meeting_requests?: MeetingRequestUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    inventory_logs?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    purchase_orders?: PurchaseOrderUncheckedUpdateManyWithoutCreatorNestedInput
    grns?: GRNUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutPurchase_requestInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutPurchase_requestInput, PurchaseOrderUncheckedUpdateWithoutPurchase_requestInput>
    create: XOR<PurchaseOrderCreateWithoutPurchase_requestInput, PurchaseOrderUncheckedCreateWithoutPurchase_requestInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutPurchase_requestInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutPurchase_requestInput, PurchaseOrderUncheckedUpdateWithoutPurchase_requestInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutPurchase_requestInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutPurchase_requestInput>
  }

  export type PurchaseOrderCreateWithoutVendorInput = {
    id?: string
    po_number: string
    total_amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.PurchaseStatus
    created_at?: Date | string
    updated_at?: Date | string
    purchase_request?: PurchaseRequestCreateNestedOneWithoutPurchase_ordersInput
    creator: UserCreateNestedOneWithoutPurchase_ordersInput
    grns?: GRNCreateNestedManyWithoutPurchase_orderInput
    vendor_bills?: VendorBillCreateNestedManyWithoutPurchase_orderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutVendorInput = {
    id?: string
    po_number: string
    purchase_request_id?: string | null
    total_amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.PurchaseStatus
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    grns?: GRNUncheckedCreateNestedManyWithoutPurchase_orderInput
    vendor_bills?: VendorBillUncheckedCreateNestedManyWithoutPurchase_orderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutVendorInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutVendorInput, PurchaseOrderUncheckedCreateWithoutVendorInput>
  }

  export type PurchaseOrderCreateManyVendorInputEnvelope = {
    data: PurchaseOrderCreateManyVendorInput | PurchaseOrderCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type VendorBillCreateWithoutVendorInput = {
    id?: string
    bill_number: string
    amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    due_date: Date | string
    status?: $Enums.InvoiceStatus
    created_at?: Date | string
    updated_at?: Date | string
    purchase_order: PurchaseOrderCreateNestedOneWithoutVendor_billsInput
    vendor_payments?: VendorPaymentCreateNestedManyWithoutVendor_billInput
  }

  export type VendorBillUncheckedCreateWithoutVendorInput = {
    id?: string
    bill_number: string
    purchase_order_id: string
    amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    due_date: Date | string
    status?: $Enums.InvoiceStatus
    created_at?: Date | string
    updated_at?: Date | string
    vendor_payments?: VendorPaymentUncheckedCreateNestedManyWithoutVendor_billInput
  }

  export type VendorBillCreateOrConnectWithoutVendorInput = {
    where: VendorBillWhereUniqueInput
    create: XOR<VendorBillCreateWithoutVendorInput, VendorBillUncheckedCreateWithoutVendorInput>
  }

  export type VendorBillCreateManyVendorInputEnvelope = {
    data: VendorBillCreateManyVendorInput | VendorBillCreateManyVendorInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderUpsertWithWhereUniqueWithoutVendorInput = {
    where: PurchaseOrderWhereUniqueInput
    update: XOR<PurchaseOrderUpdateWithoutVendorInput, PurchaseOrderUncheckedUpdateWithoutVendorInput>
    create: XOR<PurchaseOrderCreateWithoutVendorInput, PurchaseOrderUncheckedCreateWithoutVendorInput>
  }

  export type PurchaseOrderUpdateWithWhereUniqueWithoutVendorInput = {
    where: PurchaseOrderWhereUniqueInput
    data: XOR<PurchaseOrderUpdateWithoutVendorInput, PurchaseOrderUncheckedUpdateWithoutVendorInput>
  }

  export type PurchaseOrderUpdateManyWithWhereWithoutVendorInput = {
    where: PurchaseOrderScalarWhereInput
    data: XOR<PurchaseOrderUpdateManyMutationInput, PurchaseOrderUncheckedUpdateManyWithoutVendorInput>
  }

  export type VendorBillUpsertWithWhereUniqueWithoutVendorInput = {
    where: VendorBillWhereUniqueInput
    update: XOR<VendorBillUpdateWithoutVendorInput, VendorBillUncheckedUpdateWithoutVendorInput>
    create: XOR<VendorBillCreateWithoutVendorInput, VendorBillUncheckedCreateWithoutVendorInput>
  }

  export type VendorBillUpdateWithWhereUniqueWithoutVendorInput = {
    where: VendorBillWhereUniqueInput
    data: XOR<VendorBillUpdateWithoutVendorInput, VendorBillUncheckedUpdateWithoutVendorInput>
  }

  export type VendorBillUpdateManyWithWhereWithoutVendorInput = {
    where: VendorBillScalarWhereInput
    data: XOR<VendorBillUpdateManyMutationInput, VendorBillUncheckedUpdateManyWithoutVendorInput>
  }

  export type VendorBillScalarWhereInput = {
    AND?: VendorBillScalarWhereInput | VendorBillScalarWhereInput[]
    OR?: VendorBillScalarWhereInput[]
    NOT?: VendorBillScalarWhereInput | VendorBillScalarWhereInput[]
    id?: StringFilter<"VendorBill"> | string
    bill_number?: StringFilter<"VendorBill"> | string
    purchase_order_id?: StringFilter<"VendorBill"> | string
    vendor_id?: StringFilter<"VendorBill"> | string
    amount?: DecimalFilter<"VendorBill"> | Decimal | DecimalJsLike | number | string
    tax_amount?: DecimalNullableFilter<"VendorBill"> | Decimal | DecimalJsLike | number | string | null
    due_date?: DateTimeFilter<"VendorBill"> | Date | string
    status?: EnumInvoiceStatusFilter<"VendorBill"> | $Enums.InvoiceStatus
    created_at?: DateTimeFilter<"VendorBill"> | Date | string
    updated_at?: DateTimeFilter<"VendorBill"> | Date | string
  }

  export type PurchaseRequestCreateWithoutPurchase_ordersInput = {
    id?: string
    item_name: string
    quantity: number
    unit: string
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    priority?: $Enums.PriorityLevel
    status?: $Enums.PurchaseStatus
    needed_by?: Date | string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    project?: ProjectCreateNestedOneWithoutPurchase_requestsInput
    requester: UserCreateNestedOneWithoutPurchase_requestsInput
  }

  export type PurchaseRequestUncheckedCreateWithoutPurchase_ordersInput = {
    id?: string
    project_id?: string | null
    item_name: string
    quantity: number
    unit: string
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    priority?: $Enums.PriorityLevel
    status?: $Enums.PurchaseStatus
    requested_by: string
    needed_by?: Date | string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PurchaseRequestCreateOrConnectWithoutPurchase_ordersInput = {
    where: PurchaseRequestWhereUniqueInput
    create: XOR<PurchaseRequestCreateWithoutPurchase_ordersInput, PurchaseRequestUncheckedCreateWithoutPurchase_ordersInput>
  }

  export type VendorCreateWithoutPurchase_ordersInput = {
    id?: string
    name: string
    contact_person?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    vat_no?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    vendor_bills?: VendorBillCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutPurchase_ordersInput = {
    id?: string
    name: string
    contact_person?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    vat_no?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    vendor_bills?: VendorBillUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutPurchase_ordersInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutPurchase_ordersInput, VendorUncheckedCreateWithoutPurchase_ordersInput>
  }

  export type UserCreateWithoutPurchase_ordersInput = {
    id?: string
    email: string
    password?: string | null
    full_name: string
    role?: $Enums.UserRole
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    projects?: ProjectCreateNestedManyWithoutClientInput
    project_files?: ProjectFileCreateNestedManyWithoutUploaderInput
    project_updates?: ProjectUpdateCreateNestedManyWithoutAuthorInput
    support_requests?: SupportRequestCreateNestedManyWithoutClientInput
    support_messages?: SupportMessageCreateNestedManyWithoutSenderInput
    meeting_requests?: MeetingRequestCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    inventory_logs?: InventoryTransactionCreateNestedManyWithoutUserInput
    purchase_requests?: PurchaseRequestCreateNestedManyWithoutRequesterInput
    grns?: GRNCreateNestedManyWithoutReceiverInput
  }

  export type UserUncheckedCreateWithoutPurchase_ordersInput = {
    id?: string
    email: string
    password?: string | null
    full_name: string
    role?: $Enums.UserRole
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    project_files?: ProjectFileUncheckedCreateNestedManyWithoutUploaderInput
    project_updates?: ProjectUpdateUncheckedCreateNestedManyWithoutAuthorInput
    support_requests?: SupportRequestUncheckedCreateNestedManyWithoutClientInput
    support_messages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
    meeting_requests?: MeetingRequestUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    inventory_logs?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    purchase_requests?: PurchaseRequestUncheckedCreateNestedManyWithoutRequesterInput
    grns?: GRNUncheckedCreateNestedManyWithoutReceiverInput
  }

  export type UserCreateOrConnectWithoutPurchase_ordersInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutPurchase_ordersInput, UserUncheckedCreateWithoutPurchase_ordersInput>
  }

  export type GRNCreateWithoutPurchase_orderInput = {
    id?: string
    grn_number: string
    received_date?: Date | string
    notes?: string | null
    created_at?: Date | string
    receiver: UserCreateNestedOneWithoutGrnsInput
  }

  export type GRNUncheckedCreateWithoutPurchase_orderInput = {
    id?: string
    grn_number: string
    received_date?: Date | string
    received_by: string
    notes?: string | null
    created_at?: Date | string
  }

  export type GRNCreateOrConnectWithoutPurchase_orderInput = {
    where: GRNWhereUniqueInput
    create: XOR<GRNCreateWithoutPurchase_orderInput, GRNUncheckedCreateWithoutPurchase_orderInput>
  }

  export type GRNCreateManyPurchase_orderInputEnvelope = {
    data: GRNCreateManyPurchase_orderInput | GRNCreateManyPurchase_orderInput[]
    skipDuplicates?: boolean
  }

  export type VendorBillCreateWithoutPurchase_orderInput = {
    id?: string
    bill_number: string
    amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    due_date: Date | string
    status?: $Enums.InvoiceStatus
    created_at?: Date | string
    updated_at?: Date | string
    vendor: VendorCreateNestedOneWithoutVendor_billsInput
    vendor_payments?: VendorPaymentCreateNestedManyWithoutVendor_billInput
  }

  export type VendorBillUncheckedCreateWithoutPurchase_orderInput = {
    id?: string
    bill_number: string
    vendor_id: string
    amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    due_date: Date | string
    status?: $Enums.InvoiceStatus
    created_at?: Date | string
    updated_at?: Date | string
    vendor_payments?: VendorPaymentUncheckedCreateNestedManyWithoutVendor_billInput
  }

  export type VendorBillCreateOrConnectWithoutPurchase_orderInput = {
    where: VendorBillWhereUniqueInput
    create: XOR<VendorBillCreateWithoutPurchase_orderInput, VendorBillUncheckedCreateWithoutPurchase_orderInput>
  }

  export type VendorBillCreateManyPurchase_orderInputEnvelope = {
    data: VendorBillCreateManyPurchase_orderInput | VendorBillCreateManyPurchase_orderInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseRequestUpsertWithoutPurchase_ordersInput = {
    update: XOR<PurchaseRequestUpdateWithoutPurchase_ordersInput, PurchaseRequestUncheckedUpdateWithoutPurchase_ordersInput>
    create: XOR<PurchaseRequestCreateWithoutPurchase_ordersInput, PurchaseRequestUncheckedCreateWithoutPurchase_ordersInput>
    where?: PurchaseRequestWhereInput
  }

  export type PurchaseRequestUpdateToOneWithWhereWithoutPurchase_ordersInput = {
    where?: PurchaseRequestWhereInput
    data: XOR<PurchaseRequestUpdateWithoutPurchase_ordersInput, PurchaseRequestUncheckedUpdateWithoutPurchase_ordersInput>
  }

  export type PurchaseRequestUpdateWithoutPurchase_ordersInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_name?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priority?: EnumPriorityLevelFieldUpdateOperationsInput | $Enums.PriorityLevel
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    needed_by?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutPurchase_requestsNestedInput
    requester?: UserUpdateOneRequiredWithoutPurchase_requestsNestedInput
  }

  export type PurchaseRequestUncheckedUpdateWithoutPurchase_ordersInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: NullableStringFieldUpdateOperationsInput | string | null
    item_name?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priority?: EnumPriorityLevelFieldUpdateOperationsInput | $Enums.PriorityLevel
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    requested_by?: StringFieldUpdateOperationsInput | string
    needed_by?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorUpsertWithoutPurchase_ordersInput = {
    update: XOR<VendorUpdateWithoutPurchase_ordersInput, VendorUncheckedUpdateWithoutPurchase_ordersInput>
    create: XOR<VendorCreateWithoutPurchase_ordersInput, VendorUncheckedCreateWithoutPurchase_ordersInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutPurchase_ordersInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutPurchase_ordersInput, VendorUncheckedUpdateWithoutPurchase_ordersInput>
  }

  export type VendorUpdateWithoutPurchase_ordersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vat_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor_bills?: VendorBillUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutPurchase_ordersInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vat_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor_bills?: VendorBillUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type UserUpsertWithoutPurchase_ordersInput = {
    update: XOR<UserUpdateWithoutPurchase_ordersInput, UserUncheckedUpdateWithoutPurchase_ordersInput>
    create: XOR<UserCreateWithoutPurchase_ordersInput, UserUncheckedCreateWithoutPurchase_ordersInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutPurchase_ordersInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutPurchase_ordersInput, UserUncheckedUpdateWithoutPurchase_ordersInput>
  }

  export type UserUpdateWithoutPurchase_ordersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutClientNestedInput
    project_files?: ProjectFileUpdateManyWithoutUploaderNestedInput
    project_updates?: ProjectUpdateUpdateManyWithoutAuthorNestedInput
    support_requests?: SupportRequestUpdateManyWithoutClientNestedInput
    support_messages?: SupportMessageUpdateManyWithoutSenderNestedInput
    meeting_requests?: MeetingRequestUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    inventory_logs?: InventoryTransactionUpdateManyWithoutUserNestedInput
    purchase_requests?: PurchaseRequestUpdateManyWithoutRequesterNestedInput
    grns?: GRNUpdateManyWithoutReceiverNestedInput
  }

  export type UserUncheckedUpdateWithoutPurchase_ordersInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    project_files?: ProjectFileUncheckedUpdateManyWithoutUploaderNestedInput
    project_updates?: ProjectUpdateUncheckedUpdateManyWithoutAuthorNestedInput
    support_requests?: SupportRequestUncheckedUpdateManyWithoutClientNestedInput
    support_messages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
    meeting_requests?: MeetingRequestUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    inventory_logs?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    purchase_requests?: PurchaseRequestUncheckedUpdateManyWithoutRequesterNestedInput
    grns?: GRNUncheckedUpdateManyWithoutReceiverNestedInput
  }

  export type GRNUpsertWithWhereUniqueWithoutPurchase_orderInput = {
    where: GRNWhereUniqueInput
    update: XOR<GRNUpdateWithoutPurchase_orderInput, GRNUncheckedUpdateWithoutPurchase_orderInput>
    create: XOR<GRNCreateWithoutPurchase_orderInput, GRNUncheckedCreateWithoutPurchase_orderInput>
  }

  export type GRNUpdateWithWhereUniqueWithoutPurchase_orderInput = {
    where: GRNWhereUniqueInput
    data: XOR<GRNUpdateWithoutPurchase_orderInput, GRNUncheckedUpdateWithoutPurchase_orderInput>
  }

  export type GRNUpdateManyWithWhereWithoutPurchase_orderInput = {
    where: GRNScalarWhereInput
    data: XOR<GRNUpdateManyMutationInput, GRNUncheckedUpdateManyWithoutPurchase_orderInput>
  }

  export type VendorBillUpsertWithWhereUniqueWithoutPurchase_orderInput = {
    where: VendorBillWhereUniqueInput
    update: XOR<VendorBillUpdateWithoutPurchase_orderInput, VendorBillUncheckedUpdateWithoutPurchase_orderInput>
    create: XOR<VendorBillCreateWithoutPurchase_orderInput, VendorBillUncheckedCreateWithoutPurchase_orderInput>
  }

  export type VendorBillUpdateWithWhereUniqueWithoutPurchase_orderInput = {
    where: VendorBillWhereUniqueInput
    data: XOR<VendorBillUpdateWithoutPurchase_orderInput, VendorBillUncheckedUpdateWithoutPurchase_orderInput>
  }

  export type VendorBillUpdateManyWithWhereWithoutPurchase_orderInput = {
    where: VendorBillScalarWhereInput
    data: XOR<VendorBillUpdateManyMutationInput, VendorBillUncheckedUpdateManyWithoutPurchase_orderInput>
  }

  export type PurchaseOrderCreateWithoutGrnsInput = {
    id?: string
    po_number: string
    total_amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.PurchaseStatus
    created_at?: Date | string
    updated_at?: Date | string
    purchase_request?: PurchaseRequestCreateNestedOneWithoutPurchase_ordersInput
    vendor: VendorCreateNestedOneWithoutPurchase_ordersInput
    creator: UserCreateNestedOneWithoutPurchase_ordersInput
    vendor_bills?: VendorBillCreateNestedManyWithoutPurchase_orderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutGrnsInput = {
    id?: string
    po_number: string
    purchase_request_id?: string | null
    vendor_id: string
    total_amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.PurchaseStatus
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    vendor_bills?: VendorBillUncheckedCreateNestedManyWithoutPurchase_orderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutGrnsInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutGrnsInput, PurchaseOrderUncheckedCreateWithoutGrnsInput>
  }

  export type UserCreateWithoutGrnsInput = {
    id?: string
    email: string
    password?: string | null
    full_name: string
    role?: $Enums.UserRole
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    projects?: ProjectCreateNestedManyWithoutClientInput
    project_files?: ProjectFileCreateNestedManyWithoutUploaderInput
    project_updates?: ProjectUpdateCreateNestedManyWithoutAuthorInput
    support_requests?: SupportRequestCreateNestedManyWithoutClientInput
    support_messages?: SupportMessageCreateNestedManyWithoutSenderInput
    meeting_requests?: MeetingRequestCreateNestedManyWithoutClientInput
    invoices?: InvoiceCreateNestedManyWithoutClientInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    transactions?: TransactionCreateNestedManyWithoutCreatorInput
    inventory_logs?: InventoryTransactionCreateNestedManyWithoutUserInput
    purchase_requests?: PurchaseRequestCreateNestedManyWithoutRequesterInput
    purchase_orders?: PurchaseOrderCreateNestedManyWithoutCreatorInput
  }

  export type UserUncheckedCreateWithoutGrnsInput = {
    id?: string
    email: string
    password?: string | null
    full_name: string
    role?: $Enums.UserRole
    avatar_url?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    projects?: ProjectUncheckedCreateNestedManyWithoutClientInput
    project_files?: ProjectFileUncheckedCreateNestedManyWithoutUploaderInput
    project_updates?: ProjectUpdateUncheckedCreateNestedManyWithoutAuthorInput
    support_requests?: SupportRequestUncheckedCreateNestedManyWithoutClientInput
    support_messages?: SupportMessageUncheckedCreateNestedManyWithoutSenderInput
    meeting_requests?: MeetingRequestUncheckedCreateNestedManyWithoutClientInput
    invoices?: InvoiceUncheckedCreateNestedManyWithoutClientInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    transactions?: TransactionUncheckedCreateNestedManyWithoutCreatorInput
    inventory_logs?: InventoryTransactionUncheckedCreateNestedManyWithoutUserInput
    purchase_requests?: PurchaseRequestUncheckedCreateNestedManyWithoutRequesterInput
    purchase_orders?: PurchaseOrderUncheckedCreateNestedManyWithoutCreatorInput
  }

  export type UserCreateOrConnectWithoutGrnsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutGrnsInput, UserUncheckedCreateWithoutGrnsInput>
  }

  export type PurchaseOrderUpsertWithoutGrnsInput = {
    update: XOR<PurchaseOrderUpdateWithoutGrnsInput, PurchaseOrderUncheckedUpdateWithoutGrnsInput>
    create: XOR<PurchaseOrderCreateWithoutGrnsInput, PurchaseOrderUncheckedCreateWithoutGrnsInput>
    where?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderUpdateToOneWithWhereWithoutGrnsInput = {
    where?: PurchaseOrderWhereInput
    data: XOR<PurchaseOrderUpdateWithoutGrnsInput, PurchaseOrderUncheckedUpdateWithoutGrnsInput>
  }

  export type PurchaseOrderUpdateWithoutGrnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase_request?: PurchaseRequestUpdateOneWithoutPurchase_ordersNestedInput
    vendor?: VendorUpdateOneRequiredWithoutPurchase_ordersNestedInput
    creator?: UserUpdateOneRequiredWithoutPurchase_ordersNestedInput
    vendor_bills?: VendorBillUpdateManyWithoutPurchase_orderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutGrnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    purchase_request_id?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_id?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor_bills?: VendorBillUncheckedUpdateManyWithoutPurchase_orderNestedInput
  }

  export type UserUpsertWithoutGrnsInput = {
    update: XOR<UserUpdateWithoutGrnsInput, UserUncheckedUpdateWithoutGrnsInput>
    create: XOR<UserCreateWithoutGrnsInput, UserUncheckedCreateWithoutGrnsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutGrnsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutGrnsInput, UserUncheckedUpdateWithoutGrnsInput>
  }

  export type UserUpdateWithoutGrnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUpdateManyWithoutClientNestedInput
    project_files?: ProjectFileUpdateManyWithoutUploaderNestedInput
    project_updates?: ProjectUpdateUpdateManyWithoutAuthorNestedInput
    support_requests?: SupportRequestUpdateManyWithoutClientNestedInput
    support_messages?: SupportMessageUpdateManyWithoutSenderNestedInput
    meeting_requests?: MeetingRequestUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUpdateManyWithoutClientNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    transactions?: TransactionUpdateManyWithoutCreatorNestedInput
    inventory_logs?: InventoryTransactionUpdateManyWithoutUserNestedInput
    purchase_requests?: PurchaseRequestUpdateManyWithoutRequesterNestedInput
    purchase_orders?: PurchaseOrderUpdateManyWithoutCreatorNestedInput
  }

  export type UserUncheckedUpdateWithoutGrnsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: NullableStringFieldUpdateOperationsInput | string | null
    full_name?: StringFieldUpdateOperationsInput | string
    role?: EnumUserRoleFieldUpdateOperationsInput | $Enums.UserRole
    avatar_url?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    projects?: ProjectUncheckedUpdateManyWithoutClientNestedInput
    project_files?: ProjectFileUncheckedUpdateManyWithoutUploaderNestedInput
    project_updates?: ProjectUpdateUncheckedUpdateManyWithoutAuthorNestedInput
    support_requests?: SupportRequestUncheckedUpdateManyWithoutClientNestedInput
    support_messages?: SupportMessageUncheckedUpdateManyWithoutSenderNestedInput
    meeting_requests?: MeetingRequestUncheckedUpdateManyWithoutClientNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutClientNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    transactions?: TransactionUncheckedUpdateManyWithoutCreatorNestedInput
    inventory_logs?: InventoryTransactionUncheckedUpdateManyWithoutUserNestedInput
    purchase_requests?: PurchaseRequestUncheckedUpdateManyWithoutRequesterNestedInput
    purchase_orders?: PurchaseOrderUncheckedUpdateManyWithoutCreatorNestedInput
  }

  export type PurchaseOrderCreateWithoutVendor_billsInput = {
    id?: string
    po_number: string
    total_amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.PurchaseStatus
    created_at?: Date | string
    updated_at?: Date | string
    purchase_request?: PurchaseRequestCreateNestedOneWithoutPurchase_ordersInput
    vendor: VendorCreateNestedOneWithoutPurchase_ordersInput
    creator: UserCreateNestedOneWithoutPurchase_ordersInput
    grns?: GRNCreateNestedManyWithoutPurchase_orderInput
  }

  export type PurchaseOrderUncheckedCreateWithoutVendor_billsInput = {
    id?: string
    po_number: string
    purchase_request_id?: string | null
    vendor_id: string
    total_amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.PurchaseStatus
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
    grns?: GRNUncheckedCreateNestedManyWithoutPurchase_orderInput
  }

  export type PurchaseOrderCreateOrConnectWithoutVendor_billsInput = {
    where: PurchaseOrderWhereUniqueInput
    create: XOR<PurchaseOrderCreateWithoutVendor_billsInput, PurchaseOrderUncheckedCreateWithoutVendor_billsInput>
  }

  export type VendorCreateWithoutVendor_billsInput = {
    id?: string
    name: string
    contact_person?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    vat_no?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    purchase_orders?: PurchaseOrderCreateNestedManyWithoutVendorInput
  }

  export type VendorUncheckedCreateWithoutVendor_billsInput = {
    id?: string
    name: string
    contact_person?: string | null
    email?: string | null
    phone?: string | null
    address?: string | null
    vat_no?: string | null
    created_at?: Date | string
    updated_at?: Date | string
    purchase_orders?: PurchaseOrderUncheckedCreateNestedManyWithoutVendorInput
  }

  export type VendorCreateOrConnectWithoutVendor_billsInput = {
    where: VendorWhereUniqueInput
    create: XOR<VendorCreateWithoutVendor_billsInput, VendorUncheckedCreateWithoutVendor_billsInput>
  }

  export type VendorPaymentCreateWithoutVendor_billInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string
    payment_method: string
    reference_no?: string | null
    notes?: string | null
    created_at?: Date | string
  }

  export type VendorPaymentUncheckedCreateWithoutVendor_billInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string
    payment_method: string
    reference_no?: string | null
    notes?: string | null
    created_at?: Date | string
  }

  export type VendorPaymentCreateOrConnectWithoutVendor_billInput = {
    where: VendorPaymentWhereUniqueInput
    create: XOR<VendorPaymentCreateWithoutVendor_billInput, VendorPaymentUncheckedCreateWithoutVendor_billInput>
  }

  export type VendorPaymentCreateManyVendor_billInputEnvelope = {
    data: VendorPaymentCreateManyVendor_billInput | VendorPaymentCreateManyVendor_billInput[]
    skipDuplicates?: boolean
  }

  export type PurchaseOrderUpsertWithoutVendor_billsInput = {
    update: XOR<PurchaseOrderUpdateWithoutVendor_billsInput, PurchaseOrderUncheckedUpdateWithoutVendor_billsInput>
    create: XOR<PurchaseOrderCreateWithoutVendor_billsInput, PurchaseOrderUncheckedCreateWithoutVendor_billsInput>
    where?: PurchaseOrderWhereInput
  }

  export type PurchaseOrderUpdateToOneWithWhereWithoutVendor_billsInput = {
    where?: PurchaseOrderWhereInput
    data: XOR<PurchaseOrderUpdateWithoutVendor_billsInput, PurchaseOrderUncheckedUpdateWithoutVendor_billsInput>
  }

  export type PurchaseOrderUpdateWithoutVendor_billsInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase_request?: PurchaseRequestUpdateOneWithoutPurchase_ordersNestedInput
    vendor?: VendorUpdateOneRequiredWithoutPurchase_ordersNestedInput
    creator?: UserUpdateOneRequiredWithoutPurchase_ordersNestedInput
    grns?: GRNUpdateManyWithoutPurchase_orderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutVendor_billsInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    purchase_request_id?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_id?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    grns?: GRNUncheckedUpdateManyWithoutPurchase_orderNestedInput
  }

  export type VendorUpsertWithoutVendor_billsInput = {
    update: XOR<VendorUpdateWithoutVendor_billsInput, VendorUncheckedUpdateWithoutVendor_billsInput>
    create: XOR<VendorCreateWithoutVendor_billsInput, VendorUncheckedCreateWithoutVendor_billsInput>
    where?: VendorWhereInput
  }

  export type VendorUpdateToOneWithWhereWithoutVendor_billsInput = {
    where?: VendorWhereInput
    data: XOR<VendorUpdateWithoutVendor_billsInput, VendorUncheckedUpdateWithoutVendor_billsInput>
  }

  export type VendorUpdateWithoutVendor_billsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vat_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase_orders?: PurchaseOrderUpdateManyWithoutVendorNestedInput
  }

  export type VendorUncheckedUpdateWithoutVendor_billsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    contact_person?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    vat_no?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase_orders?: PurchaseOrderUncheckedUpdateManyWithoutVendorNestedInput
  }

  export type VendorPaymentUpsertWithWhereUniqueWithoutVendor_billInput = {
    where: VendorPaymentWhereUniqueInput
    update: XOR<VendorPaymentUpdateWithoutVendor_billInput, VendorPaymentUncheckedUpdateWithoutVendor_billInput>
    create: XOR<VendorPaymentCreateWithoutVendor_billInput, VendorPaymentUncheckedCreateWithoutVendor_billInput>
  }

  export type VendorPaymentUpdateWithWhereUniqueWithoutVendor_billInput = {
    where: VendorPaymentWhereUniqueInput
    data: XOR<VendorPaymentUpdateWithoutVendor_billInput, VendorPaymentUncheckedUpdateWithoutVendor_billInput>
  }

  export type VendorPaymentUpdateManyWithWhereWithoutVendor_billInput = {
    where: VendorPaymentScalarWhereInput
    data: XOR<VendorPaymentUpdateManyMutationInput, VendorPaymentUncheckedUpdateManyWithoutVendor_billInput>
  }

  export type VendorPaymentScalarWhereInput = {
    AND?: VendorPaymentScalarWhereInput | VendorPaymentScalarWhereInput[]
    OR?: VendorPaymentScalarWhereInput[]
    NOT?: VendorPaymentScalarWhereInput | VendorPaymentScalarWhereInput[]
    id?: StringFilter<"VendorPayment"> | string
    vendor_bill_id?: StringFilter<"VendorPayment"> | string
    amount?: DecimalFilter<"VendorPayment"> | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFilter<"VendorPayment"> | Date | string
    payment_method?: StringFilter<"VendorPayment"> | string
    reference_no?: StringNullableFilter<"VendorPayment"> | string | null
    notes?: StringNullableFilter<"VendorPayment"> | string | null
    created_at?: DateTimeFilter<"VendorPayment"> | Date | string
  }

  export type VendorBillCreateWithoutVendor_paymentsInput = {
    id?: string
    bill_number: string
    amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    due_date: Date | string
    status?: $Enums.InvoiceStatus
    created_at?: Date | string
    updated_at?: Date | string
    purchase_order: PurchaseOrderCreateNestedOneWithoutVendor_billsInput
    vendor: VendorCreateNestedOneWithoutVendor_billsInput
  }

  export type VendorBillUncheckedCreateWithoutVendor_paymentsInput = {
    id?: string
    bill_number: string
    purchase_order_id: string
    vendor_id: string
    amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    due_date: Date | string
    status?: $Enums.InvoiceStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorBillCreateOrConnectWithoutVendor_paymentsInput = {
    where: VendorBillWhereUniqueInput
    create: XOR<VendorBillCreateWithoutVendor_paymentsInput, VendorBillUncheckedCreateWithoutVendor_paymentsInput>
  }

  export type VendorBillUpsertWithoutVendor_paymentsInput = {
    update: XOR<VendorBillUpdateWithoutVendor_paymentsInput, VendorBillUncheckedUpdateWithoutVendor_paymentsInput>
    create: XOR<VendorBillCreateWithoutVendor_paymentsInput, VendorBillUncheckedCreateWithoutVendor_paymentsInput>
    where?: VendorBillWhereInput
  }

  export type VendorBillUpdateToOneWithWhereWithoutVendor_paymentsInput = {
    where?: VendorBillWhereInput
    data: XOR<VendorBillUpdateWithoutVendor_paymentsInput, VendorBillUncheckedUpdateWithoutVendor_paymentsInput>
  }

  export type VendorBillUpdateWithoutVendor_paymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bill_number?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase_order?: PurchaseOrderUpdateOneRequiredWithoutVendor_billsNestedInput
    vendor?: VendorUpdateOneRequiredWithoutVendor_billsNestedInput
  }

  export type VendorBillUncheckedUpdateWithoutVendor_paymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    bill_number?: StringFieldUpdateOperationsInput | string
    purchase_order_id?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankTransactionCreateWithoutBank_accountInput = {
    id?: string
    date: Date | string
    description: string
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    status?: string
    type: string
    system_transaction_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BankTransactionUncheckedCreateWithoutBank_accountInput = {
    id?: string
    date: Date | string
    description: string
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    status?: string
    type: string
    system_transaction_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BankTransactionCreateOrConnectWithoutBank_accountInput = {
    where: BankTransactionWhereUniqueInput
    create: XOR<BankTransactionCreateWithoutBank_accountInput, BankTransactionUncheckedCreateWithoutBank_accountInput>
  }

  export type BankTransactionCreateManyBank_accountInputEnvelope = {
    data: BankTransactionCreateManyBank_accountInput | BankTransactionCreateManyBank_accountInput[]
    skipDuplicates?: boolean
  }

  export type BankTransactionUpsertWithWhereUniqueWithoutBank_accountInput = {
    where: BankTransactionWhereUniqueInput
    update: XOR<BankTransactionUpdateWithoutBank_accountInput, BankTransactionUncheckedUpdateWithoutBank_accountInput>
    create: XOR<BankTransactionCreateWithoutBank_accountInput, BankTransactionUncheckedCreateWithoutBank_accountInput>
  }

  export type BankTransactionUpdateWithWhereUniqueWithoutBank_accountInput = {
    where: BankTransactionWhereUniqueInput
    data: XOR<BankTransactionUpdateWithoutBank_accountInput, BankTransactionUncheckedUpdateWithoutBank_accountInput>
  }

  export type BankTransactionUpdateManyWithWhereWithoutBank_accountInput = {
    where: BankTransactionScalarWhereInput
    data: XOR<BankTransactionUpdateManyMutationInput, BankTransactionUncheckedUpdateManyWithoutBank_accountInput>
  }

  export type BankTransactionScalarWhereInput = {
    AND?: BankTransactionScalarWhereInput | BankTransactionScalarWhereInput[]
    OR?: BankTransactionScalarWhereInput[]
    NOT?: BankTransactionScalarWhereInput | BankTransactionScalarWhereInput[]
    id?: StringFilter<"BankTransaction"> | string
    bank_account_id?: StringFilter<"BankTransaction"> | string
    date?: DateTimeFilter<"BankTransaction"> | Date | string
    description?: StringFilter<"BankTransaction"> | string
    amount?: DecimalFilter<"BankTransaction"> | Decimal | DecimalJsLike | number | string
    reference?: StringNullableFilter<"BankTransaction"> | string | null
    status?: StringFilter<"BankTransaction"> | string
    type?: StringFilter<"BankTransaction"> | string
    system_transaction_id?: StringNullableFilter<"BankTransaction"> | string | null
    created_at?: DateTimeFilter<"BankTransaction"> | Date | string
    updated_at?: DateTimeFilter<"BankTransaction"> | Date | string
  }

  export type BankAccountCreateWithoutTransactionsInput = {
    id?: string
    name: string
    account_number?: string | null
    bank_name?: string | null
    currency?: string
    current_balance?: Decimal | DecimalJsLike | number | string
    type?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BankAccountUncheckedCreateWithoutTransactionsInput = {
    id?: string
    name: string
    account_number?: string | null
    bank_name?: string | null
    currency?: string
    current_balance?: Decimal | DecimalJsLike | number | string
    type?: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BankAccountCreateOrConnectWithoutTransactionsInput = {
    where: BankAccountWhereUniqueInput
    create: XOR<BankAccountCreateWithoutTransactionsInput, BankAccountUncheckedCreateWithoutTransactionsInput>
  }

  export type BankAccountUpsertWithoutTransactionsInput = {
    update: XOR<BankAccountUpdateWithoutTransactionsInput, BankAccountUncheckedUpdateWithoutTransactionsInput>
    create: XOR<BankAccountCreateWithoutTransactionsInput, BankAccountUncheckedCreateWithoutTransactionsInput>
    where?: BankAccountWhereInput
  }

  export type BankAccountUpdateToOneWithWhereWithoutTransactionsInput = {
    where?: BankAccountWhereInput
    data: XOR<BankAccountUpdateWithoutTransactionsInput, BankAccountUncheckedUpdateWithoutTransactionsInput>
  }

  export type BankAccountUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    current_balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankAccountUncheckedUpdateWithoutTransactionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    account_number?: NullableStringFieldUpdateOperationsInput | string | null
    bank_name?: NullableStringFieldUpdateOperationsInput | string | null
    currency?: StringFieldUpdateOperationsInput | string
    current_balance?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    type?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectCreateManyClientInput = {
    id?: string
    title: string
    description: string
    status?: $Enums.ProjectStatus
    github_link?: string | null
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    actual_cost?: Decimal | DecimalJsLike | number | string | null
    deadline?: Date | string | null
    test_asset_url?: string | null
    deployment_url?: string | null
    live_preview_type?: string | null
    live_preview_url?: string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectCreatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: boolean
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type ProjectFileCreateManyUploaderInput = {
    id?: string
    project_id: string
    file_name: string
    file_url: string
    file_type?: $Enums.FileType
    file_size: bigint | number
    created_at?: Date | string
  }

  export type ProjectUpdateCreateManyAuthorInput = {
    id?: string
    project_id: string
    update_text: string
    created_at?: Date | string
  }

  export type SupportRequestCreateManyClientInput = {
    id?: string
    project_id?: string | null
    subject: string
    description: string
    status?: $Enums.SupportStatus
    priority?: $Enums.PriorityLevel
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type SupportMessageCreateManySenderInput = {
    id?: string
    support_request_id: string
    message: string
    created_at?: Date | string
  }

  export type MeetingRequestCreateManyClientInput = {
    id?: string
    project_id?: string | null
    requested_date: Date | string
    duration_minutes?: number
    purpose: string
    status?: $Enums.MeetingStatus
    meeting_link?: string | null
    admin_notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InvoiceCreateManyClientInput = {
    id?: string
    project_id: string
    invoice_number: string
    amount: Decimal | DecimalJsLike | number | string
    due_date: Date | string
    status?: $Enums.InvoiceStatus
    payment_qr_url?: string | null
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    paid_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    title: string
    message: string
    type?: $Enums.NotificationType
    link?: string | null
    read?: boolean
    created_at?: Date | string
  }

  export type TransactionCreateManyCreatorInput = {
    id?: string
    type: $Enums.TransactionType
    category: string
    amount: Decimal | DecimalJsLike | number | string
    currency?: string
    exchange_rate?: Decimal | DecimalJsLike | number | string | null
    date: Date | string
    description?: string | null
    notes?: string | null
    payment_method?: string | null
    reference_number?: string | null
    attachment_url?: string | null
    tax_rate_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InventoryTransactionCreateManyUserInput = {
    id?: string
    item_id: string
    project_id?: string | null
    type: $Enums.InventoryTransactionType
    quantity: number
    date?: Date | string
    reference_no?: string | null
    notes?: string | null
    created_at?: Date | string
  }

  export type PurchaseRequestCreateManyRequesterInput = {
    id?: string
    project_id?: string | null
    item_name: string
    quantity: number
    unit: string
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    priority?: $Enums.PriorityLevel
    status?: $Enums.PurchaseStatus
    needed_by?: Date | string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PurchaseOrderCreateManyCreatorInput = {
    id?: string
    po_number: string
    purchase_request_id?: string | null
    vendor_id: string
    total_amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.PurchaseStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type GRNCreateManyReceiverInput = {
    id?: string
    grn_number: string
    purchase_order_id: string
    received_date?: Date | string
    notes?: string | null
    created_at?: Date | string
  }

  export type ProjectUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    github_link?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actual_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_asset_url?: NullableStringFieldUpdateOperationsInput | string | null
    deployment_url?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_type?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_url?: NullableStringFieldUpdateOperationsInput | string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectUpdatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: ProjectFileUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUpdateManyWithoutProjectNestedInput
    support_requests?: SupportRequestUpdateManyWithoutProjectNestedInput
    meeting_requests?: MeetingRequestUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUpdateManyWithoutProjectNestedInput
    inventory_logs?: InventoryTransactionUpdateManyWithoutProjectNestedInput
    purchase_requests?: PurchaseRequestUpdateManyWithoutProjectNestedInput
    attendance?: AttendanceUpdateManyWithoutProjectNestedInput
    labour_allocations?: LabourAllocationUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    github_link?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actual_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_asset_url?: NullableStringFieldUpdateOperationsInput | string | null
    deployment_url?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_type?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_url?: NullableStringFieldUpdateOperationsInput | string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectUpdatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    files?: ProjectFileUncheckedUpdateManyWithoutProjectNestedInput
    updates?: ProjectUpdateUncheckedUpdateManyWithoutProjectNestedInput
    support_requests?: SupportRequestUncheckedUpdateManyWithoutProjectNestedInput
    meeting_requests?: MeetingRequestUncheckedUpdateManyWithoutProjectNestedInput
    invoices?: InvoiceUncheckedUpdateManyWithoutProjectNestedInput
    inventory_logs?: InventoryTransactionUncheckedUpdateManyWithoutProjectNestedInput
    purchase_requests?: PurchaseRequestUncheckedUpdateManyWithoutProjectNestedInput
    attendance?: AttendanceUncheckedUpdateManyWithoutProjectNestedInput
    labour_allocations?: LabourAllocationUncheckedUpdateManyWithoutProjectNestedInput
  }

  export type ProjectUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumProjectStatusFieldUpdateOperationsInput | $Enums.ProjectStatus
    github_link?: NullableStringFieldUpdateOperationsInput | string | null
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    actual_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    deadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    test_asset_url?: NullableStringFieldUpdateOperationsInput | string | null
    deployment_url?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_type?: NullableStringFieldUpdateOperationsInput | string | null
    live_preview_url?: NullableStringFieldUpdateOperationsInput | string | null
    technical_config?: NullableJsonNullValueInput | InputJsonValue
    tickets?: NullableJsonNullValueInput | InputJsonValue
    notes?: ProjectUpdatenotesInput | string[]
    labour_data?: NullableJsonNullValueInput | InputJsonValue
    inventory_data?: NullableJsonNullValueInput | InputJsonValue
    resources_data?: NullableJsonNullValueInput | InputJsonValue
    design_data?: NullableJsonNullValueInput | InputJsonValue
    expenses_data?: NullableJsonNullValueInput | InputJsonValue
    timeline_data?: NullableJsonNullValueInput | InputJsonValue
    is_featured?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectFileUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    file_url?: StringFieldUpdateOperationsInput | string
    file_type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    file_size?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutFilesNestedInput
  }

  export type ProjectFileUncheckedUpdateWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    file_url?: StringFieldUpdateOperationsInput | string
    file_type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    file_size?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectFileUncheckedUpdateManyWithoutUploaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    file_url?: StringFieldUpdateOperationsInput | string
    file_type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    file_size?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    update_text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutUpdatesNestedInput
  }

  export type ProjectUpdateUncheckedUpdateWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    update_text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateUncheckedUpdateManyWithoutAuthorInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    update_text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportRequestUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSupportStatusFieldUpdateOperationsInput | $Enums.SupportStatus
    priority?: EnumPriorityLevelFieldUpdateOperationsInput | $Enums.PriorityLevel
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutSupport_requestsNestedInput
    messages?: SupportMessageUpdateManyWithoutRequestNestedInput
  }

  export type SupportRequestUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSupportStatusFieldUpdateOperationsInput | $Enums.SupportStatus
    priority?: EnumPriorityLevelFieldUpdateOperationsInput | $Enums.PriorityLevel
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: SupportMessageUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type SupportRequestUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: NullableStringFieldUpdateOperationsInput | string | null
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSupportStatusFieldUpdateOperationsInput | $Enums.SupportStatus
    priority?: EnumPriorityLevelFieldUpdateOperationsInput | $Enums.PriorityLevel
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportMessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    request?: SupportRequestUpdateOneRequiredWithoutMessagesNestedInput
  }

  export type SupportMessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    support_request_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportMessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    support_request_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingRequestUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    requested_date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_minutes?: IntFieldUpdateOperationsInput | number
    purpose?: StringFieldUpdateOperationsInput | string
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus
    meeting_link?: NullableStringFieldUpdateOperationsInput | string | null
    admin_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutMeeting_requestsNestedInput
  }

  export type MeetingRequestUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: NullableStringFieldUpdateOperationsInput | string | null
    requested_date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_minutes?: IntFieldUpdateOperationsInput | number
    purpose?: StringFieldUpdateOperationsInput | string
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus
    meeting_link?: NullableStringFieldUpdateOperationsInput | string | null
    admin_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingRequestUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: NullableStringFieldUpdateOperationsInput | string | null
    requested_date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_minutes?: IntFieldUpdateOperationsInput | number
    purpose?: StringFieldUpdateOperationsInput | string
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus
    meeting_link?: NullableStringFieldUpdateOperationsInput | string | null
    admin_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    payment_qr_url?: NullableStringFieldUpdateOperationsInput | string | null
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutInvoicesNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    payment_qr_url?: NullableStringFieldUpdateOperationsInput | string | null
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutClientInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    payment_qr_url?: NullableStringFieldUpdateOperationsInput | string | null
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    link?: NullableStringFieldUpdateOperationsInput | string | null
    read?: BoolFieldUpdateOperationsInput | boolean
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    attachment_url?: NullableStringFieldUpdateOperationsInput | string | null
    tax_rate_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    attachment_url?: NullableStringFieldUpdateOperationsInput | string | null
    tax_rate_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TransactionUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumTransactionTypeFieldUpdateOperationsInput | $Enums.TransactionType
    category?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currency?: StringFieldUpdateOperationsInput | string
    exchange_rate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    payment_method?: NullableStringFieldUpdateOperationsInput | string | null
    reference_number?: NullableStringFieldUpdateOperationsInput | string | null
    attachment_url?: NullableStringFieldUpdateOperationsInput | string | null
    tax_rate_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryTransactionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInventoryTransactionTypeFieldUpdateOperationsInput | $Enums.InventoryTransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: InventoryItemUpdateOneRequiredWithoutTransactionsNestedInput
    project?: ProjectUpdateOneWithoutInventory_logsNestedInput
  }

  export type InventoryTransactionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    project_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInventoryTransactionTypeFieldUpdateOperationsInput | $Enums.InventoryTransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryTransactionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    project_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInventoryTransactionTypeFieldUpdateOperationsInput | $Enums.InventoryTransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseRequestUpdateWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_name?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priority?: EnumPriorityLevelFieldUpdateOperationsInput | $Enums.PriorityLevel
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    needed_by?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutPurchase_requestsNestedInput
    purchase_orders?: PurchaseOrderUpdateManyWithoutPurchase_requestNestedInput
  }

  export type PurchaseRequestUncheckedUpdateWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: NullableStringFieldUpdateOperationsInput | string | null
    item_name?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priority?: EnumPriorityLevelFieldUpdateOperationsInput | $Enums.PriorityLevel
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    needed_by?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase_orders?: PurchaseOrderUncheckedUpdateManyWithoutPurchase_requestNestedInput
  }

  export type PurchaseRequestUncheckedUpdateManyWithoutRequesterInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: NullableStringFieldUpdateOperationsInput | string | null
    item_name?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priority?: EnumPriorityLevelFieldUpdateOperationsInput | $Enums.PriorityLevel
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    needed_by?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase_request?: PurchaseRequestUpdateOneWithoutPurchase_ordersNestedInput
    vendor?: VendorUpdateOneRequiredWithoutPurchase_ordersNestedInput
    grns?: GRNUpdateManyWithoutPurchase_orderNestedInput
    vendor_bills?: VendorBillUpdateManyWithoutPurchase_orderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    purchase_request_id?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_id?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    grns?: GRNUncheckedUpdateManyWithoutPurchase_orderNestedInput
    vendor_bills?: VendorBillUncheckedUpdateManyWithoutPurchase_orderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    purchase_request_id?: NullableStringFieldUpdateOperationsInput | string | null
    vendor_id?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GRNUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    grn_number?: StringFieldUpdateOperationsInput | string
    received_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase_order?: PurchaseOrderUpdateOneRequiredWithoutGrnsNestedInput
  }

  export type GRNUncheckedUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    grn_number?: StringFieldUpdateOperationsInput | string
    purchase_order_id?: StringFieldUpdateOperationsInput | string
    received_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GRNUncheckedUpdateManyWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    grn_number?: StringFieldUpdateOperationsInput | string
    purchase_order_id?: StringFieldUpdateOperationsInput | string
    received_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectFileCreateManyProjectInput = {
    id?: string
    file_name: string
    file_url: string
    file_type?: $Enums.FileType
    file_size: bigint | number
    uploaded_by: string
    created_at?: Date | string
  }

  export type ProjectUpdateCreateManyProjectInput = {
    id?: string
    update_text: string
    created_by: string
    created_at?: Date | string
  }

  export type SupportRequestCreateManyProjectInput = {
    id?: string
    client_id: string
    subject: string
    description: string
    status?: $Enums.SupportStatus
    priority?: $Enums.PriorityLevel
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type MeetingRequestCreateManyProjectInput = {
    id?: string
    client_id: string
    requested_date: Date | string
    duration_minutes?: number
    purpose: string
    status?: $Enums.MeetingStatus
    meeting_link?: string | null
    admin_notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InvoiceCreateManyProjectInput = {
    id?: string
    client_id: string
    invoice_number: string
    amount: Decimal | DecimalJsLike | number | string
    due_date: Date | string
    status?: $Enums.InvoiceStatus
    payment_qr_url?: string | null
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    paid_at?: Date | string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type InventoryTransactionCreateManyProjectInput = {
    id?: string
    item_id: string
    type: $Enums.InventoryTransactionType
    quantity: number
    date?: Date | string
    reference_no?: string | null
    notes?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type PurchaseRequestCreateManyProjectInput = {
    id?: string
    item_name: string
    quantity: number
    unit: string
    estimated_cost?: Decimal | DecimalJsLike | number | string | null
    priority?: $Enums.PriorityLevel
    status?: $Enums.PurchaseStatus
    requested_by: string
    needed_by?: Date | string | null
    notes?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type AttendanceCreateManyProjectInput = {
    id?: string
    employee_id: string
    date: Date | string
    status: string
    overtime_hours?: number
    check_in?: Date | string | null
    check_out?: Date | string | null
    created_at?: Date | string
  }

  export type LabourAllocationCreateManyProjectInput = {
    id?: string
    employee_id: string
    start_date: Date | string
    end_date?: Date | string | null
    status: string
    created_at?: Date | string
  }

  export type ProjectFileUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    file_url?: StringFieldUpdateOperationsInput | string
    file_type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    file_size?: BigIntFieldUpdateOperationsInput | bigint | number
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    uploader?: UserUpdateOneRequiredWithoutProject_filesNestedInput
  }

  export type ProjectFileUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    file_url?: StringFieldUpdateOperationsInput | string
    file_type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    file_size?: BigIntFieldUpdateOperationsInput | bigint | number
    uploaded_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectFileUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    file_name?: StringFieldUpdateOperationsInput | string
    file_url?: StringFieldUpdateOperationsInput | string
    file_type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    file_size?: BigIntFieldUpdateOperationsInput | bigint | number
    uploaded_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    update_text?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    author?: UserUpdateOneRequiredWithoutProject_updatesNestedInput
  }

  export type ProjectUpdateUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    update_text?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProjectUpdateUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    update_text?: StringFieldUpdateOperationsInput | string
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportRequestUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSupportStatusFieldUpdateOperationsInput | $Enums.SupportStatus
    priority?: EnumPriorityLevelFieldUpdateOperationsInput | $Enums.PriorityLevel
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: UserUpdateOneRequiredWithoutSupport_requestsNestedInput
    messages?: SupportMessageUpdateManyWithoutRequestNestedInput
  }

  export type SupportRequestUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSupportStatusFieldUpdateOperationsInput | $Enums.SupportStatus
    priority?: EnumPriorityLevelFieldUpdateOperationsInput | $Enums.PriorityLevel
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: SupportMessageUncheckedUpdateManyWithoutRequestNestedInput
  }

  export type SupportRequestUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    status?: EnumSupportStatusFieldUpdateOperationsInput | $Enums.SupportStatus
    priority?: EnumPriorityLevelFieldUpdateOperationsInput | $Enums.PriorityLevel
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingRequestUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    requested_date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_minutes?: IntFieldUpdateOperationsInput | number
    purpose?: StringFieldUpdateOperationsInput | string
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus
    meeting_link?: NullableStringFieldUpdateOperationsInput | string | null
    admin_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: UserUpdateOneRequiredWithoutMeeting_requestsNestedInput
  }

  export type MeetingRequestUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    requested_date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_minutes?: IntFieldUpdateOperationsInput | number
    purpose?: StringFieldUpdateOperationsInput | string
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus
    meeting_link?: NullableStringFieldUpdateOperationsInput | string | null
    admin_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MeetingRequestUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    requested_date?: DateTimeFieldUpdateOperationsInput | Date | string
    duration_minutes?: IntFieldUpdateOperationsInput | number
    purpose?: StringFieldUpdateOperationsInput | string
    status?: EnumMeetingStatusFieldUpdateOperationsInput | $Enums.MeetingStatus
    meeting_link?: NullableStringFieldUpdateOperationsInput | string | null
    admin_notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InvoiceUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    payment_qr_url?: NullableStringFieldUpdateOperationsInput | string | null
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    client?: UserUpdateOneRequiredWithoutInvoicesNestedInput
    payments?: PaymentUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    payment_qr_url?: NullableStringFieldUpdateOperationsInput | string | null
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    payments?: PaymentUncheckedUpdateManyWithoutInvoiceNestedInput
  }

  export type InvoiceUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    client_id?: StringFieldUpdateOperationsInput | string
    invoice_number?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    payment_qr_url?: NullableStringFieldUpdateOperationsInput | string | null
    bank_details?: NullableJsonNullValueInput | InputJsonValue
    paid_at?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryTransactionUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInventoryTransactionTypeFieldUpdateOperationsInput | $Enums.InventoryTransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    item?: InventoryItemUpdateOneRequiredWithoutTransactionsNestedInput
    user?: UserUpdateOneRequiredWithoutInventory_logsNestedInput
  }

  export type InventoryTransactionUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    type?: EnumInventoryTransactionTypeFieldUpdateOperationsInput | $Enums.InventoryTransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryTransactionUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_id?: StringFieldUpdateOperationsInput | string
    type?: EnumInventoryTransactionTypeFieldUpdateOperationsInput | $Enums.InventoryTransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseRequestUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_name?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priority?: EnumPriorityLevelFieldUpdateOperationsInput | $Enums.PriorityLevel
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    needed_by?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    requester?: UserUpdateOneRequiredWithoutPurchase_requestsNestedInput
    purchase_orders?: PurchaseOrderUpdateManyWithoutPurchase_requestNestedInput
  }

  export type PurchaseRequestUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_name?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priority?: EnumPriorityLevelFieldUpdateOperationsInput | $Enums.PriorityLevel
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    requested_by?: StringFieldUpdateOperationsInput | string
    needed_by?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase_orders?: PurchaseOrderUncheckedUpdateManyWithoutPurchase_requestNestedInput
  }

  export type PurchaseRequestUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    item_name?: StringFieldUpdateOperationsInput | string
    quantity?: FloatFieldUpdateOperationsInput | number
    unit?: StringFieldUpdateOperationsInput | string
    estimated_cost?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    priority?: EnumPriorityLevelFieldUpdateOperationsInput | $Enums.PriorityLevel
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    requested_by?: StringFieldUpdateOperationsInput | string
    needed_by?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    overtime_hours?: FloatFieldUpdateOperationsInput | number
    check_in?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    check_out?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    overtime_hours?: FloatFieldUpdateOperationsInput | number
    check_in?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    check_out?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    overtime_hours?: FloatFieldUpdateOperationsInput | number
    check_in?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    check_out?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabourAllocationUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    employee?: EmployeeUpdateOneRequiredWithoutAllocationsNestedInput
  }

  export type LabourAllocationUncheckedUpdateWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabourAllocationUncheckedUpdateManyWithoutProjectInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportMessageCreateManyRequestInput = {
    id?: string
    user_id: string
    message: string
    created_at?: Date | string
  }

  export type SupportMessageUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutSupport_messagesNestedInput
  }

  export type SupportMessageUncheckedUpdateWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SupportMessageUncheckedUpdateManyWithoutRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    user_id?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentCreateManyInvoiceInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    payment_method: string
    transaction_id?: string | null
    payment_date?: Date | string
    notes?: string | null
    created_at?: Date | string
  }

  export type PaymentUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: StringFieldUpdateOperationsInput | string
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: StringFieldUpdateOperationsInput | string
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUncheckedUpdateManyWithoutInvoiceInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_method?: StringFieldUpdateOperationsInput | string
    transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateManyEmployeeInput = {
    id?: string
    date: Date | string
    status: string
    overtime_hours?: number
    project_id?: string | null
    check_in?: Date | string | null
    check_out?: Date | string | null
    created_at?: Date | string
  }

  export type LabourAllocationCreateManyEmployeeInput = {
    id?: string
    project_id: string
    start_date: Date | string
    end_date?: Date | string | null
    status: string
    created_at?: Date | string
  }

  export type PayrollLineCreateManyEmployeeInput = {
    id?: string
    payroll_id: string
    basic_pay: Decimal | DecimalJsLike | number | string
    overtime_pay: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    total_pay: Decimal | DecimalJsLike | number | string
    status: string
  }

  export type AttendanceUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    overtime_hours?: FloatFieldUpdateOperationsInput | number
    check_in?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    check_out?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutAttendanceNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    overtime_hours?: FloatFieldUpdateOperationsInput | number
    project_id?: NullableStringFieldUpdateOperationsInput | string | null
    check_in?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    check_out?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    overtime_hours?: FloatFieldUpdateOperationsInput | number
    project_id?: NullableStringFieldUpdateOperationsInput | string | null
    check_in?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    check_out?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabourAllocationUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneRequiredWithoutLabour_allocationsNestedInput
  }

  export type LabourAllocationUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LabourAllocationUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: StringFieldUpdateOperationsInput | string
    start_date?: DateTimeFieldUpdateOperationsInput | Date | string
    end_date?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollLineUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    basic_pay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtime_pay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_pay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    payroll?: PayrollUpdateOneRequiredWithoutLinesNestedInput
  }

  export type PayrollLineUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    payroll_id?: StringFieldUpdateOperationsInput | string
    basic_pay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtime_pay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_pay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type PayrollLineUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    payroll_id?: StringFieldUpdateOperationsInput | string
    basic_pay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtime_pay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_pay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type PayrollLineCreateManyPayrollInput = {
    id?: string
    employee_id: string
    basic_pay: Decimal | DecimalJsLike | number | string
    overtime_pay: Decimal | DecimalJsLike | number | string
    deductions?: Decimal | DecimalJsLike | number | string
    total_pay: Decimal | DecimalJsLike | number | string
    status: string
  }

  export type PayrollLineUpdateWithoutPayrollInput = {
    id?: StringFieldUpdateOperationsInput | string
    basic_pay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtime_pay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_pay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
    employee?: EmployeeUpdateOneRequiredWithoutPayroll_itemsNestedInput
  }

  export type PayrollLineUncheckedUpdateWithoutPayrollInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    basic_pay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtime_pay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_pay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type PayrollLineUncheckedUpdateManyWithoutPayrollInput = {
    id?: StringFieldUpdateOperationsInput | string
    employee_id?: StringFieldUpdateOperationsInput | string
    basic_pay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    overtime_pay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    deductions?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    total_pay?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: StringFieldUpdateOperationsInput | string
  }

  export type InventoryTransactionCreateManyItemInput = {
    id?: string
    project_id?: string | null
    type: $Enums.InventoryTransactionType
    quantity: number
    date?: Date | string
    reference_no?: string | null
    notes?: string | null
    created_by: string
    created_at?: Date | string
  }

  export type InventoryTransactionUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: EnumInventoryTransactionTypeFieldUpdateOperationsInput | $Enums.InventoryTransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    project?: ProjectUpdateOneWithoutInventory_logsNestedInput
    user?: UserUpdateOneRequiredWithoutInventory_logsNestedInput
  }

  export type InventoryTransactionUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInventoryTransactionTypeFieldUpdateOperationsInput | $Enums.InventoryTransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InventoryTransactionUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    project_id?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumInventoryTransactionTypeFieldUpdateOperationsInput | $Enums.InventoryTransactionType
    quantity?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderCreateManyPurchase_requestInput = {
    id?: string
    po_number: string
    vendor_id: string
    total_amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.PurchaseStatus
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PurchaseOrderUpdateWithoutPurchase_requestInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutPurchase_ordersNestedInput
    creator?: UserUpdateOneRequiredWithoutPurchase_ordersNestedInput
    grns?: GRNUpdateManyWithoutPurchase_orderNestedInput
    vendor_bills?: VendorBillUpdateManyWithoutPurchase_orderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutPurchase_requestInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    grns?: GRNUncheckedUpdateManyWithoutPurchase_orderNestedInput
    vendor_bills?: VendorBillUncheckedUpdateManyWithoutPurchase_orderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutPurchase_requestInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PurchaseOrderCreateManyVendorInput = {
    id?: string
    po_number: string
    purchase_request_id?: string | null
    total_amount: Decimal | DecimalJsLike | number | string
    status?: $Enums.PurchaseStatus
    created_by: string
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type VendorBillCreateManyVendorInput = {
    id?: string
    bill_number: string
    purchase_order_id: string
    amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    due_date: Date | string
    status?: $Enums.InvoiceStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type PurchaseOrderUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase_request?: PurchaseRequestUpdateOneWithoutPurchase_ordersNestedInput
    creator?: UserUpdateOneRequiredWithoutPurchase_ordersNestedInput
    grns?: GRNUpdateManyWithoutPurchase_orderNestedInput
    vendor_bills?: VendorBillUpdateManyWithoutPurchase_orderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    purchase_request_id?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    grns?: GRNUncheckedUpdateManyWithoutPurchase_orderNestedInput
    vendor_bills?: VendorBillUncheckedUpdateManyWithoutPurchase_orderNestedInput
  }

  export type PurchaseOrderUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    po_number?: StringFieldUpdateOperationsInput | string
    purchase_request_id?: NullableStringFieldUpdateOperationsInput | string | null
    total_amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    status?: EnumPurchaseStatusFieldUpdateOperationsInput | $Enums.PurchaseStatus
    created_by?: StringFieldUpdateOperationsInput | string
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorBillUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    bill_number?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    purchase_order?: PurchaseOrderUpdateOneRequiredWithoutVendor_billsNestedInput
    vendor_payments?: VendorPaymentUpdateManyWithoutVendor_billNestedInput
  }

  export type VendorBillUncheckedUpdateWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    bill_number?: StringFieldUpdateOperationsInput | string
    purchase_order_id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor_payments?: VendorPaymentUncheckedUpdateManyWithoutVendor_billNestedInput
  }

  export type VendorBillUncheckedUpdateManyWithoutVendorInput = {
    id?: StringFieldUpdateOperationsInput | string
    bill_number?: StringFieldUpdateOperationsInput | string
    purchase_order_id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GRNCreateManyPurchase_orderInput = {
    id?: string
    grn_number: string
    received_date?: Date | string
    received_by: string
    notes?: string | null
    created_at?: Date | string
  }

  export type VendorBillCreateManyPurchase_orderInput = {
    id?: string
    bill_number: string
    vendor_id: string
    amount: Decimal | DecimalJsLike | number | string
    tax_amount?: Decimal | DecimalJsLike | number | string | null
    due_date: Date | string
    status?: $Enums.InvoiceStatus
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type GRNUpdateWithoutPurchase_orderInput = {
    id?: StringFieldUpdateOperationsInput | string
    grn_number?: StringFieldUpdateOperationsInput | string
    received_date?: DateTimeFieldUpdateOperationsInput | Date | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    receiver?: UserUpdateOneRequiredWithoutGrnsNestedInput
  }

  export type GRNUncheckedUpdateWithoutPurchase_orderInput = {
    id?: StringFieldUpdateOperationsInput | string
    grn_number?: StringFieldUpdateOperationsInput | string
    received_date?: DateTimeFieldUpdateOperationsInput | Date | string
    received_by?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type GRNUncheckedUpdateManyWithoutPurchase_orderInput = {
    id?: StringFieldUpdateOperationsInput | string
    grn_number?: StringFieldUpdateOperationsInput | string
    received_date?: DateTimeFieldUpdateOperationsInput | Date | string
    received_by?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorBillUpdateWithoutPurchase_orderInput = {
    id?: StringFieldUpdateOperationsInput | string
    bill_number?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor?: VendorUpdateOneRequiredWithoutVendor_billsNestedInput
    vendor_payments?: VendorPaymentUpdateManyWithoutVendor_billNestedInput
  }

  export type VendorBillUncheckedUpdateWithoutPurchase_orderInput = {
    id?: StringFieldUpdateOperationsInput | string
    bill_number?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
    vendor_payments?: VendorPaymentUncheckedUpdateManyWithoutVendor_billNestedInput
  }

  export type VendorBillUncheckedUpdateManyWithoutPurchase_orderInput = {
    id?: StringFieldUpdateOperationsInput | string
    bill_number?: StringFieldUpdateOperationsInput | string
    vendor_id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    tax_amount?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    due_date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: EnumInvoiceStatusFieldUpdateOperationsInput | $Enums.InvoiceStatus
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorPaymentCreateManyVendor_billInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    payment_date?: Date | string
    payment_method: string
    reference_no?: string | null
    notes?: string | null
    created_at?: Date | string
  }

  export type VendorPaymentUpdateWithoutVendor_billInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: StringFieldUpdateOperationsInput | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorPaymentUncheckedUpdateWithoutVendor_billInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: StringFieldUpdateOperationsInput | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VendorPaymentUncheckedUpdateManyWithoutVendor_billInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    payment_date?: DateTimeFieldUpdateOperationsInput | Date | string
    payment_method?: StringFieldUpdateOperationsInput | string
    reference_no?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankTransactionCreateManyBank_accountInput = {
    id?: string
    date: Date | string
    description: string
    amount: Decimal | DecimalJsLike | number | string
    reference?: string | null
    status?: string
    type: string
    system_transaction_id?: string | null
    created_at?: Date | string
    updated_at?: Date | string
  }

  export type BankTransactionUpdateWithoutBank_accountInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    system_transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankTransactionUncheckedUpdateWithoutBank_accountInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    system_transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BankTransactionUncheckedUpdateManyWithoutBank_accountInput = {
    id?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    description?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    reference?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    system_transaction_id?: NullableStringFieldUpdateOperationsInput | string | null
    created_at?: DateTimeFieldUpdateOperationsInput | Date | string
    updated_at?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}